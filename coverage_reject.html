
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cli: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/mrz1836/atlas/internal/cli/abandon.go (0.0%)</option>

				<option value="file1">github.com/mrz1836/atlas/internal/cli/ai_config.go (0.0%)</option>

				<option value="file2">github.com/mrz1836/atlas/internal/cli/approve.go (3.6%)</option>

				<option value="file3">github.com/mrz1836/atlas/internal/cli/backlog.go (0.0%)</option>

				<option value="file4">github.com/mrz1836/atlas/internal/cli/backlog_add.go (0.0%)</option>

				<option value="file5">github.com/mrz1836/atlas/internal/cli/backlog_dismiss.go (0.0%)</option>

				<option value="file6">github.com/mrz1836/atlas/internal/cli/backlog_list.go (0.0%)</option>

				<option value="file7">github.com/mrz1836/atlas/internal/cli/backlog_promote.go (0.0%)</option>

				<option value="file8">github.com/mrz1836/atlas/internal/cli/backlog_view.go (0.0%)</option>

				<option value="file9">github.com/mrz1836/atlas/internal/cli/bell.go (0.0%)</option>

				<option value="file10">github.com/mrz1836/atlas/internal/cli/checkpoint.go (0.0%)</option>

				<option value="file11">github.com/mrz1836/atlas/internal/cli/cleanup.go (0.0%)</option>

				<option value="file12">github.com/mrz1836/atlas/internal/cli/completion.go (0.0%)</option>

				<option value="file13">github.com/mrz1836/atlas/internal/cli/config_ai.go (0.0%)</option>

				<option value="file14">github.com/mrz1836/atlas/internal/cli/config_notification.go (0.0%)</option>

				<option value="file15">github.com/mrz1836/atlas/internal/cli/config_show.go (0.0%)</option>

				<option value="file16">github.com/mrz1836/atlas/internal/cli/config_validation.go (0.0%)</option>

				<option value="file17">github.com/mrz1836/atlas/internal/cli/context.go (0.0%)</option>

				<option value="file18">github.com/mrz1836/atlas/internal/cli/flags.go (11.8%)</option>

				<option value="file19">github.com/mrz1836/atlas/internal/cli/format.go (0.0%)</option>

				<option value="file20">github.com/mrz1836/atlas/internal/cli/hook.go (0.0%)</option>

				<option value="file21">github.com/mrz1836/atlas/internal/cli/init.go (0.0%)</option>

				<option value="file22">github.com/mrz1836/atlas/internal/cli/lint.go (0.0%)</option>

				<option value="file23">github.com/mrz1836/atlas/internal/cli/logger.go (0.0%)</option>

				<option value="file24">github.com/mrz1836/atlas/internal/cli/notification_config.go (0.0%)</option>

				<option value="file25">github.com/mrz1836/atlas/internal/cli/reject.go (47.0%)</option>

				<option value="file26">github.com/mrz1836/atlas/internal/cli/resume.go (0.0%)</option>

				<option value="file27">github.com/mrz1836/atlas/internal/cli/root.go (5.5%)</option>

				<option value="file28">github.com/mrz1836/atlas/internal/cli/start.go (0.0%)</option>

				<option value="file29">github.com/mrz1836/atlas/internal/cli/status.go (0.0%)</option>

				<option value="file30">github.com/mrz1836/atlas/internal/cli/test.go (0.0%)</option>

				<option value="file31">github.com/mrz1836/atlas/internal/cli/upgrade.go (0.0%)</option>

				<option value="file32">github.com/mrz1836/atlas/internal/cli/upgrade_release.go (0.0%)</option>

				<option value="file33">github.com/mrz1836/atlas/internal/cli/utility.go (11.9%)</option>

				<option value="file34">github.com/mrz1836/atlas/internal/cli/validate.go (0.0%)</option>

				<option value="file35">github.com/mrz1836/atlas/internal/cli/validation_config.go (0.0%)</option>

				<option value="file36">github.com/mrz1836/atlas/internal/cli/workspace.go (0.0%)</option>

				<option value="file37">github.com/mrz1836/atlas/internal/cli/workspace_close.go (0.0%)</option>

				<option value="file38">github.com/mrz1836/atlas/internal/cli/workspace_destroy.go (0.0%)</option>

				<option value="file39">github.com/mrz1836/atlas/internal/cli/workspace_list.go (0.0%)</option>

				<option value="file40">github.com/mrz1836/atlas/internal/cli/workspace_logs.go (0.0%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        stderrors "errors"
        "fmt"
        "io"
        "os"

        "github.com/charmbracelet/huh"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/domain"
        "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/task"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/workspace"
        "github.com/rs/zerolog"
        "github.com/spf13/cobra"
)

// AddAbandonCommand adds the abandon command to the root command.
func AddAbandonCommand(root *cobra.Command) <span class="cov0" title="0">{
        root.AddCommand(newAbandonCmd())
}</span>

// newAbandonCmd creates the abandon command.
func newAbandonCmd() *cobra.Command <span class="cov0" title="0">{
        var force bool

        cmd := &amp;cobra.Command{
                Use:   "abandon &lt;workspace&gt;",
                Short: "Abandon a failed task while preserving the branch and worktree",
                Long: `Abandon a task that is in an error state (validation_failed, gh_failed, ci_failed, ci_timeout).

Use --force to:
  - Skip the confirmation prompt
  - Force-abandon running tasks (terminates tracked processes and marks task as abandoned)

The task will be marked as abandoned, but the git branch and worktree will be preserved
for manual work. You can still access the code at the worktree path.

Examples:
  atlas abandon auth-fix           # Abandon task with confirmation
  atlas abandon auth-fix --force   # Force-abandon without confirmation or force-abandon running task`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        err := runAbandon(cmd.Context(), cmd, os.Stdout, args[0], force, "")
                        // If JSON error was already output, silence cobra's error printing
                        // but still return error for non-zero exit code
                        if stderrors.Is(err, errors.ErrJSONErrorOutput) </span><span class="cov0" title="0">{
                                cmd.SilenceErrors = true
                        }</span>
                        <span class="cov0" title="0">return err</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;force, "force", "f", false, "Skip confirmation prompt")

        return cmd</span>
}

// runAbandon executes the abandon command.
func runAbandon(ctx context.Context, cmd *cobra.Command, w io.Writer, workspaceName string, force bool, storeBaseDir string) error <span class="cov0" title="0">{
        // Check for cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        // Get output format from global flags
        <span class="cov0" title="0">outputFormat := cmd.Flag("output").Value.String()

        return runAbandonWithOutput(ctx, w, workspaceName, force, storeBaseDir, outputFormat)</span>
}

// runAbandonWithOutput executes the abandon command with explicit output format.
func runAbandonWithOutput(ctx context.Context, w io.Writer, workspaceName string, force bool, storeBaseDir, outputFormat string) error <span class="cov0" title="0">{
        logger := Logger()
        tui.CheckNoColor()

        // Set up workspace and task stores
        wsMgr, ws, err := setupWorkspace(ctx, workspaceName, storeBaseDir, outputFormat, w, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">taskStore, currentTask, err := getLatestTask(ctx, workspaceName, storeBaseDir, outputFormat, w, logger)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate and confirm abandonment
        <span class="cov0" title="0">if err := validateAbandonability(currentTask.Status, force, outputFormat, w, workspaceName, currentTask.ID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !force </span><span class="cov0" title="0">{
                if err := confirmAbandonmentInteractive(workspaceName, currentTask, outputFormat, w); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Execute abandonment
        <span class="cov0" title="0">return executeAbandon(ctx, w, wsMgr, taskStore, currentTask, ws, workspaceName, force, outputFormat, logger)</span>
}

// setupWorkspace creates workspace manager and retrieves workspace.
func setupWorkspace(ctx context.Context, workspaceName, storeBaseDir, outputFormat string, w io.Writer, logger zerolog.Logger) (workspace.Manager, *domain.Workspace, error) <span class="cov0" title="0">{
        wsStore, err := workspace.NewFileStore(storeBaseDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, handleAbandonError(outputFormat, w, workspaceName, "", fmt.Errorf("failed to create workspace store: %w", err))
        }</span>

        <span class="cov0" title="0">repoPath, err := detectRepoPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, handleAbandonError(outputFormat, w, workspaceName, "", fmt.Errorf("not in a git repository: %w", err))
        }</span>

        <span class="cov0" title="0">wtRunner, err := workspace.NewGitWorktreeRunner(ctx, repoPath, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, handleAbandonError(outputFormat, w, workspaceName, "", fmt.Errorf("failed to create worktree runner: %w", err))
        }</span>

        <span class="cov0" title="0">wsMgr := workspace.NewManager(wsStore, wtRunner, logger)
        ws, err := wsMgr.Get(ctx, workspaceName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, handleAbandonError(outputFormat, w, workspaceName, "", fmt.Errorf("failed to get workspace: %w", err))
        }</span>

        <span class="cov0" title="0">return wsMgr, ws, nil</span>
}

// getLatestTask retrieves the latest task for the workspace.
func getLatestTask(ctx context.Context, workspaceName, storeBaseDir, outputFormat string, w io.Writer, logger zerolog.Logger) (*task.FileStore, *domain.Task, error) <span class="cov0" title="0">{
        taskStore, err := task.NewFileStore(storeBaseDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, handleAbandonError(outputFormat, w, workspaceName, "", fmt.Errorf("failed to create task store: %w", err))
        }</span>

        <span class="cov0" title="0">tasks, err := taskStore.List(ctx, workspaceName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, handleAbandonError(outputFormat, w, workspaceName, "", fmt.Errorf("failed to list tasks: %w", err))
        }</span>

        <span class="cov0" title="0">if len(tasks) == 0 </span><span class="cov0" title="0">{
                return nil, nil, handleAbandonError(outputFormat, w, workspaceName, "", fmt.Errorf("no tasks found in workspace '%s': %w", workspaceName, errors.ErrNoTasksFound))
        }</span>

        <span class="cov0" title="0">currentTask := tasks[0]
        logger.Debug().
                Str("workspace_name", workspaceName).
                Str("task_id", currentTask.ID).
                Str("status", string(currentTask.Status)).
                Msg("found task to abandon")

        return taskStore, currentTask, nil</span>
}

// validateAbandonability checks if the task can be abandoned.
func validateAbandonability(status constants.TaskStatus, force bool, outputFormat string, w io.Writer, workspaceName, taskID string) error <span class="cov0" title="0">{
        if !task.CanAbandon(status) </span><span class="cov0" title="0">{
                if !force &amp;&amp; task.CanForceAbandon(status) </span><span class="cov0" title="0">{
                        return handleAbandonError(outputFormat, w, workspaceName, taskID,
                                fmt.Errorf("%w: task status %s cannot be abandoned without --force",
                                        errors.ErrInvalidTransition, status))
                }</span>
                <span class="cov0" title="0">if !task.CanForceAbandon(status) </span><span class="cov0" title="0">{
                        return handleAbandonError(outputFormat, w, workspaceName, taskID,
                                fmt.Errorf("%w: task status %s cannot be abandoned",
                                        errors.ErrInvalidTransition, status))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// confirmAbandonmentInteractive handles interactive confirmation.
func confirmAbandonmentInteractive(workspaceName string, currentTask *domain.Task, outputFormat string, w io.Writer) error <span class="cov0" title="0">{
        if !terminalCheck() </span><span class="cov0" title="0">{
                return handleAbandonError(outputFormat, w, workspaceName, currentTask.ID,
                        fmt.Errorf("cannot abandon task: %w", errors.ErrNonInteractiveMode))
        }</span>

        <span class="cov0" title="0">confirmed, err := confirmAbandon(workspaceName, currentTask.Status == constants.TaskStatusRunning)
        if err != nil </span><span class="cov0" title="0">{
                return handleAbandonError(outputFormat, w, workspaceName, currentTask.ID,
                        fmt.Errorf("failed to get confirmation: %w", err))
        }</span>

        <span class="cov0" title="0">if !confirmed </span><span class="cov0" title="0">{
                out := tui.NewOutput(w, outputFormat)
                out.Info("Abandonment canceled")
                return nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// executeAbandon performs the actual abandonment and updates workspace.
func executeAbandon(ctx context.Context, w io.Writer, wsMgr workspace.Manager, taskStore *task.FileStore,
        currentTask *domain.Task, ws *domain.Workspace, workspaceName string, force bool, outputFormat string, logger zerolog.Logger,
) error <span class="cov0" title="0">{
        engine := task.NewEngine(taskStore, nil, task.DefaultEngineConfig(), logger)

        reason := "User requested abandonment"
        if err := engine.Abandon(ctx, currentTask, reason, force); err != nil </span><span class="cov0" title="0">{
                return handleAbandonError(outputFormat, w, workspaceName, currentTask.ID,
                        fmt.Errorf("failed to abandon task: %w", err))
        }</span>

        <span class="cov0" title="0">if err := wsMgr.UpdateStatus(ctx, workspaceName, constants.WorkspaceStatusPaused); err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Str("workspace_name", workspaceName).Msg("failed to update workspace status to paused")
        }</span>

        <span class="cov0" title="0">if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return outputAbandonSuccessJSON(w, workspaceName, currentTask.ID, ws.Branch, ws.WorktreePath)
        }</span>

        <span class="cov0" title="0">out := tui.NewOutput(w, outputFormat)
        tui.DisplayAbandonmentSuccess(out, currentTask, ws)
        return nil</span>
}

// createAbandonConfirmForm is the default factory for creating abandon confirmation forms.
// This variable can be overridden in tests to inject mock forms.
//
//nolint:gochecknoglobals // Test injection point - standard Go testing pattern
var createAbandonConfirmForm = defaultCreateAbandonConfirmForm

// formRunner is an interface that matches huh.Form's Run method.
type formRunner interface {
        Run() error
}

// defaultCreateAbandonConfirmForm creates the actual Charm Huh form for abandon confirmation.
func defaultCreateAbandonConfirmForm(workspaceName string, isRunning bool, confirm *bool) formRunner <span class="cov0" title="0">{
        description := "Branch and worktree will be preserved for manual work."
        if isRunning </span><span class="cov0" title="0">{
                description = "⚠️  WARNING: Task is currently running. This will attempt to terminate processes and mark the task as abandoned.\n\n" + description
        }</span>

        <span class="cov0" title="0">return huh.NewForm(
                huh.NewGroup(
                        huh.NewConfirm().
                                Title(fmt.Sprintf("Abandon task in workspace '%s'?", workspaceName)).
                                Description(description).
                                Affirmative("Yes, abandon").
                                Negative("No, cancel").
                                Value(confirm),
                ),
        )</span>
}

// confirmAbandon prompts the user for confirmation before abandoning a task.
func confirmAbandon(workspaceName string, isRunning bool) (bool, error) <span class="cov0" title="0">{
        var confirm bool
        form := createAbandonConfirmForm(workspaceName, isRunning, &amp;confirm)

        if err := form.Run(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return confirm, nil</span>
}

// abandonResult represents the JSON output for abandon operations.
type abandonResult struct {
        Status       string `json:"status"`
        Workspace    string `json:"workspace"`
        TaskID       string `json:"task_id,omitempty"`
        Branch       string `json:"branch,omitempty"`
        WorktreePath string `json:"worktree_path,omitempty"`
        Error        string `json:"error,omitempty"`
}

// handleAbandonError handles errors based on output format.
func handleAbandonError(format string, w io.Writer, workspaceName, taskID string, err error) error <span class="cov0" title="0">{
        return HandleCommandError(format, w, abandonResult{
                Status:    "error",
                Workspace: workspaceName,
                TaskID:    taskID,
                Error:     err.Error(),
        }, err)
}</span>

// outputAbandonSuccessJSON outputs a success result as JSON.
func outputAbandonSuccessJSON(w io.Writer, workspaceName, taskID, branch, worktreePath string) error <span class="cov0" title="0">{
        return encodeJSONIndented(w, abandonResult{
                Status:       "abandoned",
                Workspace:    workspaceName,
                TaskID:       taskID,
                Branch:       branch,
                WorktreePath: worktreePath,
        })
}</span>

// outputAbandonErrorJSON outputs an error result as JSON.
// This function is kept for test compatibility but delegates to HandleCommandError.
func outputAbandonErrorJSON(w io.Writer, workspaceName, taskID, errMsg string) error <span class="cov0" title="0">{
        // Use encodeJSONIndented directly to maintain the original behavior
        // (returns encoding error, not ErrJSONErrorOutput)
        return encodeJSONIndented(w, abandonResult{
                Status:    "error",
                Workspace: workspaceName,
                TaskID:    taskID,
                Error:     errMsg,
        })
}</span>
</pre>

		<pre class="file" id="file1" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "fmt"
        "os"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/charmbracelet/huh"
        atlaserrors "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/tui"
)

// AIProviderConfig holds AI provider configuration values collected from user input.
// This struct is used for collecting configuration before saving.
type AIProviderConfig struct {
        // Model is the default Claude model to use (sonnet|opus|haiku).
        Model string
        // APIKeyEnvVar is the name of the environment variable containing the API key.
        APIKeyEnvVar string
        // Timeout is the default timeout for AI operations as a duration string.
        Timeout string
        // MaxTurns is the maximum number of turns per AI step.
        MaxTurns int
}

// AIConfigDefaults returns the default values for AI configuration.
func AIConfigDefaults() AIProviderConfig <span class="cov0" title="0">{
        return AIProviderConfig{
                Model:        "sonnet",
                APIKeyEnvVar: "ANTHROPIC_API_KEY",
                Timeout:      "30m",
                MaxTurns:     10,
        }
}</span>

// Model constants for descriptive labels.
const (
        ModelSonnet = "sonnet"
        ModelOpus   = "opus"
        ModelHaiku  = "haiku"
)

// getModelOptions returns the available model options for selection.
func getModelOptions() []huh.Option[string] <span class="cov0" title="0">{
        return []huh.Option[string]{
                huh.NewOption("Claude Sonnet (faster, balanced)", ModelSonnet),
                huh.NewOption("Claude Opus (most capable)", ModelOpus),
                huh.NewOption("Claude Haiku (fast, cost-efficient)", ModelHaiku),
        }
}</span>

// envVarNameRegex validates environment variable names.
// Must start with letter or underscore, followed by letters, digits, or underscores.
var envVarNameRegex = regexp.MustCompile(`^[a-zA-Z_][a-zA-Z0-9_]*$`)

// NewAIConfigForm creates a Charm Huh form for AI configuration.
// The form collects model, API key env var, timeout, and max turns settings.
// IMPORTANT: maxTurnsStr must be passed from the caller so the value can be
// captured after form.Run() completes. The caller is responsible for parsing
// maxTurnsStr back to cfg.MaxTurns.
func NewAIConfigForm(cfg *AIProviderConfig, maxTurnsStr *string) *huh.Form <span class="cov0" title="0">{
        return huh.NewForm(
                huh.NewGroup(
                        huh.NewSelect[string]().
                                Title("Default AI Model").
                                Description("Choose the default Claude model for ATLAS tasks").
                                Options(getModelOptions()...).
                                Value(&amp;cfg.Model),
                        huh.NewInput().
                                Title("API Key Environment Variable").
                                Description("Name of the environment variable containing your Anthropic API key").
                                Value(&amp;cfg.APIKeyEnvVar).
                                Placeholder("ANTHROPIC_API_KEY").
                                Validate(validateEnvVarName),
                        huh.NewInput().
                                Title("Default AI Timeout").
                                Description("Maximum time for AI operations (e.g., 30m, 1h, 1h30m)").
                                Value(&amp;cfg.Timeout).
                                Placeholder("30m").
                                Validate(validateTimeoutFormat),
                        huh.NewInput().
                                Title("Max Turns per Step").
                                Description("Maximum number of AI turns per step (1-100)").
                                Value(maxTurnsStr).
                                Placeholder("10").
                                Validate(validateMaxTurns),
                ),
        ).WithTheme(tui.AtlasTheme())
}</span>

// createAIConfigForm is the default factory for creating AI config forms.
// This variable can be overridden in tests to inject mock forms.
//
//nolint:gochecknoglobals // Test injection point - standard Go testing pattern
var createAIConfigForm = defaultCreateAIConfigForm

// defaultCreateAIConfigForm creates the actual Charm Huh form for AI configuration.
func defaultCreateAIConfigForm(cfg *AIProviderConfig, maxTurnsStr *string) formRunner <span class="cov0" title="0">{
        return NewAIConfigForm(cfg, maxTurnsStr)
}</span>

// CollectAIConfigInteractive runs the AI configuration form and returns the collected config.
// It validates all inputs and handles form errors.
func CollectAIConfigInteractive(ctx context.Context, cfg *AIProviderConfig) error <span class="cov0" title="0">{
        // Check cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">defaults := AIConfigDefaults()

        // Initialize with defaults if empty
        if cfg.Model == "" </span><span class="cov0" title="0">{
                cfg.Model = defaults.Model
        }</span>
        <span class="cov0" title="0">if cfg.APIKeyEnvVar == "" </span><span class="cov0" title="0">{
                cfg.APIKeyEnvVar = defaults.APIKeyEnvVar
        }</span>
        <span class="cov0" title="0">if cfg.Timeout == "" </span><span class="cov0" title="0">{
                cfg.Timeout = defaults.Timeout
        }</span>
        <span class="cov0" title="0">if cfg.MaxTurns == 0 </span><span class="cov0" title="0">{
                cfg.MaxTurns = defaults.MaxTurns
        }</span>

        // Create string for max turns input (huh.Input works with strings)
        // This must be defined here so we can capture the value after form.Run()
        <span class="cov0" title="0">maxTurnsStr := strconv.Itoa(cfg.MaxTurns)

        form := createAIConfigForm(cfg, &amp;maxTurnsStr)
        if err := form.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("AI configuration failed: %w", err)
        }</span>

        // Parse maxTurnsStr back to cfg.MaxTurns after form completes
        <span class="cov0" title="0">cfg.MaxTurns = ParseMaxTurnsWithDefault(maxTurnsStr, defaults.MaxTurns)

        return nil</span>
}

// CollectAIConfigNonInteractive returns a configuration with default values.
// Used when running in non-interactive mode.
func CollectAIConfigNonInteractive() AIProviderConfig <span class="cov0" title="0">{
        return AIConfigDefaults()
}</span>

// validateEnvVarName validates that the input is a valid environment variable name.
func validateEnvVarName(s string) error <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: environment variable name", atlaserrors.ErrEmptyValue)
        }</span>
        <span class="cov0" title="0">if !IsValidEnvVarName(s) </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: must start with letter or underscore, contain only letters, digits, or underscores", atlaserrors.ErrInvalidEnvVarName)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IsValidEnvVarName checks if a string is a valid environment variable name.
// A valid name starts with a letter or underscore and contains only
// letters, digits, or underscores.
func IsValidEnvVarName(name string) bool <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return envVarNameRegex.MatchString(name)</span>
}

// validateTimeoutFormat validates that the input is a valid duration string.
func validateTimeoutFormat(s string) error <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: timeout", atlaserrors.ErrEmptyValue)
        }</span>
        <span class="cov0" title="0">duration, err := time.ParseDuration(s)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: use formats like 30m, 1h, 1h30m", atlaserrors.ErrInvalidDuration)
        }</span>
        <span class="cov0" title="0">if duration &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: timeout must be positive", atlaserrors.ErrInvalidDuration)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateMaxTurns validates that the input is a valid max turns value (1-100).
func validateMaxTurns(s string) error <span class="cov0" title="0">{
        s = strings.TrimSpace(s)
        if s == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: max turns", atlaserrors.ErrEmptyValue)
        }</span>
        <span class="cov0" title="0">val, err := strconv.Atoi(s)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: max turns must be a number", atlaserrors.ErrValueOutOfRange)
        }</span>
        <span class="cov0" title="0">if val &lt; 1 || val &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: max turns must be between 1 and 100", atlaserrors.ErrValueOutOfRange)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CheckAPIKeyExists checks if the specified environment variable is set.
// Returns whether the key exists and a warning message if it doesn't.
func CheckAPIKeyExists(envVarName string) (exists bool, warning string) <span class="cov0" title="0">{
        value := os.Getenv(envVarName)
        if value == "" </span><span class="cov0" title="0">{
                return false, fmt.Sprintf("Warning: %s is not set in your environment. ATLAS will fail to run AI operations until this is configured.", envVarName)
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

// ValidateAIConfig validates an AIProviderConfig and returns any validation errors.
func ValidateAIConfig(cfg *AIProviderConfig) error <span class="cov0" title="0">{
        if cfg.Model == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: model", atlaserrors.ErrEmptyValue)
        }</span>
        <span class="cov0" title="0">if cfg.Model != ModelSonnet &amp;&amp; cfg.Model != ModelOpus &amp;&amp; cfg.Model != ModelHaiku </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: must be 'sonnet', 'opus', or 'haiku'", atlaserrors.ErrInvalidModel)
        }</span>
        <span class="cov0" title="0">if err := validateEnvVarName(cfg.APIKeyEnvVar); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := validateTimeoutFormat(cfg.Timeout); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if cfg.MaxTurns &lt; 1 || cfg.MaxTurns &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: max turns must be between 1 and 100", atlaserrors.ErrValueOutOfRange)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ParseMaxTurnsWithDefault parses a string to int, returning a default on error.
func ParseMaxTurnsWithDefault(s string, defaultVal int) int <span class="cov0" title="0">{
        s = strings.TrimSpace(s)
        if s == "" </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">val, err := strconv.Atoi(s)
        if err != nil || val &lt; 1 || val &gt; 100 </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return val</span>
}

// ValidateTimeoutWithDefault validates and returns a timeout string.
// If the input is invalid, returns the default value.
func ValidateTimeoutWithDefault(s, defaultVal string) string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">duration, err := time.ParseDuration(s)
        if err != nil || duration &lt;= 0 </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return s</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "os/exec"
        "strconv"
        "strings"

        "github.com/mrz1836/atlas/internal/backlog"
        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/domain"
        atlaserrors "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/git"
        "github.com/mrz1836/atlas/internal/task"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/workspace"
        "github.com/spf13/cobra"
        "golang.org/x/term"
)

// AddApproveCommand adds the approve command to the root command.
func AddApproveCommand(root *cobra.Command) <span class="cov0" title="0">{
        root.AddCommand(newApproveCmd())
}</span>

// approveOptions contains all options for the approve command.
type approveOptions struct {
        workspace    string // Optional workspace name
        autoApprove  bool   // Skip interactive menu and approve directly
        closeWS      bool   // Also close the workspace after approval
        mergeMessage string // Custom message for approve+merge operations
}

// newApproveCmd creates the approve command.
func newApproveCmd() *cobra.Command <span class="cov0" title="0">{
        var autoApprove bool
        var closeWS bool
        var mergeMessage string

        cmd := &amp;cobra.Command{
                Use:   "approve [workspace]",
                Short: "Approve a completed task",
                Long: `Approve a task that has passed validation and is awaiting approval.

If multiple tasks are awaiting approval, you'll be prompted to select one.
You can also specify a workspace name directly to skip the selection.

The approval flow shows a summary of the task and provides options to:
  - Approve and complete the task
  - Approve and close the workspace (removes worktree, preserves history)
  - Approve, merge PR, and close workspace (all in one)
  - View the git diff of changes
  - View task execution logs
  - Open the PR in your browser
  - Reject the task (redirects to atlas reject)
  - Cancel and return

Non-interactive mode:
  Use --auto-approve to skip the interactive menu and approve directly.
  In non-interactive environments (pipes, CI), --auto-approve is required.

Examples:
  atlas approve              # Interactive selection if multiple tasks
  atlas approve my-feature   # Approve task in my-feature workspace
  atlas approve my-feature --auto-approve  # Approve directly without menu
  atlas approve my-feature --close         # Approve and close workspace
  atlas approve my-feature --message "Merged by CI"  # Custom merge message
  atlas approve -o json my-feature  # Output result as JSON`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        opts := approveOptions{
                                autoApprove:  autoApprove,
                                closeWS:      closeWS,
                                mergeMessage: mergeMessage,
                        }
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                opts.workspace = args[0]
                        }</span>
                        <span class="cov0" title="0">return runApprove(cmd.Context(), cmd, os.Stdout, opts)</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;autoApprove, "auto-approve", false, "Skip interactive menu and approve directly")
        cmd.Flags().BoolVar(&amp;closeWS, "close", false, "Also close the workspace after approval (removes worktree, preserves history)")
        cmd.Flags().StringVar(&amp;mergeMessage, "message", "", "Custom message for approve+merge (overrides config)")

        return cmd</span>
}

// approveResponse represents the JSON output for approve operations.
type approveResponse struct {
        Success         bool          `json:"success"`
        Workspace       workspaceInfo `json:"workspace"`
        Task            taskInfo      `json:"task"`
        PRURL           string        `json:"pr_url,omitempty"`
        WorkspaceClosed bool          `json:"workspace_closed,omitempty"`
        Warning         string        `json:"warning,omitempty"`
        Error           string        `json:"error,omitempty"`
}

// approvalAction represents actions available in the approval menu.
type approvalAction string

const (
        actionApprove           approvalAction = "approve"
        actionApproveAndClose   approvalAction = "approve_and_close"
        actionApproveMergeClose approvalAction = "approve_merge_close"
        actionViewDiff          approvalAction = "view_diff"
        actionViewLogs          approvalAction = "view_logs"
        actionOpenPR            approvalAction = "open_pr"
        actionReject            approvalAction = "reject"
        actionCancel            approvalAction = "cancel"
)

// approveStep represents a step in the approval workflow
type approveStep struct {
        name    string          // Display name (e.g., "Add PR Review")
        execute approveStepFunc // Function to execute
}

// approveStepFunc executes a step and returns an optional message
type approveStepFunc func(ctx context.Context, stepCtx *approveStepContext) (message string, err error)

// approveStepContext contains context needed for executing approval steps
type approveStepContext struct {
        out       tui.Output
        taskStore task.Store
        ws        *domain.Workspace
        t         *domain.Task
        notifier  *tui.Notifier
        hubRunner git.HubRunner
        message   string // PR merge message
}

// approveStepTracker manages step execution and progress display
type approveStepTracker struct {
        steps        []approveStep
        currentStep  int
        totalSteps   int
        out          tui.Output
        outputFormat string // Skip progress in JSON mode
}

// Injection points for testing - these can be overridden in tests
//
//nolint:gochecknoglobals // Test injection points - standard Go testing pattern
var (
        // tuiSelectFunc allows injecting tui.Select for testing
        tuiSelectFunc = tui.Select

        // selectApprovalActionFunc allows injecting selectApprovalAction for testing
        selectApprovalActionFunc = selectApprovalAction

        // execCommandContextFunc allows injecting exec.CommandContext for testing
        execCommandContextFunc = exec.CommandContext
)

// runApprove executes the approve command.
func runApprove(ctx context.Context, cmd *cobra.Command, w io.Writer, opts approveOptions) error <span class="cov0" title="0">{
        // Check context cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">logger := Logger()
        outputFormat := cmd.Flag("output").Value.String()

        // Respect NO_COLOR environment variable
        tui.CheckNoColor()

        out := tui.NewOutput(w, outputFormat)

        // Detect non-interactive mode
        isNonInteractive := outputFormat == OutputJSON || !term.IsTerminal(int(os.Stdin.Fd()))

        // JSON mode requires workspace argument (no interactive selection)
        if outputFormat == OutputJSON &amp;&amp; opts.workspace == "" </span><span class="cov0" title="0">{
                return handleApproveError(outputFormat, w, "", fmt.Errorf("workspace argument required with --output json: %w", atlaserrors.ErrInvalidArgument))
        }</span>

        // Non-interactive mode requires --auto-approve or JSON output
        <span class="cov0" title="0">if isNonInteractive &amp;&amp; !opts.autoApprove &amp;&amp; outputFormat != OutputJSON </span><span class="cov0" title="0">{
                return atlaserrors.NewExitCode2Error(
                        fmt.Errorf("use --auto-approve in non-interactive mode: %w", atlaserrors.ErrApprovalRequired))
        }</span>

        // Create stores and find awaiting tasks
        <span class="cov0" title="0">selectedWS, selectedTask, err := findAndSelectTask(ctx, outputFormat, w, out, opts, isNonInteractive)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("find awaiting task: %w", err)
        }</span>
        <span class="cov0" title="0">if selectedWS == nil </span><span class="cov0" title="0">{
                // No tasks awaiting approval (message already shown)
                return nil
        }</span>

        <span class="cov0" title="0">logger.Debug().
                Str("workspace_name", selectedWS.Name).
                Str("task_id", selectedTask.ID).
                Str("status", string(selectedTask.Status)).
                Msg("selected task for approval")

        // Create task store for updates
        taskStore, err := task.NewFileStore("")
        if err != nil </span><span class="cov0" title="0">{
                return handleApproveError(outputFormat, w, "", fmt.Errorf("failed to create task store: %w", err))
        }</span>

        // Load config for notification settings
        <span class="cov0" title="0">cfg, err := config.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("failed to load config, using default notification settings")
                cfg = config.DefaultConfig()
        }</span>

        // Create notifier
        <span class="cov0" title="0">notifier := tui.NewNotifier(cfg.Notifications.Bell, false)

        // JSON mode: approve directly without interactive menu
        if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return approveAndOutputJSON(ctx, w, taskStore, selectedWS, selectedTask, opts.closeWS)
        }</span>

        // Auto-approve mode: approve directly without interactive menu
        <span class="cov0" title="0">if opts.autoApprove </span><span class="cov0" title="0">{
                return runAutoApprove(ctx, out, taskStore, selectedWS, selectedTask, notifier, opts.closeWS)
        }</span>

        // Get verbose flag from global flags
        <span class="cov0" title="0">verbose := cmd.Flag("verbose").Value.String() == "true"

        // Interactive approval flow
        return runInteractiveApproval(ctx, out, taskStore, selectedWS, selectedTask, notifier, verbose)</span>
}

// findAndSelectTask finds awaiting tasks and selects one based on options.
func findAndSelectTask(ctx context.Context, outputFormat string, w io.Writer, out tui.Output, opts approveOptions, isNonInteractive bool) (*domain.Workspace, *domain.Task, error) <span class="cov0" title="0">{
        // Create stores
        wsStore, taskStore, err := CreateStores("")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, handleApproveError(outputFormat, w, "", err)
        }</span>

        // Find tasks awaiting approval
        <span class="cov0" title="0">awaitingTasks, err := findAwaitingApprovalTasks(ctx, wsStore, taskStore)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, handleApproveError(outputFormat, w, "", err)
        }</span>

        // Handle case where no tasks are awaiting approval
        <span class="cov0" title="0">if len(awaitingTasks) == 0 </span><span class="cov0" title="0">{
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return nil, nil, handleApproveError(outputFormat, w, "", atlaserrors.ErrNoTasksFound)
                }</span>
                <span class="cov0" title="0">out.Info("No tasks awaiting approval.")
                out.Info("Run 'atlas status' to see all workspace statuses.")
                return nil, nil, nil</span>
        }

        // Select the appropriate task
        <span class="cov0" title="0">return selectApprovalTask(outputFormat, w, out, opts, awaitingTasks, isNonInteractive)</span>
}

// selectApprovalTask selects a task from the awaiting tasks based on options.
func selectApprovalTask(outputFormat string, w io.Writer, out tui.Output, opts approveOptions, awaitingTasks []awaitingTask, isNonInteractive bool) (*domain.Workspace, *domain.Task, error) <span class="cov0" title="0">{
        // If workspace provided, find it directly
        if opts.workspace != "" </span><span class="cov0" title="0">{
                for _, at := range awaitingTasks </span><span class="cov0" title="0">{
                        if at.workspace.Name == opts.workspace </span><span class="cov0" title="0">{
                                return at.workspace, at.task, nil
                        }</span>
                }
                <span class="cov0" title="0">return nil, nil, handleApproveError(outputFormat, w, opts.workspace, fmt.Errorf("workspace '%s' not found or not awaiting approval: %w", opts.workspace, atlaserrors.ErrWorkspaceNotFound))</span>
        }

        // Auto-select if only one task
        <span class="cov0" title="0">if len(awaitingTasks) == 1 </span><span class="cov0" title="0">{
                return awaitingTasks[0].workspace, awaitingTasks[0].task, nil
        }</span>

        // Non-interactive mode requires workspace argument when multiple tasks exist
        <span class="cov0" title="0">if isNonInteractive </span><span class="cov0" title="0">{
                return nil, nil, atlaserrors.NewExitCode2Error(
                        fmt.Errorf("multiple tasks awaiting approval, use workspace argument to specify: %w", atlaserrors.ErrInteractiveRequired))
        }</span>

        // Present selection menu (AC: #1)
        <span class="cov0" title="0">selected, err := selectWorkspaceForApproval(awaitingTasks)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, tui.ErrMenuCanceled) </span><span class="cov0" title="0">{
                        out.Info("Approval canceled.")
                        return nil, nil, nil
                }</span>
                <span class="cov0" title="0">return nil, nil, handleApproveError(outputFormat, w, "", err)</span>
        }

        <span class="cov0" title="0">return selected.workspace, selected.task, nil</span>
}

// awaitingTask holds a workspace and its task awaiting approval.
type awaitingTask struct {
        workspace *domain.Workspace
        task      *domain.Task
}

// GetWorkspaceName returns the workspace name for menu selection.
func (a awaitingTask) GetWorkspaceName() string <span class="cov0" title="0">{
        return a.workspace.Name
}</span>

// GetTaskDescription returns the task description for menu selection.
func (a awaitingTask) GetTaskDescription() string <span class="cov0" title="0">{
        return a.task.Description
}</span>

// findAwaitingApprovalTasks finds all tasks with awaiting_approval status.
func findAwaitingApprovalTasks(ctx context.Context, wsStore workspace.Store, taskStore task.Store) ([]awaitingTask, error) <span class="cov8" title="1">{
        // List all workspaces
        workspaces, err := wsStore.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list workspaces: %w", err)
        }</span>

        <span class="cov8" title="1">var result []awaitingTask

        for _, ws := range workspaces </span><span class="cov8" title="1">{
                // Check context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                // List tasks for this workspace
                <span class="cov8" title="1">tasks, err := taskStore.List(ctx, ws.Name)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip workspaces with no tasks or errors
                        continue</span>
                }

                // Find the latest task with awaiting_approval status
                <span class="cov8" title="1">for _, t := range tasks </span><span class="cov8" title="1">{
                        if t.Status == constants.TaskStatusAwaitingApproval </span><span class="cov8" title="1">{
                                result = append(result, awaitingTask{
                                        workspace: ws,
                                        task:      t,
                                })
                                break</span> // Only count the latest task per workspace
                        }
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// selectWorkspaceForApproval presents a selection menu for multiple awaiting tasks.
func selectWorkspaceForApproval(tasks []awaitingTask) (*awaitingTask, error) <span class="cov0" title="0">{
        idx, err := SelectWorkspaceTask("Select a workspace to approve:", tasks)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;tasks[idx], nil</span>
}

// runAutoApprove performs automatic approval without interactive menu.
func runAutoApprove(ctx context.Context, out tui.Output, taskStore task.Store, ws *domain.Workspace, t *domain.Task, notifier *tui.Notifier, closeWS bool) error <span class="cov0" title="0">{
        // Build step workflow based on whether we're closing workspace
        var steps []approveStep
        if closeWS </span><span class="cov0" title="0">{
                steps = buildApproveAndCloseSteps()
        }</span> else<span class="cov0" title="0"> {
                steps = buildSimpleApproveSteps()
        }</span>

        // Create step context
        <span class="cov0" title="0">stepCtx := &amp;approveStepContext{
                out:       out,
                taskStore: taskStore,
                ws:        ws,
                t:         t,
                notifier:  notifier,
        }

        // Auto-approve mode uses TTY output (not JSON)
        tracker := newApproveStepTracker(steps, out, "")
        if err := tracker.executeSteps(ctx, stepCtx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to approve task: %w", err)
        }</span>

        // Display summary info
        <span class="cov0" title="0">out.Info(fmt.Sprintf("  Workspace: %s", ws.Name))
        out.Info(fmt.Sprintf("  Task ID:   %s", t.ID))
        if prURL := extractPRURL(t); prURL != "" </span><span class="cov0" title="0">{
                out.Info(fmt.Sprintf("  PR URL:    %s", prURL))
        }</span>

        <span class="cov0" title="0">notifier.Bell()
        return nil</span>
}

// findCurrentStepResult finds the most recent StepResult for the current step.
// Returns nil if no result exists for the current step.
// This function searches by StepIndex field rather than array position because
// StepResults is a history list where array index may not match step index
// (e.g., after interruptions/resumes or step retries).
func findCurrentStepResult(t *domain.Task) *domain.StepResult <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Search backwards to find most recent result for current step
        <span class="cov0" title="0">for i := len(t.StepResults) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if t.StepResults[i].StepIndex == t.CurrentStep </span><span class="cov0" title="0">{
                        return &amp;t.StepResults[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// hasStepLevelApproval checks if the current step has approval options.
// This indicates the step requires user input before proceeding (e.g., garbage file handling).
func hasStepLevelApproval(t *domain.Task) bool <span class="cov0" title="0">{
        result := findCurrentStepResult(t)
        return result != nil &amp;&amp; len(result.ApprovalOptions) &gt; 0
}</span>

// runInteractiveApproval runs the interactive approval flow with action menu.
func runInteractiveApproval(ctx context.Context, out tui.Output, taskStore task.Store, ws *domain.Workspace, t *domain.Task, notifier *tui.Notifier, verbose bool) error <span class="cov0" title="0">{
        // Check for step-level approval first (e.g., garbage file handling)
        if hasStepLevelApproval(t) </span><span class="cov0" title="0">{
                return runStepLevelApproval(ctx, out, taskStore, ws, t, notifier)
        }</span>

        // Display approval summary (AC: #2)
        <span class="cov0" title="0">summary := tui.NewApprovalSummary(t, ws)
        _ = out // Mark out as used - printApprovalSummary writes to stdout directly for styled output
        printApprovalSummary(summary, verbose)

        // Action menu loop (AC: #3, #4)
        return runApprovalActionLoop(ctx, out, taskStore, ws, t, notifier)</span>
}

// runStepLevelApproval handles approval for step-specific choices (e.g., garbage file handling).
// It displays the step output and shows a menu with the step's approval options.
// After the user makes a choice, it automatically resumes the task.
func runStepLevelApproval(ctx context.Context, out tui.Output, taskStore task.Store, ws *domain.Workspace, t *domain.Task, notifier *tui.Notifier) error <span class="cov0" title="0">{
        stepResult := findCurrentStepResult(t)
        if stepResult == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no result found for current step %d: %w", t.CurrentStep, atlaserrors.ErrUnknownStepResultStatus)
        }</span>

        // Display step output (the garbage warning or other step-specific message)
        <span class="cov0" title="0">out.Warning(stepResult.Output)

        // Build menu from step options
        options := make([]tui.Option, len(stepResult.ApprovalOptions))
        for i, opt := range stepResult.ApprovalOptions </span><span class="cov0" title="0">{
                label := opt.Label
                if opt.Recommended </span><span class="cov0" title="0">{
                        label += " (recommended)"
                }</span>
                <span class="cov0" title="0">options[i] = tui.Option{Label: label, Description: opt.Description, Value: opt.Key}</span>
        }

        <span class="cov0" title="0">selected, err := tuiSelectFunc("How would you like to proceed?", options)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, tui.ErrMenuCanceled) </span><span class="cov0" title="0">{
                        out.Info("Approval canceled.")
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("select step action: %w", err)</span>
        }

        // Store choice in task metadata for Resume to use
        <span class="cov0" title="0">if t.Metadata == nil </span><span class="cov0" title="0">{
                t.Metadata = make(map[string]any)
        }</span>
        <span class="cov0" title="0">t.Metadata["step_approval_choice"] = selected

        // Save the task with the choice
        if err := taskStore.Update(ctx, t.WorkspaceID, t); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save approval choice: %w", err)
        }</span>

        <span class="cov0" title="0">out.Success(fmt.Sprintf("Choice '%s' saved.", selected))

        // Inform user to resume the task
        out.Info(fmt.Sprintf("Run 'atlas resume %s' to continue the task with your choice.", ws.Name))
        notifier.Bell()
        return nil</span>
}

// printApprovalSummaryTo prints the approval summary to the specified writer.
// This function is testable by injecting a custom writer.
func printApprovalSummaryTo(w io.Writer, summary *tui.ApprovalSummary, verbose bool) <span class="cov0" title="0">{
        rendered := tui.RenderApprovalSummaryWithWidth(summary, 0, verbose)
        _, _ = w.Write([]byte(rendered + "\n"))
}</span>

// printApprovalSummary prints the approval summary to stdout.
// This is a convenience wrapper around printApprovalSummaryTo for production use.
func printApprovalSummary(summary *tui.ApprovalSummary, verbose bool) <span class="cov0" title="0">{
        printApprovalSummaryTo(os.Stdout, summary, verbose)
}</span>

// runApprovalActionLoop handles the approval action menu loop.
func runApprovalActionLoop(ctx context.Context, out tui.Output, taskStore task.Store, ws *domain.Workspace, t *domain.Task, notifier *tui.Notifier) error <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                action, err := selectApprovalActionFunc(t)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, tui.ErrMenuCanceled) </span><span class="cov0" title="0">{
                                out.Info("Approval canceled.")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("select approval action: %w", err)</span>
                }

                <span class="cov0" title="0">done, err := executeApprovalAction(ctx, out, taskStore, ws, t, notifier, action)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("execute approval action: %w", err)
                }</span>
                <span class="cov0" title="0">if done </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // Continue loop for view actions
        }
}

// executeApprovalAction executes the selected approval action.
// Returns true if the action loop should exit.
//
//nolint:unparam // error return is kept for future extensibility and consistent interface
func executeApprovalAction(ctx context.Context, out tui.Output, taskStore task.Store, ws *domain.Workspace, t *domain.Task, notifier *tui.Notifier, action approvalAction) (bool, error) <span class="cov8" title="1">{
        switch action </span>{
        case actionApprove:<span class="cov0" title="0">
                // Build single-step workflow
                steps := buildSimpleApproveSteps()
                stepCtx := &amp;approveStepContext{
                        out:       out,
                        taskStore: taskStore,
                        ws:        ws,
                        t:         t,
                        notifier:  notifier,
                }
                // Interactive mode always uses TTY output (not JSON)
                tracker := newApproveStepTracker(steps, out, "")
                if err := tracker.executeSteps(ctx, stepCtx); err != nil </span><span class="cov0" title="0">{
                        out.Error(tui.WrapWithSuggestion(err))
                        return false, nil // Continue loop on error
                }</span>
                <span class="cov0" title="0">out.Info("PR ready for merge.")
                notifier.Bell()
                return true, nil</span>

        case actionApproveAndClose:<span class="cov0" title="0">
                // Build two-step workflow
                steps := buildApproveAndCloseSteps()
                stepCtx := &amp;approveStepContext{
                        out:       out,
                        taskStore: taskStore,
                        ws:        ws,
                        t:         t,
                        notifier:  notifier,
                }
                // Interactive mode always uses TTY output (not JSON)
                tracker := newApproveStepTracker(steps, out, "")
                if err := tracker.executeSteps(ctx, stepCtx); err != nil </span><span class="cov0" title="0">{
                        out.Error(tui.WrapWithSuggestion(err))
                        return false, nil // Continue loop on error
                }</span>
                <span class="cov0" title="0">out.Info("PR ready for merge.")
                notifier.Bell()
                return true, nil</span>

        case actionApproveMergeClose:<span class="cov0" title="0">
                // Load config to get the default merge message
                cfg, _ := config.Load(ctx)
                message := cfg.Approval.MergeMessage
                // Interactive mode always uses TTY output (not JSON)
                if err := executeApproveMergeClose(ctx, out, taskStore, ws, t, notifier, message, ""); err != nil </span><span class="cov0" title="0">{
                        //nolint:nilerr // Error already displayed to user; continue interactive loop
                        return false, nil
                }</span>
                <span class="cov0" title="0">return true, nil</span>

        case actionViewDiff:<span class="cov0" title="0">
                if err := viewDiff(ctx, ws.WorktreePath); err != nil </span><span class="cov0" title="0">{
                        out.Warning(fmt.Sprintf("Could not display diff: %v", err))
                }</span>
                <span class="cov0" title="0">return false, nil</span>

        case actionViewLogs:<span class="cov0" title="0">
                if err := viewLogs(ctx, taskStore, ws.Name, t.ID); err != nil </span><span class="cov0" title="0">{
                        out.Warning(fmt.Sprintf("Could not display logs: %v", err))
                }</span>
                <span class="cov0" title="0">return false, nil</span>

        case actionOpenPR:<span class="cov0" title="0">
                prURL := extractPRURL(t)
                if prURL == "" </span><span class="cov0" title="0">{
                        out.Warning("No PR URL available.")
                        return false, nil
                }</span>
                <span class="cov0" title="0">if err := openInBrowser(ctx, prURL); err != nil </span><span class="cov0" title="0">{
                        out.Warning(fmt.Sprintf("Could not open PR: %v", err))
                        return false, nil
                }</span>
                <span class="cov0" title="0">out.Info(fmt.Sprintf("Opened %s in browser.", prURL))
                return false, nil</span>

        case actionReject:<span class="cov8" title="1">
                out.Info(fmt.Sprintf("Run 'atlas reject %s' to reject with feedback.", ws.Name))
                return true, nil</span>

        case actionCancel:<span class="cov0" title="0">
                out.Info("Approval canceled.")
                return true, nil</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

// selectApprovalAction presents the action menu.
func selectApprovalAction(t *domain.Task) (approvalAction, error) <span class="cov0" title="0">{
        options := []tui.Option{
                {Label: "Approve and complete", Description: "Mark task as completed", Value: string(actionApprove)},
                {Label: "Approve and close workspace", Description: "Mark completed and remove worktree", Value: string(actionApproveAndClose)},
        }

        // Only show merge option if PR exists
        if prNumber := extractPRNumber(t); prNumber &gt; 0 </span><span class="cov0" title="0">{
                options = append(options, tui.Option{
                        Label:       "Approve + Merge + Close",
                        Description: "Review PR, squash merge, close workspace",
                        Value:       string(actionApproveMergeClose),
                })
        }</span>

        <span class="cov0" title="0">options = append(options,
                tui.Option{Label: "View diff", Description: "Show file changes", Value: string(actionViewDiff)},
                tui.Option{Label: "View logs", Description: "Show task execution log", Value: string(actionViewLogs)},
        )

        // Only show Open PR if URL is available
        if prURL := extractPRURL(t); prURL != "" </span><span class="cov0" title="0">{
                options = append(options, tui.Option{
                        Label:       "Open PR in browser",
                        Description: "View pull request",
                        Value:       string(actionOpenPR),
                })
        }</span>

        <span class="cov0" title="0">options = append(options,
                tui.Option{Label: "Reject", Description: "Run atlas reject for feedback", Value: string(actionReject)},
                tui.Option{Label: "Cancel", Description: "Return without action", Value: string(actionCancel)},
        )

        selected, err := tuiSelectFunc("What would you like to do?", options)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return approvalAction(selected), nil</span>
}

// approveTask transitions the task to completed status.
func approveTask(ctx context.Context, taskStore task.Store, t *domain.Task) error <span class="cov0" title="0">{
        // Transition task to completed (AC: #4)
        if err := task.Transition(ctx, t, constants.TaskStatusCompleted, "User approved"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to approve task: %w", err)
        }</span>

        // Save updated task
        <span class="cov0" title="0">if err := taskStore.Update(ctx, t.WorkspaceID, t); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save task: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// viewDiff displays the git diff in a pager.
func viewDiff(ctx context.Context, worktreePath string) error <span class="cov0" title="0">{
        if worktreePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to view diff: %w", atlaserrors.ErrEmptyValue)
        }</span>

        // Get diff of recent changes
        <span class="cov0" title="0">gitCmd := execCommandContextFunc(ctx, "git", "-C", worktreePath, "diff", "HEAD~1")
        gitOutput, err := gitCmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                // Try without HEAD~1 for new repos
                gitCmd = execCommandContextFunc(ctx, "git", "-C", worktreePath, "diff")
                gitOutput, err = gitCmd.Output()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get diff: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if len(gitOutput) == 0 </span><span class="cov0" title="0">{
                _, _ = os.Stdout.WriteString("No changes to display.\n")
                return nil
        }</span>

        // Pipe to less with color support
        <span class="cov0" title="0">return pipeToLess(ctx, gitOutput)</span>
}

// viewLogs displays the task log in a pager.
func viewLogs(ctx context.Context, taskStore task.Store, workspaceName, taskID string) error <span class="cov0" title="0">{
        logData, err := taskStore.ReadLog(ctx, workspaceName, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no log file found: %w", err)
        }</span>

        <span class="cov0" title="0">if len(logData) == 0 </span><span class="cov0" title="0">{
                _, _ = os.Stdout.WriteString("Log file is empty.\n")
                return nil
        }</span>

        // Pipe to less
        <span class="cov0" title="0">return pipeToLess(ctx, logData)</span>
}

// pipeToLess pipes data to the less pager.
func pipeToLess(ctx context.Context, data []byte) error <span class="cov0" title="0">{
        lessCmd := execCommandContextFunc(ctx, "less", "-R")
        lessCmd.Stdin = os.Stdin
        lessCmd.Stdout = os.Stdout
        lessCmd.Stderr = os.Stderr

        stdin, pipeErr := lessCmd.StdinPipe()
        if pipeErr != nil </span><span class="cov0" title="0">{
                // Fallback: print directly (intentionally ignoring pipeErr as we're falling back)
                _, _ = os.Stdout.Write(data)
                return nil //nolint:nilerr // Fallback behavior intentional - print directly when pager unavailable
        }</span>

        <span class="cov0" title="0">if startErr := lessCmd.Start(); startErr != nil </span><span class="cov0" title="0">{
                // Fallback: print directly (intentionally ignoring startErr as we're falling back)
                _, _ = os.Stdout.Write(data)
                return nil //nolint:nilerr // Fallback behavior intentional - print directly when pager unavailable
        }</span>

        <span class="cov0" title="0">_, _ = stdin.Write(data)
        _ = stdin.Close()

        return lessCmd.Wait()</span>
}

// extractPRURL extracts the PR URL from task metadata.
func extractPRURL(t *domain.Task) string <span class="cov0" title="0">{
        if t == nil || t.Metadata == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if prURL, ok := t.Metadata["pr_url"].(string); ok </span><span class="cov0" title="0">{
                return prURL
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// extractPRNumber extracts the PR number from task metadata.
func extractPRNumber(t *domain.Task) int <span class="cov0" title="0">{
        if t == nil || t.Metadata == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">prNumber, ok := t.Metadata["pr_number"]
        if !ok </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">switch v := prNumber.(type) </span>{
        case int:<span class="cov0" title="0">
                return v</span>
        case float64:<span class="cov0" title="0">
                return int(v)</span>
        case string:<span class="cov0" title="0">
                n, _ := strconv.Atoi(v)
                return n</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// createHubRunnerFunc creates a GitHub runner for the given work directory.
// This is a variable to allow test injection.
//
//nolint:gochecknoglobals // Test injection point - standard Go testing pattern
var createHubRunnerFunc = func(workDir string) git.HubRunner <span class="cov0" title="0">{
        return git.NewCLIGitHubRunner(workDir)
}</span>

// executeApproveMergeClose performs the approve+merge+close workflow with step tracking.
// 1. Adds PR review (APPROVE) or falls back to comment
// 2. Merges PR with squash (falls back to admin bypass if needed)
// 3. Approves task
// 4. Closes workspace
func executeApproveMergeClose(
        ctx context.Context,
        out tui.Output,
        taskStore task.Store,
        ws *domain.Workspace,
        t *domain.Task,
        notifier *tui.Notifier,
        message string,
        outputFormat string,
) error <span class="cov0" title="0">{
        // Validate PR exists
        prNumber := extractPRNumber(t)
        if prNumber == 0 </span><span class="cov0" title="0">{
                err := fmt.Errorf("no PR number found in task metadata: %w", atlaserrors.ErrEmptyValue)
                out.Error(err)
                return err
        }</span>

        // Get the worktree path for GitHub runner
        <span class="cov0" title="0">hubRunner := createHubRunnerFunc(ws.WorktreePath)

        // Build step definitions
        steps := buildApproveMergeCloseSteps()

        // Create step context
        stepCtx := &amp;approveStepContext{
                out:       out,
                taskStore: taskStore,
                ws:        ws,
                t:         t,
                notifier:  notifier,
                hubRunner: hubRunner,
                message:   message,
        }

        // Create tracker and execute steps
        tracker := newApproveStepTracker(steps, out, outputFormat)
        if err := tracker.executeSteps(ctx, stepCtx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("execute approval steps: %w", err)
        }</span>

        // Ring bell on success
        <span class="cov0" title="0">notifier.Bell()
        return nil</span>
}

// openInBrowser opens a URL in the default browser (macOS).
func openInBrowser(ctx context.Context, url string) error <span class="cov0" title="0">{
        cmd := execCommandContextFunc(ctx, "open", url)
        return cmd.Run()
}</span>

// approveAndOutputJSON approves the task and outputs JSON result.
func approveAndOutputJSON(ctx context.Context, w io.Writer, taskStore task.Store, ws *domain.Workspace, t *domain.Task, closeWS bool) error <span class="cov0" title="0">{
        // Approve the task
        if err := task.Transition(ctx, t, constants.TaskStatusCompleted, "User approved via JSON"); err != nil </span><span class="cov0" title="0">{
                return outputApproveErrorJSON(w, ws.Name, t.ID, err.Error())
        }</span>

        <span class="cov0" title="0">if err := taskStore.Update(ctx, t.WorkspaceID, t); err != nil </span><span class="cov0" title="0">{
                return outputApproveErrorJSON(w, ws.Name, t.ID, err.Error())
        }</span>

        // Complete linked backlog discovery if present
        <span class="cov0" title="0">completeLinkedDiscovery(ctx, t)

        // Close workspace if requested
        workspaceClosed := false
        var closeWarning string
        if closeWS </span><span class="cov0" title="0">{
                warning, err := closeWorkspace(ctx, ws.Name)
                if err == nil </span><span class="cov0" title="0">{
                        workspaceClosed = true
                        closeWarning = warning
                }</span>
                // We don't fail the approval if workspace close fails
        }

        // Output success JSON
        <span class="cov0" title="0">resp := approveResponse{
                Success: true,
                Workspace: workspaceInfo{
                        Name:         ws.Name,
                        Branch:       ws.Branch,
                        WorktreePath: ws.WorktreePath,
                        Status:       string(ws.Status),
                },
                Task: taskInfo{
                        ID:           t.ID,
                        TemplateName: t.TemplateID,
                        Description:  t.Description,
                        Status:       string(t.Status),
                        CurrentStep:  t.CurrentStep,
                        TotalSteps:   len(t.Steps),
                },
                PRURL:           extractPRURL(t),
                WorkspaceClosed: workspaceClosed,
                Warning:         closeWarning,
        }

        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(resp)</span>
}

// handleApproveError handles errors based on output format.
func handleApproveError(format string, w io.Writer, workspaceName string, err error) error <span class="cov0" title="0">{
        return HandleCommandError(format, w, approveResponse{
                Success: false,
                Workspace: workspaceInfo{
                        Name: workspaceName,
                },
                Error: err.Error(),
        }, err)
}</span>

// outputApproveErrorJSON outputs an error result as JSON.
func outputApproveErrorJSON(w io.Writer, workspaceName, taskID, errMsg string) error <span class="cov0" title="0">{
        return HandleCommandError(OutputJSON, w, approveResponse{
                Success: false,
                Workspace: workspaceInfo{
                        Name: workspaceName,
                },
                Task: taskInfo{
                        ID: taskID,
                },
                Error: errMsg,
        }, atlaserrors.ErrJSONErrorOutput)
}</span>

// newApproveStepTracker creates a new step tracker
func newApproveStepTracker(steps []approveStep, out tui.Output, outputFormat string) *approveStepTracker <span class="cov0" title="0">{
        return &amp;approveStepTracker{
                steps:        steps,
                currentStep:  0,
                totalSteps:   len(steps),
                out:          out,
                outputFormat: outputFormat,
        }
}</span>

// executeSteps runs all steps in sequence with progress tracking
func (t *approveStepTracker) executeSteps(ctx context.Context, stepCtx *approveStepContext) error <span class="cov0" title="0">{
        for i, step := range t.steps </span><span class="cov0" title="0">{
                // Check context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">t.currentStep = i

                // Notify step start
                t.notifyStepStart(step)

                // Execute step
                message, err := step.execute(ctx, stepCtx)
                if err != nil </span><span class="cov0" title="0">{
                        t.notifyStepFailed(step, err)
                        return err
                }</span>

                // Notify step complete
                <span class="cov0" title="0">t.notifyStepComplete(step, message)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// notifyStepStart displays the step start message (skip in JSON mode)
func (t *approveStepTracker) notifyStepStart(step approveStep) <span class="cov0" title="0">{
        if t.outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("Step %d/%d: %s...", t.currentStep+1, t.totalSteps, step.name)
        t.out.Info(msg)</span>
}

// notifyStepComplete displays the step completion message (skip in JSON mode)
func (t *approveStepTracker) notifyStepComplete(step approveStep, message string) <span class="cov0" title="0">{
        if t.outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("Step %d/%d: %s completed", t.currentStep+1, t.totalSteps, step.name)
        t.out.Success(msg)

        // Display additional message if provided
        if message != "" </span><span class="cov0" title="0">{
                t.out.Info(fmt.Sprintf("  %s", message))
        }</span>
}

// notifyStepFailed displays the step failure message (skip in JSON mode)
func (t *approveStepTracker) notifyStepFailed(step approveStep, err error) <span class="cov0" title="0">{
        if t.outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("Step %d/%d: %s failed", t.currentStep+1, t.totalSteps, step.name)
        t.out.Error(fmt.Errorf("%s: %w", msg, err))</span>
}

// buildApproveMergeCloseSteps creates the step definitions for approve+merge+close workflow
func buildApproveMergeCloseSteps() []approveStep <span class="cov0" title="0">{
        return []approveStep{
                {
                        name:    "Add PR Review",
                        execute: executeAddReviewStep,
                },
                {
                        name:    "Merge PR",
                        execute: executeMergePRStep,
                },
                {
                        name:    "Approve Task",
                        execute: executeApproveTaskStep,
                },
                {
                        name:    "Close Workspace",
                        execute: executeCloseWorkspaceStep,
                },
        }
}</span>

// buildApproveAndCloseSteps creates the step definitions for approve+close workflow
func buildApproveAndCloseSteps() []approveStep <span class="cov0" title="0">{
        return []approveStep{
                {
                        name:    "Approve Task",
                        execute: executeApproveTaskStep,
                },
                {
                        name:    "Close Workspace",
                        execute: executeCloseWorkspaceStep,
                },
        }
}</span>

// buildSimpleApproveSteps creates the step definitions for simple approve workflow
func buildSimpleApproveSteps() []approveStep <span class="cov0" title="0">{
        return []approveStep{
                {
                        name:    "Approve Task",
                        execute: executeApproveTaskStep,
                },
        }
}</span>

// executeAddReviewStep handles adding PR review or comment with fallback
func executeAddReviewStep(ctx context.Context, stepCtx *approveStepContext) (string, error) <span class="cov0" title="0">{
        prNumber := extractPRNumber(stepCtx.t)
        if prNumber == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no PR number found in task metadata: %w", atlaserrors.ErrEmptyValue)
        }</span>

        // Try to add review first
        <span class="cov0" title="0">reviewErr := stepCtx.hubRunner.AddPRReview(ctx, prNumber, stepCtx.message, "APPROVE")
        if reviewErr == nil </span><span class="cov0" title="0">{
                return "PR approved", nil
        }</span>

        // Fallback to comment if review not allowed (own PR)
        <span class="cov0" title="0">if errors.Is(reviewErr, atlaserrors.ErrPRReviewNotAllowed) </span><span class="cov0" title="0">{
                if commentErr := stepCtx.hubRunner.AddPRComment(ctx, prNumber, stepCtx.message); commentErr != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("could not add comment: %w", commentErr)
                }</span>
                <span class="cov0" title="0">return "Comment added (own PR)", nil</span>
        }

        // Try comment fallback for other errors too
        <span class="cov0" title="0">if commentErr := stepCtx.hubRunner.AddPRComment(ctx, prNumber, stepCtx.message); commentErr != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not add review or comment: %w", reviewErr)
        }</span>
        <span class="cov0" title="0">return "Comment added (review failed)", nil</span>
}

// executeMergePRStep handles merging PR with admin bypass fallback
func executeMergePRStep(ctx context.Context, stepCtx *approveStepContext) (string, error) <span class="cov0" title="0">{
        prNumber := extractPRNumber(stepCtx.t)

        // Try standard merge first (deleteBranch=false to preserve branch for workspace cleanup)
        mergeErr := stepCtx.hubRunner.MergePR(ctx, prNumber, "squash", false, false)
        if mergeErr == nil </span><span class="cov0" title="0">{
                return "PR merged (squash)", nil
        }</span>

        // Try with admin bypass
        <span class="cov0" title="0">mergeErr = stepCtx.hubRunner.MergePR(ctx, prNumber, "squash", true, false)
        if mergeErr != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("merge failed: %w", mergeErr)
        }</span>

        <span class="cov0" title="0">return "PR merged (squash) with admin bypass", nil</span>
}

// executeApproveTaskStep handles task approval
func executeApproveTaskStep(ctx context.Context, stepCtx *approveStepContext) (string, error) <span class="cov0" title="0">{
        if err := approveTask(ctx, stepCtx.taskStore, stepCtx.t); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to approve task: %w", err)
        }</span>

        // Complete linked backlog discovery if present
        <span class="cov0" title="0">completeLinkedDiscovery(ctx, stepCtx.t)

        return "Task approved", nil</span>
}

// completeLinkedDiscovery marks a linked backlog discovery as completed.
// This is a best-effort operation - failures are logged but don't fail the approval.
func completeLinkedDiscovery(ctx context.Context, t *domain.Task) <span class="cov0" title="0">{
        if t == nil || t.Metadata == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">backlogID, ok := t.Metadata["from_backlog_id"].(string)
        if !ok || backlogID == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">logger := Logger()
        mgr, err := backlog.NewManager("")
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).
                        Str("discovery_id", backlogID).
                        Msg("failed to create backlog manager for discovery completion")
                return
        }</span>

        <span class="cov0" title="0">_, err = mgr.Complete(ctx, backlogID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).
                        Str("discovery_id", backlogID).
                        Msg("failed to complete backlog discovery")
                return
        }</span>

        <span class="cov0" title="0">logger.Info().
                Str("discovery_id", backlogID).
                Str("task_id", t.ID).
                Msg("backlog discovery marked as completed")</span>
}

// executeCloseWorkspaceStep handles workspace closure
func executeCloseWorkspaceStep(ctx context.Context, stepCtx *approveStepContext) (string, error) <span class="cov0" title="0">{
        warning, err := closeWorkspace(ctx, stepCtx.ws.Name)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to close workspace: %w", err)
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("Workspace '%s' closed", stepCtx.ws.Name)
        if warning != "" </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("%s (warning: %s)", msg, warning)
        }</span>
        <span class="cov0" title="0">return msg, nil</span>
}

// closeWorkspace closes the workspace, removing the worktree but preserving history.
// Returns a warning string if worktree removal failed (workspace is still closed).
func closeWorkspace(ctx context.Context, workspaceName string) (warning string, err error) <span class="cov0" title="0">{
        // Create workspace store
        wsStore, err := workspace.NewFileStore("")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create workspace store: %w", err)
        }</span>

        // Get workspace to find worktree path
        <span class="cov0" title="0">ws, err := wsStore.Get(ctx, workspaceName)
        if err != nil </span><span class="cov0" title="0">{
                // If workspace not found, treat it as already closed
                if errors.Is(err, atlaserrors.ErrWorkspaceNotFound) </span><span class="cov0" title="0">{
                        return "workspace already closed or not found", nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("failed to get workspace: %w", err)</span>
        }

        // Get repo path for worktree runner
        <span class="cov0" title="0">repoPath, err := detectRepoPath()
        if err != nil </span><span class="cov0" title="0">{
                // If we can't detect repo, worktree operations will fail gracefully
                repoPath = ""
        }</span>

        // Create worktree runner (may be nil if no repo path)
        <span class="cov0" title="0">var wtRunner workspace.WorktreeRunner
        if repoPath != "" </span><span class="cov0" title="0">{
                wtRunner, err = workspace.NewGitWorktreeRunner(ctx, repoPath, Logger())
                if err != nil </span><span class="cov0" title="0">{
                        // Continue without worktree runner - close should still update state
                        wtRunner = nil
                }</span>
        }

        // Create task store to check for running tasks before closing
        // This prevents closing a workspace while tasks are actively running
        <span class="cov0" title="0">var taskLister workspace.TaskLister
        taskStore, taskErr := task.NewFileStore("")
        if taskErr == nil </span><span class="cov0" title="0">{
                taskLister = taskStore
        }</span>

        // Create manager and close
        <span class="cov0" title="0">mgr := workspace.NewManager(wsStore, wtRunner, Logger())
        result, closeErr := mgr.Close(ctx, ws.Name, taskLister)
        if closeErr != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to close workspace: %w", closeErr)
        }</span>

        // Return any warnings about worktree or branch removal failures
        <span class="cov0" title="0">var warnings []string
        if result != nil </span><span class="cov0" title="0">{
                if result.WorktreeWarning != "" </span><span class="cov0" title="0">{
                        warnings = append(warnings, result.WorktreeWarning)
                }</span>
                <span class="cov0" title="0">if result.BranchWarning != "" </span><span class="cov0" title="0">{
                        warnings = append(warnings, result.BranchWarning)
                }</span>
        }

        <span class="cov0" title="0">if len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                return strings.Join(warnings, "; "), nil
        }</span>

        <span class="cov0" title="0">return "", nil</span>
}
</pre>

		<pre class="file" id="file3" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "github.com/spf13/cobra"
)

// AddBacklogCommand adds the backlog command group to the root command.
func AddBacklogCommand(root *cobra.Command) <span class="cov0" title="0">{
        backlogCmd := &amp;cobra.Command{
                Use:   "backlog",
                Short: "Manage the work backlog for discovered issues",
                Long: `Commands for managing discoveries in the work backlog.

The backlog captures issues discovered during AI-assisted development that
cannot be addressed in the current task scope. Each discovery is stored as
an individual YAML file in .atlas/backlog/ to enable frictionless capture
and zero merge conflicts.

Examples:
  atlas backlog add "Missing error handling"    # Add a new discovery
  atlas backlog list                            # List pending discoveries
  atlas backlog view disc-abc123                # View discovery details
  atlas backlog promote disc-abc123             # Promote to task
  atlas backlog dismiss disc-abc123 --reason "duplicate"  # Dismiss`,
        }

        backlogCmd.AddCommand(newBacklogAddCmd())
        backlogCmd.AddCommand(newBacklogListCmd())
        backlogCmd.AddCommand(newBacklogViewCmd())
        backlogCmd.AddCommand(newBacklogPromoteCmd())
        backlogCmd.AddCommand(newBacklogDismissCmd())

        root.AddCommand(backlogCmd)
}</span>
</pre>

		<pre class="file" id="file4" style="display: none">package cli

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "os/exec"
        "os/user"
        "strings"

        "github.com/charmbracelet/huh"
        "github.com/mrz1836/atlas/internal/backlog"
        atlaserrors "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/git"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/spf13/cobra"
)

// backlogAddFlags holds the flags for the add command.
type backlogAddFlags struct {
        file        string
        line        int
        category    string
        severity    string
        description string
        tags        string
        json        bool
        projectRoot string // used for testing
}

// newBacklogAddCmd creates the backlog add command.
func newBacklogAddCmd() *cobra.Command <span class="cov0" title="0">{
        flags := &amp;backlogAddFlags{}

        cmd := &amp;cobra.Command{
                Use:   "add [title]",
                Short: "Add a new discovery to the backlog",
                Long: `Add a new discovery to the work backlog.

When called without a title argument, launches an interactive form (for humans).
When called with a title argument and flags, adds the discovery directly (for AI/scripts).

The discoverer is automatically detected:
- Interactive mode: human:&lt;github-username&gt;
- Flag mode with --ai: ai:&lt;agent&gt;:&lt;model&gt;
- Flag mode with env vars: ai:&lt;ATLAS_AGENT&gt;:&lt;ATLAS_MODEL&gt;

Examples:
  # Interactive mode (for humans)
  atlas backlog add

  # Flag mode (for AI/scripts)
  atlas backlog add "Missing error handling" --file main.go --line 47 \
    --category bug --severity high --description "Details here"

  # With tags
  atlas backlog add "Add unit tests" --category testing --severity medium \
    --tags "tests,coverage"

Exit codes:
  0: Success
  1: General error (IO, validation)
  2: Invalid input (missing required flags)`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runBacklogAdd(cmd.Context(), cmd, cmd.OutOrStdout(), args, flags)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;flags.file, "file", "f", "", "File path where issue was found")
        cmd.Flags().IntVarP(&amp;flags.line, "line", "l", 0, "Line number in file")
        cmd.Flags().StringVarP(&amp;flags.category, "category", "c", "", "Issue category (bug, security, performance, maintainability, testing, documentation)")
        cmd.Flags().StringVarP(&amp;flags.severity, "severity", "s", "", "Priority level (low, medium, high, critical)")
        cmd.Flags().StringVarP(&amp;flags.description, "description", "d", "", "Detailed explanation")
        cmd.Flags().StringVarP(&amp;flags.tags, "tags", "t", "", "Comma-separated labels")
        cmd.Flags().BoolVar(&amp;flags.json, "json", false, "Output created discovery as JSON")

        return cmd</span>
}

// runBacklogAdd executes the backlog add command.
func runBacklogAdd(ctx context.Context, cmd *cobra.Command, w io.Writer, args []string, flags *backlogAddFlags) error <span class="cov0" title="0">{
        outputFormat := getOutputFormat(cmd, flags.json)
        out := tui.NewOutput(w, outputFormat)

        // Create manager
        mgr, err := backlog.NewManager(flags.projectRoot)
        if err != nil </span><span class="cov0" title="0">{
                return outputBacklogError(w, outputFormat, "add", err)
        }</span>

        // Determine mode and get discovery
        <span class="cov0" title="0">discovery, err := resolveBacklogAddMode(ctx, mgr, args, flags)
        if err != nil </span><span class="cov0" title="0">{
                if atlaserrors.IsExitCode2Error(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return outputBacklogError(w, outputFormat, "add", err)</span>
        }

        // Add the discovery
        <span class="cov0" title="0">if err := mgr.Add(ctx, discovery); err != nil </span><span class="cov0" title="0">{
                return outputBacklogError(w, outputFormat, "add", err)
        }</span>

        // Output result
        <span class="cov0" title="0">if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(discovery)
        }</span>

        <span class="cov0" title="0">displayBacklogAddSuccess(out, discovery)
        return nil</span>
}

// hasAnyBacklogAddFlags checks if any flags were provided.
func hasAnyBacklogAddFlags(flags *backlogAddFlags) bool <span class="cov0" title="0">{
        return flags.file != "" || flags.line != 0 || flags.category != "" ||
                flags.severity != "" || flags.description != "" || flags.tags != ""
}</span>

// resolveBacklogAddMode determines whether to use interactive or flag mode and returns a discovery.
func resolveBacklogAddMode(ctx context.Context, mgr *backlog.Manager, args []string, flags *backlogAddFlags) (*backlog.Discovery, error) <span class="cov0" title="0">{
        // Interactive mode: no args and no flags
        if len(args) == 0 &amp;&amp; !hasAnyBacklogAddFlags(flags) </span><span class="cov0" title="0">{
                return runBacklogAddInteractive(ctx, mgr)
        }</span>

        // Flag mode: validate required inputs
        <span class="cov0" title="0">if len(args) == 0 </span><span class="cov0" title="0">{
                return nil, atlaserrors.NewExitCode2Error(
                        fmt.Errorf("%w: title argument is required in flag mode", atlaserrors.ErrUserInputRequired))
        }</span>
        <span class="cov0" title="0">if flags.category == "" </span><span class="cov0" title="0">{
                return nil, atlaserrors.NewExitCode2Error(
                        fmt.Errorf("%w: --category flag is required", atlaserrors.ErrUserInputRequired))
        }</span>
        <span class="cov0" title="0">if flags.severity == "" </span><span class="cov0" title="0">{
                return nil, atlaserrors.NewExitCode2Error(
                        fmt.Errorf("%w: --severity flag is required", atlaserrors.ErrUserInputRequired))
        }</span>

        <span class="cov0" title="0">return buildDiscoveryFromFlags(ctx, mgr, args[0], flags)</span>
}

// buildDiscoveryFromFlags creates a Discovery from command flags.
func buildDiscoveryFromFlags(ctx context.Context, mgr *backlog.Manager, title string, flags *backlogAddFlags) (*backlog.Discovery, error) <span class="cov0" title="0">{
        // Parse category
        category := backlog.Category(flags.category)
        if !category.IsValid() </span><span class="cov0" title="0">{
                return nil, atlaserrors.NewExitCode2Error(
                        fmt.Errorf("%w: invalid category %q, must be one of: %v",
                                atlaserrors.ErrInvalidArgument, flags.category, backlog.ValidCategories()))
        }</span>

        // Parse severity
        <span class="cov0" title="0">severity := backlog.Severity(flags.severity)
        if !severity.IsValid() </span><span class="cov0" title="0">{
                return nil, atlaserrors.NewExitCode2Error(
                        fmt.Errorf("%w: invalid severity %q, must be one of: %v",
                                atlaserrors.ErrInvalidArgument, flags.severity, backlog.ValidSeverities()))
        }</span>

        // Parse tags
        <span class="cov0" title="0">var tags []string
        if flags.tags != "" </span><span class="cov0" title="0">{
                for _, tag := range strings.Split(flags.tags, ",") </span><span class="cov0" title="0">{
                        tag = strings.TrimSpace(tag)
                        if tag != "" </span><span class="cov0" title="0">{
                                tags = append(tags, tag)
                        }</span>
                }
        }

        // Build discovery
        <span class="cov0" title="0">d := &amp;backlog.Discovery{
                Title:  title,
                Status: backlog.StatusPending,
                Content: backlog.Content{
                        Description: flags.description,
                        Category:    category,
                        Severity:    severity,
                        Tags:        tags,
                },
                Context: backlog.Context{
                        DiscoveredBy: detectDiscoverer(ctx, mgr.ProjectRoot(), false),
                },
        }

        // Add location if provided
        if flags.file != "" || flags.line &gt; 0 </span><span class="cov0" title="0">{
                d.Location = &amp;backlog.Location{
                        File: flags.file,
                        Line: flags.line,
                }
        }</span>

        <span class="cov0" title="0">return d, nil</span>
}

// runBacklogAddInteractive runs the interactive form for adding a discovery.
func runBacklogAddInteractive(ctx context.Context, mgr *backlog.Manager) (*backlog.Discovery, error) <span class="cov0" title="0">{
        var (
                title       string
                description string
                category    string
                severity    string
                file        string
                line        int
                lineStr     string
        )

        // Build category options
        categoryOptions := make([]huh.Option[string], 0, len(backlog.ValidCategories()))
        for _, c := range backlog.ValidCategories() </span><span class="cov0" title="0">{
                categoryOptions = append(categoryOptions, huh.NewOption(string(c), string(c)))
        }</span>

        // Build severity options
        <span class="cov0" title="0">severityOptions := make([]huh.Option[string], 0, len(backlog.ValidSeverities()))
        for _, s := range backlog.ValidSeverities() </span><span class="cov0" title="0">{
                severityOptions = append(severityOptions, huh.NewOption(string(s), string(s)))
        }</span>

        <span class="cov0" title="0">form := huh.NewForm(
                huh.NewGroup(
                        huh.NewInput().
                                Title("Title").
                                Description("Brief title describing what you found (required)").
                                Value(&amp;title).
                                Validate(func(s string) error </span><span class="cov0" title="0">{
                                        if strings.TrimSpace(s) == "" </span><span class="cov0" title="0">{
                                                return fmt.Errorf("%w: title", atlaserrors.ErrEmptyValue)
                                        }</span>
                                        <span class="cov0" title="0">if len(s) &gt; backlog.MaxTitleLength </span><span class="cov0" title="0">{
                                                return fmt.Errorf("%w: title exceeds %d characters", atlaserrors.ErrValueOutOfRange, backlog.MaxTitleLength)
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }),
                ),
                huh.NewGroup(
                        huh.NewText().
                                Title("Description (optional)").
                                Description("Provide additional details about the discovery").
                                Value(&amp;description).
                                CharLimit(2000),
                ),
                huh.NewGroup(
                        huh.NewSelect[string]().
                                Title("Category").
                                Description("What type of issue is this?").
                                Options(categoryOptions...).
                                Value(&amp;category),
                        huh.NewSelect[string]().
                                Title("Severity").
                                Description("How important is this?").
                                Options(severityOptions...).
                                Value(&amp;severity),
                ),
                huh.NewGroup(
                        huh.NewInput().
                                Title("File path (optional)").
                                Description("Relative path to the file").
                                Value(&amp;file),
                        huh.NewInput().
                                Title("Line number (optional)").
                                Description("Line number in the file").
                                Validate(func(s string) error <span class="cov0" title="0">{
                                        if s == "" </span><span class="cov0" title="0">{
                                                return nil
                                        }</span>
                                        <span class="cov0" title="0">var l int
                                        if _, err := fmt.Sscanf(s, "%d", &amp;l); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("%w: line number", atlaserrors.ErrInvalidArgument)
                                        }</span>
                                        <span class="cov0" title="0">if l &lt; 1 </span><span class="cov0" title="0">{
                                                return fmt.Errorf("%w: line must be positive", atlaserrors.ErrValueOutOfRange)
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }).
                                Value(&amp;lineStr),
                ),
        ).WithTheme(tui.AtlasTheme())

        <span class="cov0" title="0">if err := form.Run(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("form canceled: %w", err)
        }</span>

        // Parse line number if provided
        <span class="cov0" title="0">if lineStr != "" </span><span class="cov0" title="0">{
                _, _ = fmt.Sscanf(lineStr, "%d", &amp;line) // validation already passed in form
        }</span>

        // Build discovery
        <span class="cov0" title="0">d := &amp;backlog.Discovery{
                Title:  title,
                Status: backlog.StatusPending,
                Content: backlog.Content{
                        Description: description,
                        Category:    backlog.Category(category),
                        Severity:    backlog.Severity(severity),
                },
                Context: backlog.Context{
                        DiscoveredBy: detectDiscoverer(ctx, mgr.ProjectRoot(), true),
                },
        }

        // Add location if provided
        if file != "" </span><span class="cov0" title="0">{
                d.Location = &amp;backlog.Location{
                        File: file,
                        Line: line,
                }
        }</span>

        <span class="cov0" title="0">return d, nil</span>
}

// detectDiscoverer determines the discoverer identifier.
// For interactive mode, uses "human:&lt;github-username&gt;".
// For flag mode, checks environment variables or defaults to AI detection.
func detectDiscoverer(ctx context.Context, projectRoot string, interactive bool) string <span class="cov0" title="0">{
        if interactive </span><span class="cov0" title="0">{
                username := getGitHubUsername(ctx, projectRoot)
                if username == "" </span><span class="cov0" title="0">{
                        return "human:unknown"
                }</span>
                <span class="cov0" title="0">return "human:" + strings.ToLower(username)</span>
        }

        // Check environment variables for AI agent detection
        <span class="cov0" title="0">agent := os.Getenv("ATLAS_AGENT")
        model := os.Getenv("ATLAS_MODEL")

        if agent != "" &amp;&amp; model != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("ai:%s:%s", agent, model)
        }</span>

        // Check for Claude Code environment variables
        <span class="cov0" title="0">if os.Getenv("CLAUDE_CODE") != "" || os.Getenv("ANTHROPIC_API_KEY") != "" </span><span class="cov0" title="0">{
                model = os.Getenv("ANTHROPIC_MODEL")
                if model == "" </span><span class="cov0" title="0">{
                        model = "unknown"
                }</span>
                <span class="cov0" title="0">return "ai:claude-code:" + model</span>
        }

        // Default to human with GitHub username
        <span class="cov0" title="0">username := getGitHubUsername(ctx, projectRoot)
        if username == "" </span><span class="cov0" title="0">{
                return "human:unknown"
        }</span>
        <span class="cov0" title="0">return "human:" + strings.ToLower(username)</span>
}

// getGitHubUsername attempts to detect the GitHub username using multiple methods.
// Priority: env vars &gt; git config &gt; gh CLI &gt; OS username.
func getGitHubUsername(ctx context.Context, projectRoot string) string <span class="cov0" title="0">{
        // Method 1: Environment variables (fastest, no I/O)
        if username := os.Getenv("GITHUB_USER"); username != "" </span><span class="cov0" title="0">{
                return username
        }</span>
        <span class="cov0" title="0">if username := os.Getenv("GITHUB_ACTOR"); username != "" </span><span class="cov0" title="0">{
                return username
        }</span>

        // Method 2: Custom git config (fast, local file read)
        <span class="cov0" title="0">if username, err := git.RunCommand(ctx, projectRoot, "config", "user.github"); err == nil &amp;&amp; username != "" </span><span class="cov0" title="0">{
                return username
        }</span>

        // Method 3: GitHub CLI (authoritative but slower)
        <span class="cov0" title="0">if username := getGitHubUsernameViaCLI(ctx, projectRoot); username != "" </span><span class="cov0" title="0">{
                return username
        }</span>

        // Method 4: OS username fallback
        <span class="cov0" title="0">if currentUser, err := user.Current(); err == nil &amp;&amp; currentUser.Username != "" </span><span class="cov0" title="0">{
                return currentUser.Username
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// getGitHubUsernameViaCLI attempts to get the GitHub username via gh CLI.
// Returns empty string if gh is not installed or not authenticated.
func getGitHubUsernameViaCLI(ctx context.Context, workDir string) string <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "gh", "api", "user", "--jq", ".login") //#nosec G204 -- args are constant
        cmd.Dir = workDir

        var stdout bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = nil // Suppress stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(stdout.String())</span>
}

// displayBacklogAddSuccess displays the success message for add command.
func displayBacklogAddSuccess(out tui.Output, d *backlog.Discovery) <span class="cov0" title="0">{
        out.Success(fmt.Sprintf("Created discovery: %s", d.ID))
        out.Info(fmt.Sprintf("  Title: %s", d.Title))
        out.Info(fmt.Sprintf("  Category: %s | Severity: %s", d.Content.Category, d.Content.Severity))
        if d.Location != nil &amp;&amp; d.Location.File != "" </span><span class="cov0" title="0">{
                if d.Location.Line &gt; 0 </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("  Location: %s:%d", d.Location.File, d.Location.Line))
                }</span> else<span class="cov0" title="0"> {
                        out.Info(fmt.Sprintf("  Location: %s", d.Location.File))
                }</span>
        }
}

// getOutputFormat safely retrieves the output format from the command flags.
// If the jsonFlag is true, it returns OutputJSON. Otherwise, it checks the
// "output" flag if defined, returning its value or empty string if not defined.
func getOutputFormat(cmd *cobra.Command, jsonFlag bool) string <span class="cov0" title="0">{
        if jsonFlag </span><span class="cov0" title="0">{
                return OutputJSON
        }</span>
        <span class="cov0" title="0">if flag := cmd.Flag("output"); flag != nil </span><span class="cov0" title="0">{
                return flag.Value.String()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// outputBacklogError outputs an error in the appropriate format.
func outputBacklogError(w io.Writer, format, command string, err error) error <span class="cov0" title="0">{
        if format == OutputJSON </span><span class="cov0" title="0">{
                encoder := json.NewEncoder(w)
                encoder.SetIndent("", "  ")
                if encErr := encoder.Encode(map[string]any{
                        "success": false,
                        "command": "backlog " + command,
                        "error":   err.Error(),
                }); encErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encode JSON: %w", encErr)
                }</span>
                <span class="cov0" title="0">return atlaserrors.ErrJSONErrorOutput</span>
        }
        <span class="cov0" title="0">return err</span>
}
</pre>

		<pre class="file" id="file5" style="display: none">package cli

import (
        "context"
        "fmt"
        "io"

        "github.com/mrz1836/atlas/internal/backlog"
        atlaserrors "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/spf13/cobra"
)

// backlogDismissFlags holds the flags for the dismiss command.
type backlogDismissFlags struct {
        reason      string
        json        bool
        projectRoot string // used for testing
}

// newBacklogDismissCmd creates the backlog dismiss command.
func newBacklogDismissCmd() *cobra.Command <span class="cov0" title="0">{
        flags := &amp;backlogDismissFlags{}

        cmd := &amp;cobra.Command{
                Use:   "dismiss &lt;id&gt;",
                Short: "Dismiss a discovery with a reason",
                Long: `Dismiss a discovery with a reason.

Only pending discoveries can be dismissed. The reason is required
to document why the discovery was not addressed.

Examples:
  atlas backlog dismiss disc-abc123 --reason "duplicate of disc-xyz789"
  atlas backlog dismiss disc-abc123 --reason "won't fix"
  atlas backlog dismiss disc-abc123 --reason "already fixed in PR #123"

Exit codes:
  0: Success
  1: Discovery not found or error
  2: Invalid input (discovery not pending, missing reason)`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runBacklogDismiss(cmd.Context(), cmd, cmd.OutOrStdout(), args[0], flags)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().StringVar(&amp;flags.reason, "reason", "", "Reason for dismissal (required)")
        cmd.Flags().BoolVar(&amp;flags.json, "json", false, "Output as JSON")
        _ = cmd.MarkFlagRequired("reason")

        return cmd</span>
}

// runBacklogDismiss executes the backlog dismiss command.
func runBacklogDismiss(ctx context.Context, cmd *cobra.Command, w io.Writer, id string, flags *backlogDismissFlags) error <span class="cov0" title="0">{
        outputFormat := getOutputFormat(cmd, flags.json)
        out := tui.NewOutput(w, outputFormat)

        // Validate reason
        if flags.reason == "" </span><span class="cov0" title="0">{
                return atlaserrors.NewExitCode2Error(
                        fmt.Errorf("%w: --reason flag is required", atlaserrors.ErrUserInputRequired))
        }</span>

        // Create manager
        <span class="cov0" title="0">mgr, err := backlog.NewManager(flags.projectRoot)
        if err != nil </span><span class="cov0" title="0">{
                return outputBacklogError(w, outputFormat, "dismiss", err)
        }</span>

        // Dismiss the discovery
        <span class="cov0" title="0">d, err := mgr.Dismiss(ctx, id, flags.reason)
        if err != nil </span><span class="cov0" title="0">{
                // Check if this is an invalid transition error
                if atlaserrors.IsExitCode2Error(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return outputBacklogError(w, outputFormat, "dismiss", err)</span>
        }

        // Output results
        <span class="cov0" title="0">if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(map[string]any{
                        "success":   true,
                        "id":        d.ID,
                        "status":    d.Status,
                        "reason":    d.Lifecycle.DismissedReason,
                        "discovery": d,
                })
        }</span>

        <span class="cov0" title="0">displayBacklogDismissSuccess(out, d)
        return nil</span>
}

// displayBacklogDismissSuccess displays the success message for dismiss command.
func displayBacklogDismissSuccess(out tui.Output, d *backlog.Discovery) <span class="cov0" title="0">{
        out.Success(fmt.Sprintf("Dismissed discovery %s", d.ID))
        out.Info(fmt.Sprintf("  Reason: %s", d.Lifecycle.DismissedReason))
}</span>
</pre>

		<pre class="file" id="file6" style="display: none">package cli

import (
        "context"
        "fmt"
        "io"
        "time"

        "github.com/mrz1836/atlas/internal/backlog"
        atlaserrors "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/spf13/cobra"
)

// backlogListFlags holds the flags for the list command.
type backlogListFlags struct {
        status      string
        category    string
        all         bool
        limit       int
        json        bool
        projectRoot string // used for testing
}

// newBacklogListCmd creates the backlog list command.
func newBacklogListCmd() *cobra.Command <span class="cov0" title="0">{
        flags := &amp;backlogListFlags{}

        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List discoveries in the backlog",
                Long: `List discoveries in the work backlog.

By default, shows only pending discoveries. Use --all to include
promoted and dismissed discoveries.

Examples:
  atlas backlog list                    # List pending discoveries
  atlas backlog list --status pending   # Same as default
  atlas backlog list --status promoted  # List promoted discoveries
  atlas backlog list --all              # Include all statuses
  atlas backlog list --category bug     # Filter by category
  atlas backlog list --limit 10         # Limit to 10 results
  atlas backlog list --json             # Output as JSON

Exit codes:
  0: Success
  1: General error`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runBacklogList(cmd.Context(), cmd, cmd.OutOrStdout(), flags)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().StringVar(&amp;flags.status, "status", "pending", "Filter by status (pending, promoted, dismissed)")
        cmd.Flags().StringVarP(&amp;flags.category, "category", "c", "", "Filter by category")
        cmd.Flags().BoolVarP(&amp;flags.all, "all", "a", false, "Include all statuses (overrides --status)")
        cmd.Flags().IntVarP(&amp;flags.limit, "limit", "n", 0, "Maximum items to show (0 = unlimited)")
        cmd.Flags().BoolVar(&amp;flags.json, "json", false, "Output as JSON array")

        return cmd</span>
}

// runBacklogList executes the backlog list command.
func runBacklogList(ctx context.Context, cmd *cobra.Command, w io.Writer, flags *backlogListFlags) error <span class="cov0" title="0">{
        outputFormat := getOutputFormat(cmd, flags.json)
        out := tui.NewOutput(w, outputFormat)

        // Create manager
        mgr, err := backlog.NewManager(flags.projectRoot)
        if err != nil </span><span class="cov0" title="0">{
                return outputBacklogError(w, outputFormat, "list", err)
        }</span>

        // Build filter
        <span class="cov0" title="0">filter := backlog.Filter{
                Limit: flags.limit,
        }

        // Status filter (unless --all is set)
        if !flags.all </span><span class="cov0" title="0">{
                status := backlog.Status(flags.status)
                if !status.IsValid() </span><span class="cov0" title="0">{
                        return outputBacklogError(w, outputFormat, "list",
                                fmt.Errorf("%w: %q is not valid, must be one of: %v", atlaserrors.ErrInvalidDiscoveryStatus, flags.status, backlog.ValidStatuses()))
                }</span>
                <span class="cov0" title="0">filter.Status = &amp;status</span>
        }

        // Category filter
        <span class="cov0" title="0">if flags.category != "" </span><span class="cov0" title="0">{
                category := backlog.Category(flags.category)
                if !category.IsValid() </span><span class="cov0" title="0">{
                        return outputBacklogError(w, outputFormat, "list",
                                fmt.Errorf("%w: %q is not valid, must be one of: %v", atlaserrors.ErrInvalidArgument, flags.category, backlog.ValidCategories()))
                }</span>
                <span class="cov0" title="0">filter.Category = &amp;category</span>
        }

        // List discoveries
        <span class="cov0" title="0">discoveries, warnings, err := mgr.List(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return outputBacklogError(w, outputFormat, "list", err)
        }</span>

        // Display warnings about malformed files
        <span class="cov0" title="0">for _, warning := range warnings </span><span class="cov0" title="0">{
                out.Warning(fmt.Sprintf("Skipping malformed file: %s", warning))
        }</span>

        // Output results
        <span class="cov0" title="0">if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(discoveries)
        }</span>

        <span class="cov0" title="0">displayBacklogList(out, discoveries)
        return nil</span>
}

// displayBacklogList displays the list of discoveries in table format.
func displayBacklogList(out tui.Output, discoveries []*backlog.Discovery) <span class="cov0" title="0">{
        if len(discoveries) == 0 </span><span class="cov0" title="0">{
                out.Info("No discoveries found.")
                return
        }</span>

        // Print header
        <span class="cov0" title="0">out.Info(fmt.Sprintf("%-12s  %-40s  %-15s  %-8s  %s",
                "ID", "TITLE", "CATEGORY", "SEVERITY", "AGE"))

        // Print each discovery
        for _, d := range discoveries </span><span class="cov0" title="0">{
                title := d.Title
                if len(title) &gt; 40 </span><span class="cov0" title="0">{
                        title = title[:37] + "..."
                }</span>
                <span class="cov0" title="0">age := formatAge(d.Context.DiscoveredAt)
                out.Info(fmt.Sprintf("%-12s  %-40s  %-15s  %-8s  %s",
                        d.ID, title, d.Content.Category, d.Content.Severity, age))</span>
        }
}

// formatAge formats a time as a human-readable age string.
func formatAge(t time.Time) string <span class="cov0" title="0">{
        d := time.Since(t)

        if d &lt; time.Minute </span><span class="cov0" title="0">{
                return "just now"
        }</span>
        <span class="cov0" title="0">if d &lt; time.Hour </span><span class="cov0" title="0">{
                m := int(d.Minutes())
                if m == 1 </span><span class="cov0" title="0">{
                        return "1m"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%dm", m)</span>
        }
        <span class="cov0" title="0">if d &lt; 24*time.Hour </span><span class="cov0" title="0">{
                h := int(d.Hours())
                if h == 1 </span><span class="cov0" title="0">{
                        return "1h"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%dh", h)</span>
        }

        <span class="cov0" title="0">days := int(d.Hours() / 24)
        if days == 1 </span><span class="cov0" title="0">{
                return "1d"
        }</span>
        <span class="cov0" title="0">if days &lt; 7 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dd", days)
        }</span>

        <span class="cov0" title="0">weeks := days / 7
        if weeks == 1 </span><span class="cov0" title="0">{
                return "1w"
        }</span>
        <span class="cov0" title="0">if weeks &lt; 4 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dw", weeks)
        }</span>

        <span class="cov0" title="0">months := days / 30
        if months == 1 </span><span class="cov0" title="0">{
                return "1mo"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%dmo", months)</span>
}
</pre>

		<pre class="file" id="file7" style="display: none">package cli

import (
        "context"
        "errors"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/mrz1836/atlas/internal/backlog"
        "github.com/mrz1836/atlas/internal/cli/workflow"
        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/contracts"
        atlaserrors "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/spf13/cobra"
        "golang.org/x/term"
)

// aiRunnerFactory allows tests to inject mock AI runners.
// This is only used in tests to avoid slow real AI CLI calls.
// When nil (the default), the real workflow.CreateAIRunner is used.
var aiRunnerFactory func(*config.Config) contracts.AIRunner //nolint:gochecknoglobals // Test dependency injection

// promoteOptions holds the flags for the promote command.
type promoteOptions struct {
        // template overrides the auto-detected template.
        template string

        // ai enables AI-assisted analysis.
        ai bool

        // agent overrides the AI agent.
        agent string

        // model overrides the AI model.
        model string

        // dryRun shows what would happen without executing.
        dryRun bool

        // jsonOutput enables JSON output.
        jsonOutput bool

        // projectRoot overrides the project root (used for testing).
        projectRoot string
}

// newBacklogPromoteCmd creates the backlog promote command.
func newBacklogPromoteCmd() *cobra.Command <span class="cov0" title="0">{
        var opts promoteOptions

        cmd := &amp;cobra.Command{
                Use:   "promote [id]",
                Short: "Promote a discovery to a task",
                Long: `Promote a discovery to a task, creating the task configuration automatically.

When called without arguments in a terminal, launches an interactive menu to
select a discovery and configure promotion options.

When called with an ID argument, promotes the discovery directly.

Generates task configuration from the discovery based on category and severity.
Critical security issues use the hotfix template; bugs use bugfix; other
categories use the task template.

The --ai flag enables AI-assisted analysis to determine the optimal task
configuration (template, description, workspace name).

The --dry-run flag shows what would happen without making any changes.

Examples:
  # Interactive mode (select discovery from menu)
  atlas backlog promote

  # Direct mode with discovery ID
  atlas backlog promote item-ABC123

  # Preview what would happen
  atlas backlog promote item-ABC123 --dry-run

  # Use AI to determine optimal task configuration
  atlas backlog promote item-ABC123 --ai

  # Override template selection
  atlas backlog promote item-ABC123 --template feature

Exit codes:
  0: Success
  1: Discovery not found or error
  2: Invalid input (discovery not pending, conflicting flags, ID required)`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        id := ""
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                id = args[0]
                        }</span>
                        <span class="cov0" title="0">return runBacklogPromote(cmd.Context(), cmd, cmd.OutOrStdout(), id, opts)</span>
                },
        }

        // Flags
        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;opts.template, "template", "t", "", "Override template selection (bugfix, feature, task, hotfix)")
        cmd.Flags().BoolVar(&amp;opts.ai, "ai", false, "Use AI to determine optimal task configuration")
        cmd.Flags().StringVar(&amp;opts.agent, "agent", "", "Override AI agent (claude, gemini, codex)")
        cmd.Flags().StringVar(&amp;opts.model, "model", "", "Override AI model")
        cmd.Flags().BoolVar(&amp;opts.dryRun, "dry-run", false, "Show what would happen without executing")
        cmd.Flags().BoolVar(&amp;opts.jsonOutput, "json", false, "Output as JSON")

        return cmd</span>
}

// isPromoteInteractiveMode determines if the promote command should run in interactive mode.
// Interactive mode is used when: no ID provided, not JSON output, and running in a terminal.
func isPromoteInteractiveMode(id string, opts promoteOptions) bool <span class="cov0" title="0">{
        if id != "" </span><span class="cov0" title="0">{
                return false // ID provided = direct mode
        }</span>
        <span class="cov0" title="0">if opts.jsonOutput </span><span class="cov0" title="0">{
                return false // JSON = non-interactive
        }</span>
        <span class="cov0" title="0">return term.IsTerminal(int(os.Stdin.Fd()))</span>
}

// runBacklogPromote executes the backlog promote command.
func runBacklogPromote(ctx context.Context, cmd *cobra.Command, w io.Writer, id string, opts promoteOptions) error <span class="cov0" title="0">{
        outputFormat := getOutputFormat(cmd, opts.jsonOutput)
        out := tui.NewOutput(w, outputFormat)

        // Check for interactive mode
        if isPromoteInteractiveMode(id, opts) </span><span class="cov0" title="0">{
                return runBacklogPromoteInteractive(ctx, cmd, w, opts)
        }</span>

        // Require ID in non-interactive mode
        <span class="cov0" title="0">if id == "" </span><span class="cov0" title="0">{
                if opts.jsonOutput </span><span class="cov0" title="0">{
                        return atlaserrors.NewExitCode2Error(
                                fmt.Errorf("%w: ID required with --json flag", atlaserrors.ErrUserInputRequired))
                }</span>
                <span class="cov0" title="0">return atlaserrors.NewExitCode2Error(
                        fmt.Errorf("%w: ID required in non-interactive mode (not a terminal)", atlaserrors.ErrUserInputRequired))</span>
        }

        // Validate flags
        <span class="cov0" title="0">if opts.template != "" &amp;&amp; !backlog.IsValidTemplateName(opts.template) </span><span class="cov0" title="0">{
                return atlaserrors.NewExitCode2Error(
                        fmt.Errorf("%w: invalid template %q, valid templates are: %s",
                                atlaserrors.ErrInvalidArgument, opts.template, strings.Join(backlog.ValidTemplateNames(), ", ")))
        }</span>

        // Create manager
        <span class="cov0" title="0">mgr, err := backlog.NewManager(opts.projectRoot)
        if err != nil </span><span class="cov0" title="0">{
                return outputBacklogError(w, outputFormat, "promote", err)
        }</span>

        // Detect available AI agents
        <span class="cov0" title="0">availableAgents := detectAvailableAgents(ctx)

        // Build promote options
        promoteOpts := backlog.PromoteOptions{
                Template:        opts.template,
                Agent:           opts.agent,
                Model:           opts.model,
                UseAI:           opts.ai,
                DryRun:          opts.dryRun,
                AvailableAgents: availableAgents,
        }

        // Create AI promoter if AI mode is enabled
        aiPromoter := createAIPromoterIfEnabled(ctx, opts, availableAgents, outputFormat, out)

        // Promote with options
        result, err := mgr.PromoteWithOptions(ctx, id, promoteOpts, aiPromoter)
        if err != nil </span><span class="cov0" title="0">{
                // Check if this is an invalid transition error
                if atlaserrors.IsExitCode2Error(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return outputBacklogError(w, outputFormat, "promote", err)</span>
        }

        // Show completion for AI analysis
        <span class="cov0" title="0">if opts.ai &amp;&amp; outputFormat != OutputJSON </span><span class="cov0" title="0">{
                out.Success("AI Analysis complete")
        }</span>

        // Output results
        <span class="cov0" title="0">if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return outputPromoteResultJSON(out, result)
        }</span>

        <span class="cov0" title="0">displayPromoteResult(out, result)

        // Add informational note
        if !result.DryRun </span><span class="cov0" title="0">{
                out.Info("")
                out.Info("Note: Discovery status will change to 'promoted' when you run the start command.")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createAIPromoterIfEnabled creates an AI promoter if AI mode is enabled.
// Returns nil if AI mode is disabled.
func createAIPromoterIfEnabled(
        ctx context.Context,
        opts promoteOptions,
        availableAgents []string,
        outputFormat string,
        out tui.Output,
) *backlog.AIPromoter <span class="cov0" title="0">{
        if !opts.ai </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Load config to get AI settings
        <span class="cov0" title="0">cfg, cfgErr := config.Load(ctx)
        if cfgErr != nil </span><span class="cov0" title="0">{
                // Use defaults if config loading fails
                cfg = config.DefaultConfig()
        }</span>

        // Create AI runner (use test factory if available, otherwise real runner)
        <span class="cov0" title="0">var aiRunner contracts.AIRunner
        if aiRunnerFactory != nil </span><span class="cov0" title="0">{
                aiRunner = aiRunnerFactory(cfg)
        }</span> else<span class="cov0" title="0"> {
                aiRunner = workflow.CreateAIRunner(cfg)
        }</span>
        <span class="cov0" title="0">aiPromoter := backlog.NewAIPromoter(aiRunner, &amp;cfg.AI)

        // Show progress for AI analysis (only in non-JSON mode)
        if outputFormat != OutputJSON </span><span class="cov0" title="0">{
                aiCfg := &amp;backlog.AIPromoterConfig{
                        Agent:           opts.agent,
                        Model:           opts.model,
                        AvailableAgents: availableAgents,
                }
                agent, model := aiPromoter.ResolvedConfig(aiCfg)
                out.Info(fmt.Sprintf("AI Analysis (%s/%s)...", agent, model))
        }</span>

        <span class="cov0" title="0">return aiPromoter</span>
}

// outputPromoteResultJSON outputs the promote result as JSON.
func outputPromoteResultJSON(out tui.Output, result *backlog.PromoteResult) error <span class="cov0" title="0">{
        response := map[string]any{
                "success":        true,
                "id":             result.Discovery.ID,
                "status":         result.Discovery.Status,
                "dry_run":        result.DryRun,
                "template":       result.TemplateName,
                "workspace_name": result.WorkspaceName,
                "branch_name":    result.BranchName,
                "description":    result.Description,
                "start_command":  buildStartCommand(result),
        }

        if result.AIAnalysis != nil </span><span class="cov0" title="0">{
                response["ai_analysis"] = buildAIAnalysisMap(result.AIAnalysis)
        }</span>

        <span class="cov0" title="0">response["discovery"] = result.Discovery

        return out.JSON(response)</span>
}

// displayPromoteResult displays the promote result in text format.
func displayPromoteResult(out tui.Output, result *backlog.PromoteResult) <span class="cov0" title="0">{
        if result.DryRun </span><span class="cov0" title="0">{
                out.Info("Dry-run mode: showing what would happen\n")
        }</span>

        <span class="cov0" title="0">out.Info(fmt.Sprintf("Promoting discovery: %s", result.Discovery.ID))
        out.Info(fmt.Sprintf("  Title:    %s", result.Discovery.Title))
        out.Info(fmt.Sprintf("  Category: %s", result.Discovery.Content.Category))
        out.Info(fmt.Sprintf("  Severity: %s", result.Discovery.Content.Severity))

        // Show generated configuration
        out.Info("\nTask configuration:")
        out.Info(fmt.Sprintf("  Template:  %s", result.TemplateName))
        out.Info(fmt.Sprintf("  Workspace: %s", result.WorkspaceName))
        out.Info(fmt.Sprintf("  Branch:    %s", result.BranchName))

        if result.AIAnalysis != nil </span><span class="cov0" title="0">{
                displayAIAnalysis(out, result.AIAnalysis)
        }</span>

        // Build the suggested command with all flags
        <span class="cov0" title="0">startCmd := buildStartCommand(result)

        if result.DryRun </span><span class="cov0" title="0">{
                out.Text("\nTo create the task, run without --dry-run:")
                out.Text(fmt.Sprintf("  atlas backlog promote %s", result.Discovery.ID))
                if result.TemplateName != "" </span><span class="cov0" title="0">{
                        out.Text("\nOr start the task directly with:")
                        out.Text(fmt.Sprintf("  %s \\", startCmd))
                        out.Text(fmt.Sprintf("    %q", result.Discovery.Title))
                }</span>
        } else<span class="cov0" title="0"> {
                // Not dry-run: show instructions for next steps
                out.Success(fmt.Sprintf("\nDiscovery %s ready for task creation", result.Discovery.ID))
                out.Text("\nTo create and start the task, run:")
                out.Text(fmt.Sprintf("  %s \\", startCmd))
                out.Text(fmt.Sprintf("    %q", result.Discovery.Title))
                out.Text(fmt.Sprintf("\nDiscovery file: .atlas/backlog/%s.yaml", result.Discovery.ID))
        }</span>
}

// buildStartCommand constructs the atlas start command with all recommended flags.
func buildStartCommand(result *backlog.PromoteResult) string <span class="cov0" title="0">{
        // Start with base command (template and workspace)
        cmd := fmt.Sprintf("atlas start -t %s -w %s",
                result.TemplateName, result.WorkspaceName)

        // Use the branch where the discovery was made as the base branch (explicit, no assumptions)
        if result.Discovery.Context.Git != nil &amp;&amp; result.Discovery.Context.Git.Branch != "" </span><span class="cov0" title="0">{
                cmd += fmt.Sprintf(" -b %s", result.Discovery.Context.Git.Branch)
        }</span>

        // Add AI-recommended flags
        <span class="cov0" title="0">if result.AIAnalysis != nil &amp;&amp; result.AIAnalysis.UseVerify != nil </span><span class="cov0" title="0">{
                if *result.AIAnalysis.UseVerify </span><span class="cov0" title="0">{
                        cmd += " --verify"
                }</span> else<span class="cov0" title="0"> {
                        cmd += " --no-verify"
                }</span>
        }

        // Add backlog link
        <span class="cov0" title="0">cmd += fmt.Sprintf(" --from-backlog %s", result.Discovery.ID)

        return cmd</span>
}

// buildAIAnalysisMap creates a map representation of AI analysis for JSON output.
func buildAIAnalysisMap(ai *backlog.AIAnalysis) map[string]any <span class="cov0" title="0">{
        aiMap := map[string]any{
                "template":       ai.Template,
                "description":    ai.Description,
                "reasoning":      ai.Reasoning,
                "workspace_name": ai.WorkspaceName,
                "priority":       ai.Priority,
        }
        if ai.BaseBranch != "" </span><span class="cov0" title="0">{
                aiMap["base_branch"] = ai.BaseBranch
        }</span>
        <span class="cov0" title="0">if ai.UseVerify != nil </span><span class="cov0" title="0">{
                aiMap["use_verify"] = *ai.UseVerify
        }</span>
        <span class="cov0" title="0">if ai.File != "" </span><span class="cov0" title="0">{
                aiMap["file"] = ai.File
        }</span>
        <span class="cov0" title="0">if ai.Line &gt; 0 </span><span class="cov0" title="0">{
                aiMap["line"] = ai.Line
        }</span>
        <span class="cov0" title="0">return aiMap</span>
}

// displayAIAnalysis displays AI analysis information in text format.
func displayAIAnalysis(out tui.Output, ai *backlog.AIAnalysis) <span class="cov0" title="0">{
        out.Info("\nAI Analysis:")
        out.Info(fmt.Sprintf("  Reasoning: %s", ai.Reasoning))
        if ai.File != "" </span><span class="cov0" title="0">{
                if ai.Line &gt; 0 </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("  Location:  %s:%d", ai.File, ai.Line))
                }</span> else<span class="cov0" title="0"> {
                        out.Info(fmt.Sprintf("  Location:  %s", ai.File))
                }</span>
        }
        <span class="cov0" title="0">if ai.Priority &gt; 0 </span><span class="cov0" title="0">{
                out.Info(fmt.Sprintf("  Priority:  %d/5", ai.Priority))
        }</span>
}

// truncateDescription truncates a description to a maximum length.
func truncateDescription(desc string, maxLen int) string <span class="cov0" title="0">{
        // Take only the first line
        if idx := strings.Index(desc, "\n"); idx != -1 </span><span class="cov0" title="0">{
                desc = desc[:idx]
        }</span>

        <span class="cov0" title="0">if len(desc) &lt;= maxLen </span><span class="cov0" title="0">{
                return desc
        }</span>
        <span class="cov0" title="0">return desc[:maxLen-3] + "..."</span>
}

// detectAvailableAgents detects which AI agent CLIs are installed.
// Returns a slice of agent names (e.g., ["claude", "gemini"]).
func detectAvailableAgents(ctx context.Context) []string <span class="cov0" title="0">{
        detector := config.NewToolDetector()
        result, err := detector.Detect(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var agents []string
        agentTools := []string{constants.ToolClaude, constants.ToolGemini, constants.ToolCodex}

        for _, tool := range result.Tools </span><span class="cov0" title="0">{
                for _, agentTool := range agentTools </span><span class="cov0" title="0">{
                        if tool.Name == agentTool &amp;&amp; tool.Status == config.ToolStatusInstalled </span><span class="cov0" title="0">{
                                agents = append(agents, tool.Name)
                        }</span>
                }
        }

        <span class="cov0" title="0">return agents</span>
}

// runBacklogPromoteInteractive runs the interactive mode for promoting a discovery.
func runBacklogPromoteInteractive(ctx context.Context, cmd *cobra.Command, w io.Writer, opts promoteOptions) error <span class="cov0" title="0">{
        out := tui.NewOutput(w, "")

        // Create manager
        mgr, err := backlog.NewManager(opts.projectRoot)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backlog manager: %w", err)
        }</span>

        // List pending discoveries
        <span class="cov0" title="0">pendingStatus := backlog.StatusPending
        discoveries, _, err := mgr.List(ctx, backlog.Filter{Status: &amp;pendingStatus})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list discoveries: %w", err)
        }</span>

        // Check if there are any pending discoveries
        <span class="cov0" title="0">if len(discoveries) == 0 </span><span class="cov0" title="0">{
                out.Info("No pending discoveries to promote.")
                return nil
        }</span>

        // Build options from discoveries
        <span class="cov0" title="0">options := buildDiscoveryOptions(discoveries)

        // Select a discovery
        selectedID, err := tui.Select("Select a discovery to promote:", options)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, tui.ErrMenuCanceled) </span><span class="cov0" title="0">{
                        out.Info("Promotion canceled.")
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("selection failed: %w", err)</span>
        }

        // Ask about AI mode (unless already specified via flag)
        <span class="cov0" title="0">useAI := opts.ai
        if !opts.ai </span><span class="cov0" title="0">{
                useAI, err = tui.Confirm("Use AI to determine optimal task configuration?", false)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, tui.ErrMenuCanceled) </span><span class="cov0" title="0">{
                                out.Info("Promotion canceled.")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("confirmation failed: %w", err)</span>
                }
        }

        // If not using AI, optionally select template override
        <span class="cov0" title="0">templateOverride := opts.template
        if !useAI &amp;&amp; templateOverride == "" </span><span class="cov0" title="0">{
                templateOverride, err = selectTemplateOverride()
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, tui.ErrMenuCanceled) </span><span class="cov0" title="0">{
                                out.Info("Promotion canceled.")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("template selection failed: %w", err)</span>
                }
        }

        // Build options for promotion
        <span class="cov0" title="0">promoteOpts := opts
        promoteOpts.ai = useAI
        if templateOverride != "" </span><span class="cov0" title="0">{
                promoteOpts.template = templateOverride
        }</span>

        // Execute promotion with selected ID
        <span class="cov0" title="0">return runBacklogPromote(ctx, cmd, w, selectedID, promoteOpts)</span>
}

// buildDiscoveryOptions builds TUI options from discoveries.
// Format: "[item-ABC123] Title truncated to 50 chars"
// Description: "bug/high | 2h ago"
func buildDiscoveryOptions(discoveries []*backlog.Discovery) []tui.Option <span class="cov0" title="0">{
        const maxTitleLen = 50
        options := make([]tui.Option, len(discoveries))

        for i, d := range discoveries </span><span class="cov0" title="0">{
                // Truncate title for display
                title := d.Title
                if len(title) &gt; maxTitleLen </span><span class="cov0" title="0">{
                        title = title[:maxTitleLen-3] + "..."
                }</span>

                // Build label with ID and title
                <span class="cov0" title="0">label := fmt.Sprintf("[%s] %s", d.ID, title)

                // Build description with category/severity and relative time
                relTime := tui.RelativeTime(d.Context.DiscoveredAt)
                desc := fmt.Sprintf("%s/%s | %s", d.Content.Category, d.Content.Severity, relTime)

                options[i] = tui.Option{
                        Label:       label,
                        Description: desc,
                        Value:       d.ID,
                }</span>
        }

        <span class="cov0" title="0">return options</span>
}

// selectTemplateOverride presents a menu to optionally select a template override.
// Returns empty string for auto-detect, or the selected template name.
func selectTemplateOverride() (string, error) <span class="cov0" title="0">{
        options := []tui.Option{
                {
                        Label:       "Auto-detect",
                        Description: "Based on category/severity",
                        Value:       "",
                },
                {
                        Label:       "bugfix",
                        Description: "Fix bugs and regressions",
                        Value:       "bugfix",
                },
                {
                        Label:       "feature",
                        Description: "New feature development",
                        Value:       "feature",
                },
                {
                        Label:       "hotfix",
                        Description: "Critical production fixes",
                        Value:       "hotfix",
                },
                {
                        Label:       "task",
                        Description: "General development tasks",
                        Value:       "task",
                },
        }

        return tui.Select("Select task template:", options)
}</span>
</pre>

		<pre class="file" id="file8" style="display: none">package cli

import (
        "context"
        "fmt"
        "io"
        "strings"
        "sync"

        "github.com/charmbracelet/glamour"
        "github.com/mrz1836/atlas/internal/backlog"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/spf13/cobra"
)

var (
        glamourRenderer     *glamour.TermRenderer //nolint:gochecknoglobals // cached renderer for performance
        glamourRendererOnce sync.Once             //nolint:gochecknoglobals // sync.Once for renderer initialization
)

// getGlamourRenderer returns a cached glamour renderer for markdown rendering.
// The renderer is initialized once and reused across all calls.
func getGlamourRenderer() *glamour.TermRenderer <span class="cov0" title="0">{
        glamourRendererOnce.Do(func() </span><span class="cov0" title="0">{
                r, err := glamour.NewTermRenderer(
                        glamour.WithAutoStyle(),
                        glamour.WithWordWrap(80),
                )
                if err == nil </span><span class="cov0" title="0">{
                        glamourRenderer = r
                }</span>
        })
        <span class="cov0" title="0">return glamourRenderer</span>
}

// backlogViewFlags holds the flags for the view command.
type backlogViewFlags struct {
        json        bool
        projectRoot string // used for testing
}

// newBacklogViewCmd creates the backlog view command.
func newBacklogViewCmd() *cobra.Command <span class="cov0" title="0">{
        flags := &amp;backlogViewFlags{}

        cmd := &amp;cobra.Command{
                Use:   "view &lt;id&gt;",
                Short: "View full details of a discovery",
                Long: `View full details of a discovery by ID.

Displays all information about a discovery including description,
location, context, and lifecycle information.

Examples:
  atlas backlog view disc-abc123        # View discovery details
  atlas backlog view disc-abc123 --json # Output as JSON

Exit codes:
  0: Success
  1: Discovery not found or error`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runBacklogView(cmd.Context(), cmd, cmd.OutOrStdout(), args[0], flags)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;flags.json, "json", false, "Output as JSON")

        return cmd</span>
}

// runBacklogView executes the backlog view command.
func runBacklogView(ctx context.Context, cmd *cobra.Command, w io.Writer, id string, flags *backlogViewFlags) error <span class="cov0" title="0">{
        outputFormat := getOutputFormat(cmd, flags.json)
        out := tui.NewOutput(w, outputFormat)

        // Create manager
        mgr, err := backlog.NewManager(flags.projectRoot)
        if err != nil </span><span class="cov0" title="0">{
                return outputBacklogError(w, outputFormat, "view", err)
        }</span>

        // Get discovery
        <span class="cov0" title="0">d, err := mgr.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return outputBacklogError(w, outputFormat, "view", err)
        }</span>

        // Output results
        <span class="cov0" title="0">if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(d)
        }</span>

        <span class="cov0" title="0">displayBacklogView(out, w, d)
        return nil</span>
}

// displayBacklogView displays a discovery in rich detail format.
func displayBacklogView(out tui.Output, w io.Writer, d *backlog.Discovery) <span class="cov0" title="0">{
        // Header
        out.Info(fmt.Sprintf("Discovery: %s", d.ID))
        out.Info(strings.Repeat("━", 50))
        out.Info("")

        // Basic info
        out.Info(fmt.Sprintf("Title:      %s", d.Title))
        out.Info(fmt.Sprintf("Status:     %s", d.Status))
        out.Info(fmt.Sprintf("Category:   %s", d.Content.Category))
        out.Info(fmt.Sprintf("Severity:   %s", d.Content.Severity))
        out.Info("")

        // Description with markdown rendering
        if d.Content.Description != "" </span><span class="cov0" title="0">{
                out.Info("Description:")
                renderDescription(w, d.Content.Description)
                out.Info("")
        }</span>

        // Location
        <span class="cov0" title="0">if d.Location != nil &amp;&amp; d.Location.File != "" </span><span class="cov0" title="0">{
                if d.Location.Line &gt; 0 </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("Location:   %s:%d", d.Location.File, d.Location.Line))
                }</span> else<span class="cov0" title="0"> {
                        out.Info(fmt.Sprintf("Location:   %s", d.Location.File))
                }</span>
        }

        // Tags
        <span class="cov0" title="0">if len(d.Content.Tags) &gt; 0 </span><span class="cov0" title="0">{
                out.Info(fmt.Sprintf("Tags:       %s", strings.Join(d.Content.Tags, ", ")))
        }</span>

        <span class="cov0" title="0">out.Info("")

        // Context
        out.Info(fmt.Sprintf("Discovered: %s", d.Context.DiscoveredAt.Format("2006-01-02 15:04:05 MST")))
        out.Info(fmt.Sprintf("By:         %s", d.Context.DiscoveredBy))

        if d.Context.DuringTask != "" </span><span class="cov0" title="0">{
                out.Info(fmt.Sprintf("During:     %s", d.Context.DuringTask))
        }</span>

        <span class="cov0" title="0">if d.Context.Git != nil </span><span class="cov0" title="0">{
                if d.Context.Git.Branch != "" &amp;&amp; d.Context.Git.Commit != "" </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("Git:        %s @ %s", d.Context.Git.Branch, d.Context.Git.Commit))
                }</span> else<span class="cov0" title="0"> if d.Context.Git.Branch != "" </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("Git:        %s", d.Context.Git.Branch))
                }</span>
        }

        // Lifecycle info
        <span class="cov0" title="0">if d.Status == backlog.StatusPromoted &amp;&amp; d.Lifecycle.PromotedToTask != "" </span><span class="cov0" title="0">{
                out.Info("")
                out.Info(fmt.Sprintf("Promoted to task: %s", d.Lifecycle.PromotedToTask))
        }</span>

        <span class="cov0" title="0">if d.Status == backlog.StatusDismissed &amp;&amp; d.Lifecycle.DismissedReason != "" </span><span class="cov0" title="0">{
                out.Info("")
                out.Info(fmt.Sprintf("Dismissed reason: %s", d.Lifecycle.DismissedReason))
        }</span>
}

// renderDescription renders markdown description using glamour.
func renderDescription(w io.Writer, description string) <span class="cov0" title="0">{
        if renderer := getGlamourRenderer(); renderer != nil </span><span class="cov0" title="0">{
                if rendered, err := renderer.Render(description); err == nil </span><span class="cov0" title="0">{
                        // Indent the rendered output
                        for _, line := range strings.Split(rendered, "\n") </span><span class="cov0" title="0">{
                                _, _ = fmt.Fprintf(w, "  %s\n", line)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }
        // Fallback to plain text
        <span class="cov0" title="0">_, _ = fmt.Fprintf(w, "  %s\n", description)</span>
}
</pre>

		<pre class="file" id="file9" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "fmt"
        "io"
        "os"
)

// EmitBell writes the BEL character to stdout to trigger the terminal bell.
// This works on most terminals including iTerm2, Terminal.app, tmux, etc.
func EmitBell() <span class="cov0" title="0">{
        EmitBellTo(os.Stdout)
}</span>

// EmitBellTo writes the BEL character to the specified writer.
// This allows testing without actually emitting to stdout.
func EmitBellTo(w io.Writer) <span class="cov0" title="0">{
        _, _ = fmt.Fprint(w, "\a") // BEL character (ASCII 7)
}</span>

// ShouldNotify checks if a notification should be triggered for an event.
// Returns true if bell is enabled and the event is in the configured events list.
func ShouldNotify(event string, cfg *NotificationConfig) bool <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if !cfg.BellEnabled </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, e := range cfg.Events </span><span class="cov0" title="0">{
                if e == event </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// NotifyIfEnabled emits a bell if the event should trigger a notification.
// This is a convenience function combining ShouldNotify and EmitBell.
func NotifyIfEnabled(event string, cfg *NotificationConfig) <span class="cov0" title="0">{
        if ShouldNotify(event, cfg) </span><span class="cov0" title="0">{
                EmitBell()
        }</span>
}

// NotifyIfEnabledTo emits a bell to the specified writer if the event should trigger a notification.
// This allows testing without actually emitting to stdout.
func NotifyIfEnabledTo(w io.Writer, event string, cfg *NotificationConfig) <span class="cov0" title="0">{
        if ShouldNotify(event, cfg) </span><span class="cov0" title="0">{
                EmitBellTo(w)
        }</span>
}
</pre>

		<pre class="file" id="file10" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "time"

        "github.com/google/uuid"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/domain"
        atlaserrors "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/hook"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/workspace"
        "github.com/spf13/cobra"
)

// AddCheckpointCommand adds the checkpoint command to the root command.
func AddCheckpointCommand(root *cobra.Command) <span class="cov0" title="0">{
        root.AddCommand(newCheckpointCmd())
}</span>

// newCheckpointCmd creates the checkpoint command for manual checkpoint creation.
func newCheckpointCmd() *cobra.Command <span class="cov0" title="0">{
        var trigger string

        cmd := &amp;cobra.Command{
                Use:   "checkpoint [description]",
                Short: "Create a manual checkpoint of current task state",
                Long: `Create a manual checkpoint for the current task.

Checkpoints capture the current state of task execution, including:
- Current step progress
- Git branch and commit state
- File snapshots

Manual checkpoints are useful for marking significant milestones
during task execution. They can be used for recovery if needed.

Trigger types:
  manual       - User-initiated checkpoint (default)
  git_commit   - Triggered by git post-commit hook
  git_push     - Triggered by git post-push hook
  pr_created   - Triggered after PR creation
  validation   - Triggered after validation pass
  step_complete - Triggered on step completion
  interval     - Triggered by interval timer

Examples:
  atlas checkpoint "Completed initial analysis"
  atlas checkpoint "Ready for review"
  atlas checkpoint --trigger git_commit

Exit codes:
  0: Checkpoint created successfully
  1: No active task found
  2: Failed to create checkpoint`,
                Args: cobra.RangeArgs(0, 1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        description := ""
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                description = args[0]
                        }</span>
                        <span class="cov0" title="0">return runCheckpoint(cmd.Context(), cmd, os.Stdout, description, trigger)</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().StringVar(&amp;trigger, "trigger", "manual", "Checkpoint trigger type (manual, git_commit, git_push, pr_created, validation, step_complete, interval)")

        return cmd</span>
}

// runCheckpoint executes the checkpoint command.
func runCheckpoint(ctx context.Context, cmd *cobra.Command, w io.Writer, description, trigger string) error <span class="cov0" title="0">{
        outputFormat := cmd.Flag("output").Value.String()
        out := tui.NewOutput(w, outputFormat)

        // Get base path
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get home directory: %w", err)
        }</span>
        <span class="cov0" title="0">baseDir := filepath.Join(homeDir, constants.AtlasHome)

        // Find active hook
        hookPath, taskID, workspaceID, err := findActiveHookPath(ctx, baseDir)
        if err != nil </span><span class="cov0" title="0">{
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return outputCheckpointErrorJSON(w, err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Create hook store
        <span class="cov0" title="0">hookStore := hook.NewFileStore(baseDir)

        // Get the hook
        h, err := hookStore.Get(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return outputCheckpointErrorJSON(w, fmt.Sprintf("failed to get hook: %v", err))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get hook: %w", err)</span>
        }

        // Create the checkpoint
        <span class="cov0" title="0">now := time.Now().UTC()
        checkpointID := "ckpt-" + uuid.New().String()[:8]

        // Parse trigger type
        triggerType := parseTriggerType(trigger)

        // Set default description based on trigger
        if description == "" </span><span class="cov0" title="0">{
                description = defaultCheckpointDescription(triggerType)
        }</span>

        <span class="cov0" title="0">checkpoint := domain.StepCheckpoint{
                CheckpointID: checkpointID,
                CreatedAt:    now,
                Description:  description,
                Trigger:      triggerType,
        }

        // Add current step info if available
        if h.CurrentStep != nil </span><span class="cov0" title="0">{
                checkpoint.StepName = h.CurrentStep.StepName
                checkpoint.StepIndex = h.CurrentStep.StepIndex
        }</span>

        // Add to checkpoints
        <span class="cov0" title="0">h.Checkpoints = append(h.Checkpoints, checkpoint)
        h.UpdatedAt = now

        // Prune if over limit
        if len(h.Checkpoints) &gt; 50 </span><span class="cov0" title="0">{
                h.Checkpoints = h.Checkpoints[len(h.Checkpoints)-50:]
        }</span>

        // Record in history
        <span class="cov0" title="0">h.History = append(h.History, domain.HookEvent{
                Timestamp: now,
                FromState: h.State,
                ToState:   h.State,
                Trigger:   "manual_checkpoint",
                Details: map[string]any{
                        "checkpoint_id": checkpointID,
                        "description":   description,
                },
        })

        // Save the hook
        if err := hookStore.Save(ctx, h); err != nil </span><span class="cov0" title="0">{
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return outputCheckpointErrorJSON(w, fmt.Sprintf("failed to save checkpoint: %v", err))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to save checkpoint: %w", err)</span>
        }

        <span class="cov0" title="0">if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(map[string]any{
                        "success":       true,
                        "checkpoint_id": checkpointID,
                        "description":   description,
                        "task_id":       taskID,
                        "workspace_id":  workspaceID,
                        "created_at":    now.Format(time.RFC3339),
                })
        }</span>

        <span class="cov0" title="0">out.Success(fmt.Sprintf("Checkpoint created: %s", checkpointID))
        out.Info(fmt.Sprintf("  Description: %s", description))
        out.Info(fmt.Sprintf("  Task: %s", taskID))
        out.Info(fmt.Sprintf("  Hook: %s", hookPath))
        return nil</span>
}

// findActiveHookPath finds the path to an active hook and returns relevant IDs.
func findActiveHookPath(ctx context.Context, baseDir string) (hookPath, taskID, workspaceID string, err error) <span class="cov0" title="0">{
        // Get workspace store
        wsStore, err := workspace.NewFileStore("")
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", fmt.Errorf("failed to create workspace store: %w", err)
        }</span>

        // Find active workspaces
        <span class="cov0" title="0">workspaces, err := wsStore.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", fmt.Errorf("failed to list workspaces: %w", err)
        }</span>

        // Look for hook.json in active workspaces
        <span class="cov0" title="0">for _, ws := range workspaces </span><span class="cov0" title="0">{
                if ws.Status == "closed" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check for hook.json in this workspace's tasks
                <span class="cov0" title="0">tasksDir := filepath.Join(baseDir, "workspaces", ws.Name, "tasks")
                entries, err := os.ReadDir(tasksDir)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                        if !entry.IsDir() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">hp := filepath.Join(tasksDir, entry.Name(), "hook.json")
                        if _, statErr := os.Stat(hp); statErr == nil </span><span class="cov0" title="0">{
                                return hp, entry.Name(), ws.Name, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", "", "", fmt.Errorf("%w: no active task with hook found", atlaserrors.ErrHookNotFound)</span>
}

// outputCheckpointErrorJSON outputs an error result as JSON.
func outputCheckpointErrorJSON(w io.Writer, errMsg string) error <span class="cov0" title="0">{
        out := tui.NewOutput(w, OutputJSON)
        if err := out.JSON(map[string]any{
                "success": false,
                "error":   errMsg,
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return atlaserrors.ErrJSONErrorOutput</span>
}

// parseTriggerType converts a string trigger to CheckpointTrigger.
func parseTriggerType(trigger string) domain.CheckpointTrigger <span class="cov0" title="0">{
        switch trigger </span>{
        case "git_commit":<span class="cov0" title="0">
                return domain.CheckpointTriggerCommit</span>
        case "git_push":<span class="cov0" title="0">
                return domain.CheckpointTriggerPush</span>
        case "pr_created":<span class="cov0" title="0">
                return domain.CheckpointTriggerPR</span>
        case "validation":<span class="cov0" title="0">
                return domain.CheckpointTriggerValidation</span>
        case "step_complete":<span class="cov0" title="0">
                return domain.CheckpointTriggerStepComplete</span>
        case "interval":<span class="cov0" title="0">
                return domain.CheckpointTriggerInterval</span>
        default:<span class="cov0" title="0">
                return domain.CheckpointTriggerManual</span>
        }
}

// defaultCheckpointDescription returns a default description for the trigger type.
func defaultCheckpointDescription(trigger domain.CheckpointTrigger) string <span class="cov0" title="0">{
        switch trigger </span>{
        case domain.CheckpointTriggerCommit:<span class="cov0" title="0">
                return "Git commit checkpoint"</span>
        case domain.CheckpointTriggerPush:<span class="cov0" title="0">
                return "Git push checkpoint"</span>
        case domain.CheckpointTriggerPR:<span class="cov0" title="0">
                return "Pull request created"</span>
        case domain.CheckpointTriggerValidation:<span class="cov0" title="0">
                return "Validation passed"</span>
        case domain.CheckpointTriggerStepComplete:<span class="cov0" title="0">
                return "Step completed"</span>
        case domain.CheckpointTriggerInterval:<span class="cov0" title="0">
                return "Interval checkpoint"</span>
        case domain.CheckpointTriggerManual:<span class="cov0" title="0">
                return "Manual checkpoint"</span>
        default:<span class="cov0" title="0">
                return "Manual checkpoint"</span>
        }
}
</pre>

		<pre class="file" id="file11" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "time"

        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/domain"
        "github.com/mrz1836/atlas/internal/hook"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/spf13/cobra"
)

// Cleanup retention defaults (overridden by config).
const (
        defaultCompletedRetention = 30 * 24 * time.Hour // 30 days
        defaultFailedRetention    = 7 * 24 * time.Hour  // 7 days
        defaultAbandonedRetention = 7 * 24 * time.Hour  // 7 days
)

// AddCleanupCommand adds the cleanup command to the root command.
func AddCleanupCommand(root *cobra.Command) <span class="cov0" title="0">{
        root.AddCommand(newCleanupCmd())
}</span>

// newCleanupCmd creates the cleanup command for removing old artifacts.
func newCleanupCmd() *cobra.Command <span class="cov0" title="0">{
        var dryRun bool
        var hooksOnly bool

        cmd := &amp;cobra.Command{
                Use:   "cleanup",
                Short: "Clean up old task artifacts and hook files",
                Long: `Clean up old task artifacts and hook files based on retention policies.

By default, hooks are retained based on their terminal state:
- Completed hooks: 30 days
- Failed hooks: 7 days
- Abandoned hooks: 7 days

Use --dry-run to preview what would be deleted without actually removing files.
Use --hooks to only clean up hook files (skip other artifact cleanup).

Examples:
  atlas cleanup              # Clean up all old artifacts
  atlas cleanup --dry-run    # Preview what would be deleted
  atlas cleanup --hooks      # Only clean up old hooks

Exit codes:
  0: Cleanup completed successfully
  1: Cleanup failed`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runCleanup(cmd.Context(), cmd, os.Stdout, dryRun, hooksOnly)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "Preview what would be deleted without removing files")
        cmd.Flags().BoolVar(&amp;hooksOnly, "hooks", false, "Only clean up hook files")

        return cmd</span>
}

// runCleanup executes the cleanup command.
func runCleanup(ctx context.Context, cmd *cobra.Command, w io.Writer, dryRun, _ bool) error <span class="cov0" title="0">{
        outputFormat := cmd.Flag("output").Value.String()
        out := tui.NewOutput(w, outputFormat)

        // Load config and get hook store
        hookStore, cfg, err := setupCleanup(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Collect hooks to clean up
        <span class="cov0" title="0">toDelete, stats, err := collectStaleHooks(ctx, hookStore, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Handle empty result
        <span class="cov0" title="0">if len(toDelete) == 0 </span><span class="cov0" title="0">{
                return handleNoHooksToClean(out, outputFormat, dryRun)
        }</span>

        // Handle dry run
        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                return outputDryRunResults(out, outputFormat, toDelete, stats)
        }</span>

        // Perform actual deletion
        <span class="cov0" title="0">return performCleanup(ctx, hookStore, out, outputFormat, toDelete, stats)</span>
}

// setupCleanup initializes the hook store and loads configuration.
func setupCleanup(ctx context.Context) (*hook.FileStore, *config.Config, error) <span class="cov0" title="0">{
        // Load config for retention settings
        cfg, err := config.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                cfg = config.DefaultConfig()
        }</span>

        // Get base path
        <span class="cov0" title="0">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get home directory: %w", err)
        }</span>
        <span class="cov0" title="0">baseDir := filepath.Join(homeDir, constants.AtlasHome)

        // Create hook store
        hookStore := hook.NewFileStore(baseDir)

        return hookStore, cfg, nil</span>
}

// collectStaleHooks collects all hooks that are eligible for cleanup based on retention policies.
func collectStaleHooks(ctx context.Context, hookStore *hook.FileStore, cfg *config.Config) ([]*domain.Hook, cleanupStats, error) <span class="cov0" title="0">{
        var toDelete []*domain.Hook
        var stats cleanupStats

        // Get retention durations from config or use defaults
        completedRetention := getRetentionDuration(cfg.Hooks.Retention.Completed, defaultCompletedRetention)
        failedRetention := getRetentionDuration(cfg.Hooks.Retention.Failed, defaultFailedRetention)
        abandonedRetention := getRetentionDuration(cfg.Hooks.Retention.Abandoned, defaultAbandonedRetention)

        // Find stale hooks for each terminal state
        if err := collectStaleHooksByState(ctx, hookStore, completedRetention, domain.HookStateCompleted, &amp;toDelete, &amp;stats.completed); err != nil </span><span class="cov0" title="0">{
                return nil, stats, fmt.Errorf("failed to list stale completed hooks: %w", err)
        }</span>

        <span class="cov0" title="0">if err := collectStaleHooksByState(ctx, hookStore, failedRetention, domain.HookStateFailed, &amp;toDelete, &amp;stats.failed); err != nil </span><span class="cov0" title="0">{
                return nil, stats, fmt.Errorf("failed to list stale failed hooks: %w", err)
        }</span>

        <span class="cov0" title="0">if err := collectStaleHooksByState(ctx, hookStore, abandonedRetention, domain.HookStateAbandoned, &amp;toDelete, &amp;stats.abandoned); err != nil </span><span class="cov0" title="0">{
                return nil, stats, fmt.Errorf("failed to list stale abandoned hooks: %w", err)
        }</span>

        <span class="cov0" title="0">return toDelete, stats, nil</span>
}

// collectStaleHooksByState collects stale hooks for a specific state.
func collectStaleHooksByState(ctx context.Context, hookStore *hook.FileStore, retention time.Duration, state domain.HookState, toDelete *[]*domain.Hook, count *int) error <span class="cov0" title="0">{
        hooks, err := hookStore.ListStale(ctx, retention)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, h := range hooks </span><span class="cov0" title="0">{
                if h.State == state </span><span class="cov0" title="0">{
                        *toDelete = append(*toDelete, h)
                        *count++
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// handleNoHooksToClean handles the case where no hooks are eligible for cleanup.
func handleNoHooksToClean(out tui.Output, outputFormat string, dryRun bool) error <span class="cov0" title="0">{
        if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(map[string]any{
                        "success": true,
                        "dry_run": dryRun,
                        "deleted": 0,
                        "message": "No hooks eligible for cleanup",
                })
        }</span>
        <span class="cov0" title="0">out.Info("No hooks eligible for cleanup.")
        return nil</span>
}

// performCleanup performs the actual deletion of hooks and outputs results.
func performCleanup(ctx context.Context, hookStore *hook.FileStore, out tui.Output, outputFormat string, toDelete []*domain.Hook, stats cleanupStats) error <span class="cov0" title="0">{
        var deleteErrors []string
        deleted := 0

        for _, h := range toDelete </span><span class="cov0" title="0">{
                if err := hookStore.Delete(ctx, h.TaskID); err != nil </span><span class="cov0" title="0">{
                        deleteErrors = append(deleteErrors, fmt.Sprintf("%s: %v", h.TaskID, err))
                }</span> else<span class="cov0" title="0"> {
                        deleted++
                }</span>
        }

        <span class="cov0" title="0">return outputCleanupResults(out, outputFormat, deleted, stats, deleteErrors)</span>
}

// outputCleanupResults outputs the cleanup results in the appropriate format.
func outputCleanupResults(out tui.Output, outputFormat string, deleted int, stats cleanupStats, deleteErrors []string) error <span class="cov0" title="0">{
        if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                result := map[string]any{
                        "success":   len(deleteErrors) == 0,
                        "dry_run":   false,
                        "deleted":   deleted,
                        "completed": stats.completed,
                        "failed":    stats.failed,
                        "abandoned": stats.abandoned,
                }
                if len(deleteErrors) &gt; 0 </span><span class="cov0" title="0">{
                        result["errors"] = deleteErrors
                }</span>
                <span class="cov0" title="0">return out.JSON(result)</span>
        }

        <span class="cov0" title="0">out.Success(fmt.Sprintf("Cleaned up %d hook files", deleted))
        out.Info(fmt.Sprintf("  Completed: %d", stats.completed))
        out.Info(fmt.Sprintf("  Failed: %d", stats.failed))
        out.Info(fmt.Sprintf("  Abandoned: %d", stats.abandoned))

        if len(deleteErrors) &gt; 0 </span><span class="cov0" title="0">{
                out.Warning(fmt.Sprintf("Failed to delete %d hooks:", len(deleteErrors)))
                for _, errMsg := range deleteErrors </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("  - %s", errMsg))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// cleanupStats tracks cleanup statistics.
type cleanupStats struct {
        completed int
        failed    int
        abandoned int
}

// getRetentionDuration returns the config duration or default if zero.
func getRetentionDuration(configured, defaultDuration time.Duration) time.Duration <span class="cov0" title="0">{
        if configured &gt; 0 </span><span class="cov0" title="0">{
                return configured
        }</span>
        <span class="cov0" title="0">return defaultDuration</span>
}

// outputDryRunResults outputs dry-run results.
func outputDryRunResults(out tui.Output, outputFormat string, toDelete []*domain.Hook, stats cleanupStats) error <span class="cov0" title="0">{
        if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                hooks := make([]map[string]any, len(toDelete))
                for i, h := range toDelete </span><span class="cov0" title="0">{
                        hooks[i] = map[string]any{
                                "task_id":      h.TaskID,
                                "workspace_id": h.WorkspaceID,
                                "state":        h.State,
                                "updated_at":   h.UpdatedAt.Format(time.RFC3339),
                        }
                }</span>
                <span class="cov0" title="0">return out.JSON(map[string]any{
                        "success":      true,
                        "dry_run":      true,
                        "would_delete": len(toDelete),
                        "completed":    stats.completed,
                        "failed":       stats.failed,
                        "abandoned":    stats.abandoned,
                        "hooks":        hooks,
                })</span>
        }

        <span class="cov0" title="0">out.Info(fmt.Sprintf("Would delete %d hook files (dry-run):", len(toDelete)))
        out.Info(fmt.Sprintf("  Completed: %d", stats.completed))
        out.Info(fmt.Sprintf("  Failed: %d", stats.failed))
        out.Info(fmt.Sprintf("  Abandoned: %d", stats.abandoned))
        out.Info("")
        out.Info("Files that would be deleted:")
        for _, h := range toDelete </span><span class="cov0" title="0">{
                out.Info(fmt.Sprintf("  - %s (%s, %s)", h.TaskID, h.State, h.UpdatedAt.Format("2006-01-02")))
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file12" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "bytes"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"
)

// shellType represents supported shell types.
type shellType string

// Sentinel errors for completion commands.
var (
        errUnsupportedShell = errors.New("unsupported shell (supported: zsh, bash, fish)")
        errNoShellDetected  = errors.New("could not detect shell from $SHELL environment variable; use --shell flag")
)

const (
        shellZsh     shellType = "zsh"
        shellBash    shellType = "bash"
        shellFish    shellType = "fish"
        shellUnknown shellType = "unknown"
)

// AddCompletionCommand adds the completion command with subcommands to the root command.
// This replaces Cobra's default completion command with a custom one that includes
// an "install" subcommand for easy setup.
func AddCompletionCommand(rootCmd *cobra.Command) <span class="cov0" title="0">{
        // Disable Cobra's default completion command
        rootCmd.CompletionOptions.DisableDefaultCmd = true

        completionCmd := &amp;cobra.Command{
                Use:   "completion",
                Short: "Generate shell completions",
                Long: `Generate shell completion scripts for atlas.

To install completions automatically:
  atlas completion install

To generate completion scripts manually:
  atlas completion bash
  atlas completion zsh
  atlas completion fish
  atlas completion powershell`,
        }

        // Add shell-specific generation subcommands
        completionCmd.AddCommand(newBashCompletionCmd())
        completionCmd.AddCommand(newZshCompletionCmd())
        completionCmd.AddCommand(newFishCompletionCmd())
        completionCmd.AddCommand(newPowershellCompletionCmd())
        completionCmd.AddCommand(newInstallCompletionCmd())

        rootCmd.AddCommand(completionCmd)
}</span>

func newBashCompletionCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "bash",
                Short: "Generate bash completion script",
                Long: `Generate bash completion script for atlas.

To load completions in current session:
  source &lt;(atlas completion bash)

To install completions permanently:
  atlas completion install --shell bash`,
                DisableFlagsInUseLine: true,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return cmd.Root().GenBashCompletion(cmd.OutOrStdout())
                }</span>,
        }
}

func newZshCompletionCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "zsh",
                Short: "Generate zsh completion script",
                Long: `Generate zsh completion script for atlas.

To load completions in current session:
  source &lt;(atlas completion zsh)

To install completions permanently:
  atlas completion install --shell zsh`,
                DisableFlagsInUseLine: true,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return cmd.Root().GenZshCompletion(cmd.OutOrStdout())
                }</span>,
        }
}

func newFishCompletionCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "fish",
                Short: "Generate fish completion script",
                Long: `Generate fish completion script for atlas.

To load completions in current session:
  atlas completion fish | source

To install completions permanently:
  atlas completion install --shell fish`,
                DisableFlagsInUseLine: true,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return cmd.Root().GenFishCompletion(cmd.OutOrStdout(), true)
                }</span>,
        }
}

func newPowershellCompletionCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "powershell",
                Short: "Generate powershell completion script",
                Long: `Generate powershell completion script for atlas.

To load completions in current session:
  atlas completion powershell | Out-String | Invoke-Expression`,
                DisableFlagsInUseLine: true,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return cmd.Root().GenPowerShellCompletionWithDesc(cmd.OutOrStdout())
                }</span>,
        }
}

func newInstallCompletionCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "install",
                Short: "Install shell completions automatically",
                Long: `Install shell completions for atlas.

This command auto-detects your shell and installs completions to the appropriate location.
You can override the detected shell with the --shell flag.

Supported shells: zsh, bash, fish

Examples:
  atlas completion install              # Auto-detect shell
  atlas completion install --shell zsh  # Force zsh`,
                RunE: runCompletionInstall,
        }

        cmd.Flags().String("shell", "", "Shell to install completions for (zsh, bash, fish)")
        return cmd
}</span>

// runCompletionInstall handles the completion install subcommand.
func runCompletionInstall(cmd *cobra.Command, _ []string) error <span class="cov0" title="0">{
        shellFlag, _ := cmd.Flags().GetString("shell")
        quiet, _ := cmd.Flags().GetBool("quiet")

        // Detect or validate shell
        var shell shellType
        if shellFlag != "" </span><span class="cov0" title="0">{
                shell = shellType(shellFlag)
                if shell != shellZsh &amp;&amp; shell != shellBash &amp;&amp; shell != shellFish </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", shellFlag, errUnsupportedShell)
                }</span>
        } else<span class="cov0" title="0"> {
                shell = detectShell()
                if shell == shellUnknown </span><span class="cov0" title="0">{
                        return errNoShellDetected
                }</span>
        }

        <span class="cov0" title="0">if !quiet </span><span class="cov0" title="0">{
                cmd.Printf("Detected shell: %s\n\n", shell)
                cmd.Println("Installing completions...")
        }</span>

        // Get root command to generate completions
        <span class="cov0" title="0">rootCmd := cmd.Root()

        var err error
        var completionPath string
        var rcUpdated bool

        switch shell </span>{
        case shellZsh:<span class="cov0" title="0">
                completionPath, rcUpdated, err = installZshCompletions(rootCmd, quiet)</span>
        case shellBash:<span class="cov0" title="0">
                completionPath, rcUpdated, err = installBashCompletions(rootCmd, quiet)</span>
        case shellFish:<span class="cov0" title="0">
                completionPath, err = installFishCompletions(rootCmd, quiet)</span>
        case shellUnknown:<span class="cov0" title="0">
                // Already handled above with errNoShellDetected
                return errNoShellDetected</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !quiet </span><span class="cov0" title="0">{
                cmd.Printf("  Created %s\n", completionPath)
                if rcUpdated </span><span class="cov0" title="0">{
                        rcFile := getShellRCFile(shell)
                        cmd.Printf("  Updated %s\n", rcFile)
                }</span>
                <span class="cov0" title="0">cmd.Println()
                cmd.Printf("Done! Restart your shell or run: source %s\n", getShellRCFile(shell))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// detectShell detects the user's shell from the $SHELL environment variable.
func detectShell() shellType <span class="cov0" title="0">{
        shellPath := os.Getenv("SHELL")
        if shellPath == "" </span><span class="cov0" title="0">{
                return shellUnknown
        }</span>

        <span class="cov0" title="0">shellName := filepath.Base(shellPath)
        switch shellName </span>{
        case "zsh":<span class="cov0" title="0">
                return shellZsh</span>
        case "bash":<span class="cov0" title="0">
                return shellBash</span>
        case "fish":<span class="cov0" title="0">
                return shellFish</span>
        default:<span class="cov0" title="0">
                return shellUnknown</span>
        }
}

// getShellRCFile returns the path to the shell's RC file.
func getShellRCFile(shell shellType) string <span class="cov0" title="0">{
        home, _ := os.UserHomeDir()
        switch shell </span>{
        case shellZsh:<span class="cov0" title="0">
                return filepath.Join(home, ".zshrc")</span>
        case shellBash:<span class="cov0" title="0">
                return filepath.Join(home, ".bashrc")</span>
        case shellFish:<span class="cov0" title="0">
                return filepath.Join(home, ".config", "fish", "config.fish")</span>
        case shellUnknown:<span class="cov0" title="0">
                return ""</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// installZshCompletions installs zsh completions to ~/.zsh/completions/_atlas.
func installZshCompletions(rootCmd *cobra.Command, _ bool) (string, bool, error) <span class="cov0" title="0">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("could not determine home directory: %w", err)
        }</span>
        <span class="cov0" title="0">return installZshCompletionsToDir(rootCmd, home)</span>
}

// installZshCompletionsToDir installs zsh completions to a specific home directory.
// This function is extracted for testability.
func installZshCompletionsToDir(rootCmd *cobra.Command, home string) (string, bool, error) <span class="cov0" title="0">{
        // Create completions directory
        completionsDir := filepath.Join(home, ".zsh", "completions")
        if err := os.MkdirAll(completionsDir, 0o750); err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("could not create %s: %w", completionsDir, err)
        }</span>

        // Generate and write completion script
        <span class="cov0" title="0">completionPath := filepath.Join(completionsDir, "_atlas")
        var buf bytes.Buffer
        if err := rootCmd.GenZshCompletion(&amp;buf); err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("could not generate zsh completions: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(completionPath, buf.Bytes(), 0o600); err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("could not write %s: %w", completionPath, err)
        }</span>

        // Update .zshrc if needed
        <span class="cov0" title="0">rcUpdated, err := updateZshRC(home, completionsDir)
        if err != nil </span><span class="cov0" title="0">{
                return completionPath, false, fmt.Errorf("could not update .zshrc: %w", err)
        }</span>

        <span class="cov0" title="0">return completionPath, rcUpdated, nil</span>
}

// updateZshRC ensures fpath and compinit are configured in .zshrc.
func updateZshRC(home, completionsDir string) (bool, error) <span class="cov0" title="0">{
        rcPath := filepath.Clean(filepath.Join(home, ".zshrc"))

        // Read existing content
        content, err := os.ReadFile(rcPath)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">contentStr := string(content)
        var additions []string

        // Check for fpath configuration
        fpathLine := fmt.Sprintf("fpath=(%s $fpath)", completionsDir)
        if !strings.Contains(contentStr, completionsDir) </span><span class="cov0" title="0">{
                additions = append(additions, fpathLine)
        }</span>

        // Check for compinit
        <span class="cov0" title="0">if !strings.Contains(contentStr, "compinit") </span><span class="cov0" title="0">{
                additions = append(additions, "autoload -U compinit &amp;&amp; compinit")
        }</span>

        <span class="cov0" title="0">if len(additions) == 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Append to .zshrc
        <span class="cov0" title="0">f, err := os.OpenFile(rcPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o600)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = f.Close() }</span>()

        // Add a newline and comment before our additions
        <span class="cov0" title="0">toWrite := "\n# Atlas shell completions\n" + strings.Join(additions, "\n") + "\n"
        if _, err = f.WriteString(toWrite); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// installBashCompletions installs bash completions to ~/.bash_completion.d/atlas.
func installBashCompletions(rootCmd *cobra.Command, _ bool) (string, bool, error) <span class="cov0" title="0">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("could not determine home directory: %w", err)
        }</span>
        <span class="cov0" title="0">return installBashCompletionsToDir(rootCmd, home)</span>
}

// installBashCompletionsToDir installs bash completions to a specific home directory.
// This function is extracted for testability.
func installBashCompletionsToDir(rootCmd *cobra.Command, home string) (string, bool, error) <span class="cov0" title="0">{
        // Create completions directory
        completionsDir := filepath.Join(home, ".bash_completion.d")
        if err := os.MkdirAll(completionsDir, 0o750); err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("could not create %s: %w", completionsDir, err)
        }</span>

        // Generate and write completion script
        <span class="cov0" title="0">completionPath := filepath.Join(completionsDir, "atlas")
        var buf bytes.Buffer
        if err := rootCmd.GenBashCompletion(&amp;buf); err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("could not generate bash completions: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(completionPath, buf.Bytes(), 0o600); err != nil </span><span class="cov0" title="0">{
                return "", false, fmt.Errorf("could not write %s: %w", completionPath, err)
        }</span>

        // Update .bashrc if needed
        <span class="cov0" title="0">rcUpdated, err := updateBashRC(home, completionsDir)
        if err != nil </span><span class="cov0" title="0">{
                return completionPath, false, fmt.Errorf("could not update .bashrc: %w", err)
        }</span>

        <span class="cov0" title="0">return completionPath, rcUpdated, nil</span>
}

// updateBashRC ensures completion sourcing is configured in .bashrc.
func updateBashRC(home, completionsDir string) (bool, error) <span class="cov0" title="0">{
        rcPath := filepath.Clean(filepath.Join(home, ".bashrc"))

        // Read existing content
        content, err := os.ReadFile(rcPath)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">contentStr := string(content)

        // Check if our completion directory is already sourced
        if strings.Contains(contentStr, ".bash_completion.d") </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Append sourcing loop to .bashrc
        <span class="cov0" title="0">f, err := os.OpenFile(rcPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0o600)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = f.Close() }</span>()

        <span class="cov0" title="0">sourceLine := fmt.Sprintf(`
# Atlas shell completions
for f in %s/*; do
  [ -f "$f" ] &amp;&amp; source "$f"
done
`, completionsDir)

        if _, err = f.WriteString(sourceLine); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// installFishCompletions installs fish completions to ~/.config/fish/completions/atlas.fish.
func installFishCompletions(rootCmd *cobra.Command, _ bool) (string, error) <span class="cov0" title="0">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not determine home directory: %w", err)
        }</span>
        <span class="cov0" title="0">return installFishCompletionsToDir(rootCmd, home)</span>
}

// installFishCompletionsToDir installs fish completions to a specific home directory.
// This function is extracted for testability.
func installFishCompletionsToDir(rootCmd *cobra.Command, home string) (string, error) <span class="cov0" title="0">{
        // Create completions directory
        completionsDir := filepath.Join(home, ".config", "fish", "completions")
        if err := os.MkdirAll(completionsDir, 0o750); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not create %s: %w", completionsDir, err)
        }</span>

        // Generate and write completion script
        <span class="cov0" title="0">completionPath := filepath.Join(completionsDir, "atlas.fish")
        var buf bytes.Buffer
        if err := rootCmd.GenFishCompletion(&amp;buf, true); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not generate fish completions: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(completionPath, buf.Bytes(), 0o600); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not write %s: %w", completionPath, err)
        }</span>

        // Fish auto-loads from this directory, no RC update needed
        <span class="cov0" title="0">return completionPath, nil</span>
}
</pre>

		<pre class="file" id="file13" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/charmbracelet/lipgloss"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/ctxutil"
        atlaserrors "github.com/mrz1836/atlas/internal/errors"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

// ConfigAIFlags holds flags specific to the config ai command.
type ConfigAIFlags struct {
        // NoInteractive skips all prompts and shows current values.
        NoInteractive bool
}

// newConfigAICmd creates the 'config ai' subcommand for AI configuration.
func newConfigAICmd(flags *ConfigAIFlags) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "ai",
                Short: "Configure AI provider settings",
                Long: `Configure AI provider settings for ATLAS.

This command allows you to update your AI configuration settings without
running the full init wizard. It supports:
  - Default AI model selection (claude: sonnet, opus, haiku; gemini: flash, pro; codex: codex, max, mini)
  - API key environment variable configuration
  - Timeout settings
  - Max turns per step

Supported AI agents: claude (default), gemini, codex
Use --no-interactive to show current values without prompting.`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runConfigAI(cmd.Context(), cmd.OutOrStdout(), flags)
                }</span>,
                SilenceUsage: true,
        }

        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;flags.NoInteractive, "no-interactive", false, "show current values without prompting")

        return cmd</span>
}

// newConfigCmd creates the 'config' parent command.
func newConfigCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "config",
                Short: "Manage ATLAS configuration",
                Long: `Manage ATLAS configuration settings.

Subcommands:
  show          Display effective configuration with sources
  ai            Configure AI provider settings
  validation    Configure validation command settings
  notifications Configure notification settings

Example:
  atlas config show          # Show current config with source annotations
  atlas config ai            # Configure AI settings interactively
  atlas config validation    # Configure validation commands interactively
  atlas config notifications # Configure notification settings interactively`,
        }

        // Add subcommands
        aiFlags := &amp;ConfigAIFlags{}
        cmd.AddCommand(newConfigAICmd(aiFlags))

        // Add validation subcommand
        AddConfigValidationCommand(cmd)

        // Add notifications subcommand
        AddConfigNotificationCommand(cmd)

        // Add show subcommand
        AddConfigShowCommand(cmd)

        return cmd
}</span>

// AddConfigCommand adds the config command to the root command.
func AddConfigCommand(rootCmd *cobra.Command) <span class="cov0" title="0">{
        rootCmd.AddCommand(newConfigCmd())
}</span>

// runConfigAI executes the config ai command.
func runConfigAI(ctx context.Context, w io.Writer, flags *ConfigAIFlags) error <span class="cov0" title="0">{
        // Check cancellation at entry
        if err := ctxutil.Canceled(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">styles := newConfigAIStyles()

        // Load existing configuration
        existingCfg, configPath, err := loadExistingConfig()
        if err != nil </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, styles.warning.Render("⚠ No existing configuration found. Run 'atlas init' first or create a new configuration."))
        }</span>

        // Display current configuration if exists
        <span class="cov0" title="0">if existingCfg != nil </span><span class="cov0" title="0">{
                displayCurrentAIConfig(w, existingCfg, styles)
        }</span>

        // If non-interactive, just show current config
        <span class="cov0" title="0">if flags.NoInteractive </span><span class="cov0" title="0">{
                if existingCfg == nil </span><span class="cov0" title="0">{
                        _, _ = fmt.Fprintln(w, styles.dim.Render("No AI configuration found. Run 'atlas config ai' interactively to configure."))
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Collect new configuration
        <span class="cov0" title="0">_, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.header.Render("Update AI Configuration"))
        _, _ = fmt.Fprintln(w, styles.dim.Render(strings.Repeat("─", 30)))

        // Start with existing values or defaults
        aiCfg := &amp;AIProviderConfig{}
        if existingCfg != nil </span><span class="cov0" title="0">{
                aiCfg.Model = existingCfg.AI.Model
                aiCfg.APIKeyEnvVar = existingCfg.AI.APIKeyEnvVar
                aiCfg.Timeout = existingCfg.AI.Timeout
                aiCfg.MaxTurns = existingCfg.AI.MaxTurns
        }</span>

        <span class="cov0" title="0">if err = CollectAIConfigInteractive(ctx, aiCfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if API key environment variable is set
        <span class="cov0" title="0">if exists, warning := CheckAPIKeyExists(aiCfg.APIKeyEnvVar); !exists </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w)
                _, _ = fmt.Fprintln(w, styles.warning.Render("⚠ "+warning))
        }</span>

        // Merge with existing config (or create new one)
        <span class="cov0" title="0">var finalCfg AtlasConfig
        if existingCfg != nil </span><span class="cov0" title="0">{
                finalCfg = *existingCfg
        }</span>
        <span class="cov0" title="0">finalCfg.AI = AIConfig{
                Model:        aiCfg.Model,
                APIKeyEnvVar: aiCfg.APIKeyEnvVar,
                Timeout:      aiCfg.Timeout,
                MaxTurns:     aiCfg.MaxTurns,
        }

        // Save configuration using shared function
        if err = saveAtlasConfig(finalCfg, "Updated by atlas config ai"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration: %w", err)
        }</span>

        // Display success
        <span class="cov0" title="0">_, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.success.Render("✓ AI configuration updated successfully!"))
        _, _ = fmt.Fprintln(w, styles.dim.Render("Configuration saved to: "+configPath))

        return nil</span>
}

// configAIStyles contains styling for the config ai command output.
type configAIStyles struct {
        header  lipgloss.Style
        success lipgloss.Style
        warning lipgloss.Style
        dim     lipgloss.Style
        key     lipgloss.Style
        value   lipgloss.Style
}

// newConfigAIStyles creates styles for config ai command output.
func newConfigAIStyles() *configAIStyles <span class="cov0" title="0">{
        return &amp;configAIStyles{
                header: lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("#00D7FF")).
                        MarginBottom(1),
                success: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00FF87")).
                        Bold(true),
                warning: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFD700")),
                dim: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#666666")),
                key: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00D7FF")),
                value: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFFFFF")),
        }
}</span>

// displayCurrentAIConfig shows the current AI configuration.
func displayCurrentAIConfig(w io.Writer, cfg *AtlasConfig, styles *configAIStyles) <span class="cov0" title="0">{
        _, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.header.Render("Current AI Configuration"))
        _, _ = fmt.Fprintln(w, styles.dim.Render(strings.Repeat("─", 30)))

        _, _ = fmt.Fprintf(w, "%s: %s\n",
                styles.key.Render("Model"),
                styles.value.Render(cfg.AI.Model))
        _, _ = fmt.Fprintf(w, "%s: %s\n",
                styles.key.Render("API Key Env Var"),
                styles.value.Render(cfg.AI.APIKeyEnvVar))
        _, _ = fmt.Fprintf(w, "%s: %s\n",
                styles.key.Render("Timeout"),
                styles.value.Render(cfg.AI.Timeout))
        _, _ = fmt.Fprintf(w, "%s: %d\n",
                styles.key.Render("Max Turns"),
                cfg.AI.MaxTurns)

        // Check if API key is set
        if exists, _ := CheckAPIKeyExists(cfg.AI.APIKeyEnvVar); exists </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "%s: %s\n",
                        styles.key.Render("API Key Status"),
                        styles.success.Render("✓ Set"))
        }</span> else<span class="cov0" title="0"> {
                _, _ = fmt.Fprintf(w, "%s: %s\n",
                        styles.key.Render("API Key Status"),
                        styles.warning.Render("⚠ Not set"))
        }</span>
}

// loadExistingConfig loads the existing ATLAS configuration if present.
// Returns the config, the config file path, and any error.
func loadExistingConfig() (*AtlasConfig, string, error) <span class="cov0" title="0">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov0" title="0">configPath := filepath.Join(home, constants.AtlasHome, constants.GlobalConfigName)

        data, err := os.ReadFile(configPath) //nolint:gosec // Config file path from home dir
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, configPath, atlaserrors.ErrConfigNotFound
                }</span>
                <span class="cov0" title="0">return nil, configPath, fmt.Errorf("failed to read config: %w", err)</span>
        }

        <span class="cov0" title="0">var cfg AtlasConfig
        if err = yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, configPath, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;cfg, configPath, nil</span>
}
</pre>

		<pre class="file" id="file14" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "fmt"
        "io"
        "strings"

        "github.com/charmbracelet/lipgloss"
        "github.com/mrz1836/atlas/internal/ctxutil"
        "github.com/spf13/cobra"
)

// ConfigNotificationFlags holds flags specific to the config notifications command.
type ConfigNotificationFlags struct {
        // NoInteractive skips all prompts and shows current values.
        NoInteractive bool
}

// newConfigNotificationCmd creates the 'config notifications' subcommand for notification configuration.
func newConfigNotificationCmd(flags *ConfigNotificationFlags) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "notifications",
                Short: "Configure notification settings",
                Long: `Configure notification settings for ATLAS.

This command allows you to update your notification configuration settings without
running the full init wizard. It supports:
  - Terminal bell enable/disable
  - Notification event selection (task awaiting approval, validation failed, etc.)

Use --no-interactive to show current values without prompting.`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runConfigNotification(cmd.Context(), cmd.OutOrStdout(), flags)
                }</span>,
                SilenceUsage: true,
        }

        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;flags.NoInteractive, "no-interactive", false, "show current values without prompting")

        return cmd</span>
}

// AddConfigNotificationCommand adds the 'notifications' subcommand to the config command.
// This is called from config_ai.go where the config command is defined.
func AddConfigNotificationCommand(configCmd *cobra.Command) <span class="cov0" title="0">{
        flags := &amp;ConfigNotificationFlags{}
        configCmd.AddCommand(newConfigNotificationCmd(flags))
}</span>

// runConfigNotification executes the config notifications command.
func runConfigNotification(ctx context.Context, w io.Writer, flags *ConfigNotificationFlags) error <span class="cov0" title="0">{
        // Check cancellation at entry
        if err := ctxutil.Canceled(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">styles := newConfigNotificationStyles()

        // Load and display existing configuration
        existingCfg, configPath, err := loadExistingConfig()
        if err != nil </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, styles.warning.Render("⚠ No existing configuration found. Run 'atlas init' first or create a new configuration."))
        }</span>
        <span class="cov0" title="0">if existingCfg != nil </span><span class="cov0" title="0">{
                displayCurrentNotificationConfig(w, existingCfg, styles)
        }</span>

        // Handle non-interactive mode
        <span class="cov0" title="0">if flags.NoInteractive </span><span class="cov0" title="0">{
                if existingCfg == nil </span><span class="cov0" title="0">{
                        _, _ = fmt.Fprintln(w, styles.dim.Render("No notification configuration found. Run 'atlas config notifications' interactively to configure."))
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Collect new configuration
        <span class="cov0" title="0">_, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.header.Render("Update Notification Configuration"))
        _, _ = fmt.Fprintln(w, styles.dim.Render(strings.Repeat("─", 35)))

        // Start with existing values or defaults
        notifyCfg := &amp;NotificationProviderConfig{}
        if existingCfg != nil </span><span class="cov0" title="0">{
                notifyCfg.BellEnabled = existingCfg.Notifications.BellEnabled
                notifyCfg.Events = existingCfg.Notifications.Events
        }</span> else<span class="cov0" title="0"> {
                defaults := NotificationConfigDefaults()
                notifyCfg.BellEnabled = defaults.BellEnabled
                notifyCfg.Events = defaults.Events
        }</span>

        <span class="cov0" title="0">if err = CollectNotificationConfigInteractive(ctx, notifyCfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("notification configuration failed: %w", err)
        }</span>

        // Merge with existing config (or create new one)
        <span class="cov0" title="0">var finalCfg AtlasConfig
        if existingCfg != nil </span><span class="cov0" title="0">{
                finalCfg = *existingCfg
        }</span>
        <span class="cov0" title="0">finalCfg.Notifications = notifyCfg.ToNotificationConfig()

        // Save configuration using shared function
        if err = saveAtlasConfig(finalCfg, "Updated by atlas config notifications"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration: %w", err)
        }</span>

        // Display success
        <span class="cov0" title="0">_, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.success.Render("✓ Notification configuration updated successfully!"))
        _, _ = fmt.Fprintln(w, styles.dim.Render("Configuration saved to: "+configPath))

        return nil</span>
}

// configNotificationStyles contains styling for the config notifications command output.
type configNotificationStyles struct {
        header  lipgloss.Style
        success lipgloss.Style
        warning lipgloss.Style
        dim     lipgloss.Style
        key     lipgloss.Style
        value   lipgloss.Style
}

// newConfigNotificationStyles creates styles for config notifications command output.
func newConfigNotificationStyles() *configNotificationStyles <span class="cov0" title="0">{
        return &amp;configNotificationStyles{
                header: lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("#00D7FF")).
                        MarginBottom(1),
                success: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00FF87")).
                        Bold(true),
                warning: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFD700")),
                dim: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#666666")),
                key: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00D7FF")),
                value: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFFFFF")),
        }
}</span>

// displayCurrentNotificationConfig shows the current notification configuration.
func displayCurrentNotificationConfig(w io.Writer, cfg *AtlasConfig, styles *configNotificationStyles) <span class="cov0" title="0">{
        _, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.header.Render("Current Notification Configuration"))
        _, _ = fmt.Fprintln(w, styles.dim.Render(strings.Repeat("─", 35)))

        // Display bell status
        bellStatus := "Disabled"
        if cfg.Notifications.BellEnabled </span><span class="cov0" title="0">{
                bellStatus = "Enabled"
        }</span>
        <span class="cov0" title="0">_, _ = fmt.Fprintf(w, "%s: %s\n",
                styles.key.Render("Terminal Bell"),
                styles.value.Render(bellStatus))

        // Display events
        _, _ = fmt.Fprintf(w, "%s:\n", styles.key.Render("Notification Events"))
        if len(cfg.Notifications.Events) == 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "  %s\n", styles.dim.Render("(none configured)"))
        }</span> else<span class="cov0" title="0"> {
                for _, event := range cfg.Notifications.Events </span><span class="cov0" title="0">{
                        _, _ = fmt.Fprintf(w, "  ✓ %s\n", styles.value.Render(formatEventName(event)))
                }</span>
        }
}

// formatEventName converts an event constant to a human-readable name.
func formatEventName(event string) string <span class="cov0" title="0">{
        switch event </span>{
        case NotifyEventAwaitingApproval:<span class="cov0" title="0">
                return "Task awaiting approval"</span>
        case NotifyEventValidationFailed:<span class="cov0" title="0">
                return "Validation failed"</span>
        case NotifyEventCIFailed:<span class="cov0" title="0">
                return "CI failed"</span>
        case NotifyEventGitHubFailed:<span class="cov0" title="0">
                return "GitHub operation failed"</span>
        default:<span class="cov0" title="0">
                return event</span>
        }
}
</pre>

		<pre class="file" id="file15" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/charmbracelet/lipgloss"
        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/errors"
        "github.com/spf13/cobra"
)

// ConfigShowFlags holds flags specific to the config show command.
type ConfigShowFlags struct {
        // OutputFormat specifies the output format (yaml or json).
        OutputFormat string
}

// newConfigShowCmd creates the 'config show' subcommand for displaying configuration.
func newConfigShowCmd(flags *ConfigShowFlags) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "show",
                Short: "Display effective configuration",
                Long: `Display the effective ATLAS configuration with source annotations.

Shows the current configuration values and indicates where each value comes from:
  - default: Built-in default value
  - global: From ~/.atlas/config.yaml
  - project: From .atlas/config.yaml
  - env: From ATLAS_* environment variable

Sensitive values (API keys, tokens) are masked in the output.

Examples:
  atlas config show           # Display config in YAML format with sources
  atlas config show --output json   # Display config in JSON format`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runConfigShow(cmd.Context(), cmd.OutOrStdout(), flags)
                }</span>,
                SilenceUsage: true,
        }

        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;flags.OutputFormat, "output", "o", "yaml", "output format (yaml or json)")

        return cmd</span>
}

// AddConfigShowCommand adds the show subcommand to the config command.
func AddConfigShowCommand(configCmd *cobra.Command) <span class="cov0" title="0">{
        flags := &amp;ConfigShowFlags{}
        configCmd.AddCommand(newConfigShowCmd(flags))
}</span>

// ConfigSource represents where a configuration value came from.
type ConfigSource string

const (
        // SourceDefault indicates the value is a built-in default.
        SourceDefault ConfigSource = "default"
        // SourceGlobal indicates the value came from global config.
        SourceGlobal ConfigSource = "global"
        // SourceProject indicates the value came from project config.
        SourceProject ConfigSource = "project"
        // SourceEnv indicates the value came from an environment variable.
        SourceEnv ConfigSource = "env"
)

// ConfigValueWithSource represents a configuration value with its source.
type ConfigValueWithSource struct {
        Value  any          `json:"value" yaml:"value"`
        Source ConfigSource `json:"source" yaml:"source"`
}

// AnnotatedConfig represents configuration with source annotations.
type AnnotatedConfig struct {
        AI            map[string]ConfigValueWithSource `json:"ai" yaml:"ai"`
        Git           map[string]ConfigValueWithSource `json:"git" yaml:"git"`
        Worktree      map[string]ConfigValueWithSource `json:"worktree" yaml:"worktree"`
        CI            map[string]ConfigValueWithSource `json:"ci" yaml:"ci"`
        Templates     map[string]ConfigValueWithSource `json:"templates" yaml:"templates"`
        Validation    map[string]ConfigValueWithSource `json:"validation" yaml:"validation"`
        Notifications map[string]ConfigValueWithSource `json:"notifications" yaml:"notifications"`
}

// configShowStyles contains styling for the config show command output.
type configShowStyles struct {
        header    lipgloss.Style
        section   lipgloss.Style
        key       lipgloss.Style
        value     lipgloss.Style
        sourceEnv lipgloss.Style
        sourcePrj lipgloss.Style
        sourceGbl lipgloss.Style
        sourceDef lipgloss.Style
        masked    lipgloss.Style
        dim       lipgloss.Style
}

// newConfigShowStyles creates styles for config show command output.
func newConfigShowStyles() *configShowStyles <span class="cov0" title="0">{
        return &amp;configShowStyles{
                header: lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("#00D7FF")).
                        MarginBottom(1),
                section: lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("#FFFFFF")),
                key: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00D7FF")),
                value: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFFFFF")),
                sourceEnv: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FF5F5F")), // Red for env (highest precedence)
                sourcePrj: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFD700")), // Yellow for project
                sourceGbl: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00FF87")), // Green for global
                sourceDef: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#666666")), // Gray for default
                masked: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FF5F5F")),
                dim: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#666666")),
        }
}</span>

// runConfigShow executes the config show command.
func runConfigShow(ctx context.Context, w io.Writer, flags *ConfigShowFlags) error <span class="cov0" title="0">{
        // Check cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        // Load the effective configuration
        <span class="cov0" title="0">cfg, err := config.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Build annotated configuration with sources
        <span class="cov0" title="0">annotated := buildAnnotatedConfig(cfg)

        // Output based on format
        switch strings.ToLower(flags.OutputFormat) </span>{
        case "json":<span class="cov0" title="0">
                return outputJSON(w, annotated)</span>
        case "yaml":<span class="cov0" title="0">
                return outputYAML(w, cfg, annotated)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("%w: %s (use yaml or json)", errors.ErrUnsupportedOutputFormat, flags.OutputFormat)</span>
        }
}

// buildAnnotatedConfig creates an annotated configuration with source information.
func buildAnnotatedConfig(cfg *config.Config) *AnnotatedConfig <span class="cov0" title="0">{
        // Load individual config sources to determine where each value came from
        globalCfg := loadGlobalConfigOnly()
        projectCfg := loadProjectConfigOnly()

        annotated := &amp;AnnotatedConfig{
                AI:            make(map[string]ConfigValueWithSource),
                Git:           make(map[string]ConfigValueWithSource),
                Worktree:      make(map[string]ConfigValueWithSource),
                CI:            make(map[string]ConfigValueWithSource),
                Templates:     make(map[string]ConfigValueWithSource),
                Validation:    make(map[string]ConfigValueWithSource),
                Notifications: make(map[string]ConfigValueWithSource),
        }

        // AI section
        annotated.AI["agent"] = determineSource("ai.agent", cfg.AI.Agent, globalCfg, projectCfg, "claude")
        annotated.AI["model"] = determineSource("ai.model", cfg.AI.Model, globalCfg, projectCfg, "sonnet")
        // For api_key_env_vars, show the value for the current agent
        currentAgentEnvVar := cfg.AI.GetAPIKeyEnvVar(cfg.AI.Agent)
        annotated.AI["api_key_env_var"] = determineSource("ai.api_key_env_vars", currentAgentEnvVar, globalCfg, projectCfg, "ANTHROPIC_API_KEY")
        annotated.AI["timeout"] = determineSource("ai.timeout", cfg.AI.Timeout.String(), globalCfg, projectCfg, constants.DefaultAITimeout.String())
        annotated.AI["max_turns"] = determineSource("ai.max_turns", cfg.AI.MaxTurns, globalCfg, projectCfg, 10)

        // Git section
        annotated.Git["base_branch"] = determineSource("git.base_branch", cfg.Git.BaseBranch, globalCfg, projectCfg, "main")
        annotated.Git["auto_proceed_git"] = determineSource("git.auto_proceed_git", cfg.Git.AutoProceedGit, globalCfg, projectCfg, true)
        annotated.Git["remote"] = determineSource("git.remote", cfg.Git.Remote, globalCfg, projectCfg, "origin")

        // Worktree section
        annotated.Worktree["base_dir"] = determineSource("worktree.base_dir", cfg.Worktree.BaseDir, globalCfg, projectCfg, "")
        annotated.Worktree["naming_suffix"] = determineSource("worktree.naming_suffix", cfg.Worktree.NamingSuffix, globalCfg, projectCfg, "")

        // CI section
        annotated.CI["timeout"] = determineSource("ci.timeout", cfg.CI.Timeout.String(), globalCfg, projectCfg, constants.DefaultCITimeout.String())
        annotated.CI["poll_interval"] = determineSource("ci.poll_interval", cfg.CI.PollInterval.String(), globalCfg, projectCfg, constants.CIPollInterval.String())

        // Notifications section
        annotated.Notifications["bell"] = determineSource("notifications.bell", cfg.Notifications.Bell, globalCfg, projectCfg, true)
        annotated.Notifications["events"] = determineSource("notifications.events", cfg.Notifications.Events, globalCfg, projectCfg, []string{"awaiting_approval", "validation_failed"})

        return annotated
}</span>

// configValues represents parsed config values for source determination.
type configValues map[string]any

// loadGlobalConfigOnly loads only the global config for source comparison.
func loadGlobalConfigOnly() configValues <span class="cov0" title="0">{
        globalDir, err := config.GlobalConfigDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">globalConfigPath := filepath.Join(globalDir, "config.yaml")
        return loadConfigFile(globalConfigPath)</span>
}

// loadProjectConfigOnly loads only the project config for source comparison.
func loadProjectConfigOnly() configValues <span class="cov0" title="0">{
        projectConfigPath := config.ProjectConfigPath()
        return loadConfigFile(projectConfigPath)
}</span>

// loadConfigFile loads a config file into a map for source determination.
func loadConfigFile(path string) configValues <span class="cov0" title="0">{
        data, err := os.ReadFile(path) //nolint:gosec // Config file path
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Parse YAML into a map
        <span class="cov0" title="0">result := make(configValues)
        lines := strings.Split(string(data), "\n")
        currentSection := ""

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if this is a section header (no colon after first word or value is empty)
                <span class="cov0" title="0">if strings.HasSuffix(line, ":") &amp;&amp; !strings.Contains(line[:len(line)-1], " ") </span><span class="cov0" title="0">{
                        currentSection = strings.TrimSuffix(line, ":")
                        continue</span>
                }

                // Parse key: value
                <span class="cov0" title="0">parts := strings.SplitN(line, ":", 2)
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        key := strings.TrimSpace(parts[0])
                        value := strings.TrimSpace(parts[1])
                        if currentSection != "" </span><span class="cov0" title="0">{
                                result[currentSection+"."+key] = value
                        }</span> else<span class="cov0" title="0"> {
                                result[key] = value
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

// determineSource determines where a configuration value came from.
func determineSource(key string, value any, globalCfg, projectCfg configValues, _ any) ConfigValueWithSource <span class="cov0" title="0">{
        // Check env var first (highest precedence after CLI)
        envKey := "ATLAS_" + strings.ToUpper(strings.ReplaceAll(key, ".", "_"))
        if envVal := os.Getenv(envKey); envVal != "" </span><span class="cov0" title="0">{
                return ConfigValueWithSource{Value: value, Source: SourceEnv}
        }</span>

        // Check project config
        <span class="cov0" title="0">if projectCfg != nil </span><span class="cov0" title="0">{
                if _, exists := projectCfg[key]; exists </span><span class="cov0" title="0">{
                        return ConfigValueWithSource{Value: value, Source: SourceProject}
                }</span>
        }

        // Check global config
        <span class="cov0" title="0">if globalCfg != nil </span><span class="cov0" title="0">{
                if _, exists := globalCfg[key]; exists </span><span class="cov0" title="0">{
                        return ConfigValueWithSource{Value: value, Source: SourceGlobal}
                }</span>
        }

        // Must be default
        <span class="cov0" title="0">return ConfigValueWithSource{Value: value, Source: SourceDefault}</span>
}

// outputJSON outputs the configuration in JSON format.
func outputJSON(w io.Writer, annotated *AnnotatedConfig) error <span class="cov0" title="0">{
        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(annotated)
}</span>

// outputYAML outputs the configuration in YAML format with source comments.
func outputYAML(w io.Writer, cfg *config.Config, annotated *AnnotatedConfig) error <span class="cov0" title="0">{
        styles := newConfigShowStyles()

        _, _ = fmt.Fprintln(w, styles.header.Render("Effective ATLAS Configuration"))
        _, _ = fmt.Fprintln(w, styles.dim.Render(strings.Repeat("─", 50)))
        _, _ = fmt.Fprintln(w)

        // Display legend
        _, _ = fmt.Fprintln(w, styles.dim.Render("Sources: ")+
                styles.sourceEnv.Render("env")+" &gt; "+
                styles.sourcePrj.Render("project")+" &gt; "+
                styles.sourceGbl.Render("global")+" &gt; "+
                styles.sourceDef.Render("default"))
        _, _ = fmt.Fprintln(w)

        // AI section
        _, _ = fmt.Fprintln(w, styles.section.Render("ai:"))
        printConfigValue(w, styles, "  agent", annotated.AI["agent"])
        printConfigValue(w, styles, "  model", annotated.AI["model"])
        printConfigValue(w, styles, "  api_key_env_var", annotated.AI["api_key_env_var"])
        printConfigValue(w, styles, "  timeout", annotated.AI["timeout"])
        printConfigValue(w, styles, "  max_turns", annotated.AI["max_turns"])
        _, _ = fmt.Fprintln(w)

        // Git section
        _, _ = fmt.Fprintln(w, styles.section.Render("git:"))
        printConfigValue(w, styles, "  base_branch", annotated.Git["base_branch"])
        printConfigValue(w, styles, "  auto_proceed_git", annotated.Git["auto_proceed_git"])
        printConfigValue(w, styles, "  remote", annotated.Git["remote"])
        _, _ = fmt.Fprintln(w)

        // Worktree section
        _, _ = fmt.Fprintln(w, styles.section.Render("worktree:"))
        printConfigValue(w, styles, "  base_dir", annotated.Worktree["base_dir"])
        printConfigValue(w, styles, "  naming_suffix", annotated.Worktree["naming_suffix"])
        _, _ = fmt.Fprintln(w)

        // CI section
        _, _ = fmt.Fprintln(w, styles.section.Render("ci:"))
        printConfigValue(w, styles, "  timeout", annotated.CI["timeout"])
        printConfigValue(w, styles, "  poll_interval", annotated.CI["poll_interval"])
        _, _ = fmt.Fprintln(w)

        // Validation section
        _, _ = fmt.Fprintln(w, styles.section.Render("validation:"))
        printConfigValue(w, styles, "  timeout", ConfigValueWithSource{Value: cfg.Validation.Timeout.String(), Source: SourceDefault})
        printConfigValue(w, styles, "  parallel_execution", ConfigValueWithSource{Value: cfg.Validation.ParallelExecution, Source: SourceDefault})
        _, _ = fmt.Fprintln(w, styles.key.Render("  commands:"))
        if len(cfg.Validation.Commands.Format) &gt; 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "    %s: %v\n", styles.key.Render("format"), cfg.Validation.Commands.Format)
        }</span>
        <span class="cov0" title="0">if len(cfg.Validation.Commands.Lint) &gt; 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "    %s: %v\n", styles.key.Render("lint"), cfg.Validation.Commands.Lint)
        }</span>
        <span class="cov0" title="0">if len(cfg.Validation.Commands.Test) &gt; 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "    %s: %v\n", styles.key.Render("test"), cfg.Validation.Commands.Test)
        }</span>
        <span class="cov0" title="0">if len(cfg.Validation.Commands.PreCommit) &gt; 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "    %s: %v\n", styles.key.Render("pre_commit"), cfg.Validation.Commands.PreCommit)
        }</span>
        <span class="cov0" title="0">_, _ = fmt.Fprintln(w)

        // Notifications section
        _, _ = fmt.Fprintln(w, styles.section.Render("notifications:"))
        printConfigValue(w, styles, "  bell", annotated.Notifications["bell"])
        printConfigValue(w, styles, "  events", annotated.Notifications["events"])
        _, _ = fmt.Fprintln(w)

        // Config file locations
        _, _ = fmt.Fprintln(w, styles.dim.Render("Configuration files:"))
        if globalPath, err := config.GlobalConfigPath(); err == nil </span><span class="cov0" title="0">{
                if _, err := os.Stat(globalPath); err == nil </span><span class="cov0" title="0">{
                        _, _ = fmt.Fprintln(w, styles.dim.Render("  Global: ")+styles.sourceGbl.Render(globalPath))
                }</span> else<span class="cov0" title="0"> {
                        _, _ = fmt.Fprintln(w, styles.dim.Render("  Global: ")+styles.dim.Render(globalPath+" (not found)"))
                }</span>
        }

        <span class="cov0" title="0">projectPath := config.ProjectConfigPath()
        if _, err := os.Stat(projectPath); err == nil </span><span class="cov0" title="0">{
                absPath, _ := filepath.Abs(projectPath)
                _, _ = fmt.Fprintln(w, styles.dim.Render("  Project: ")+styles.sourcePrj.Render(absPath))
        }</span> else<span class="cov0" title="0"> {
                _, _ = fmt.Fprintln(w, styles.dim.Render("  Project: ")+styles.dim.Render(projectPath+" (not found)"))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// printConfigValue prints a configuration value with its source annotation.
func printConfigValue(w io.Writer, styles *configShowStyles, key string, vs ConfigValueWithSource) <span class="cov0" title="0">{
        valueStr := formatConfigValue(vs.Value)
        valueStr = maskSensitiveValue(key, valueStr, vs.Source, styles)
        sourceStyle := getSourceStyle(vs.Source, styles)

        _, _ = fmt.Fprintf(w, "%s: %s  %s\n",
                styles.key.Render(key),
                styles.value.Render(valueStr),
                sourceStyle.Render("# "+string(vs.Source)))
}</span>

// formatConfigValue converts a configuration value to a displayable string.
func formatConfigValue(value any) string <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case string:<span class="cov0" title="0">
                if v == "" </span><span class="cov0" title="0">{
                        return "(not set)"
                }</span>
                <span class="cov0" title="0">return v</span>
        case []string:<span class="cov0" title="0">
                if len(v) == 0 </span><span class="cov0" title="0">{
                        return "[]"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("[%s]", strings.Join(v, ", "))</span>
        case []any:<span class="cov0" title="0">
                if len(v) == 0 </span><span class="cov0" title="0">{
                        return "[]"
                }</span>
                <span class="cov0" title="0">strs := make([]string, len(v))
                for i, item := range v </span><span class="cov0" title="0">{
                        strs[i] = fmt.Sprintf("%v", item)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("[%s]", strings.Join(strs, ", "))</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v)</span>
        }
}

// maskSensitiveValue masks sensitive values like API keys.
func maskSensitiveValue(key, valueStr string, source ConfigSource, styles *configShowStyles) string <span class="cov0" title="0">{
        lowerKey := strings.ToLower(key)
        isSensitive := strings.Contains(lowerKey, "key") ||
                strings.Contains(lowerKey, "secret") ||
                strings.Contains(lowerKey, "token") ||
                strings.Contains(lowerKey, "password")

        if !isSensitive </span><span class="cov0" title="0">{
                return valueStr
        }</span>

        // Only mask actual secret values, not env var names
        <span class="cov0" title="0">if source == SourceEnv &amp;&amp; valueStr != "(not set)" &amp;&amp; valueStr != "" </span><span class="cov0" title="0">{
                if !strings.HasPrefix(valueStr, "ANTHROPIC") &amp;&amp; !strings.HasSuffix(valueStr, "_KEY") </span><span class="cov0" title="0">{
                        return styles.masked.Render("****")
                }</span>
        }

        <span class="cov0" title="0">return valueStr</span>
}

// getSourceStyle returns the appropriate style for a config source.
func getSourceStyle(source ConfigSource, styles *configShowStyles) lipgloss.Style <span class="cov0" title="0">{
        switch source </span>{
        case SourceEnv:<span class="cov0" title="0">
                return styles.sourceEnv</span>
        case SourceProject:<span class="cov0" title="0">
                return styles.sourcePrj</span>
        case SourceGlobal:<span class="cov0" title="0">
                return styles.sourceGbl</span>
        case SourceDefault:<span class="cov0" title="0">
                return styles.sourceDef</span>
        default:<span class="cov0" title="0">
                return styles.sourceDef</span>
        }
}
</pre>

		<pre class="file" id="file16" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "fmt"
        "io"
        "strings"

        "github.com/charmbracelet/lipgloss"
        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/ctxutil"
        "github.com/spf13/cobra"
)

// ConfigValidationFlags holds flags specific to the config validation command.
type ConfigValidationFlags struct {
        // NoInteractive skips all prompts and shows current values.
        NoInteractive bool
}

// newConfigValidationCmd creates the 'config validation' subcommand for validation configuration.
func newConfigValidationCmd(flags *ConfigValidationFlags) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "validation",
                Short: "Configure validation command settings",
                Long: `Configure validation command settings for ATLAS.

This command allows you to update your validation configuration settings without
running the full init wizard. It supports:
  - Format commands (code formatting)
  - Lint commands (code linting)
  - Test commands (running tests)
  - Pre-commit commands (git hooks)
  - Custom pre-PR hooks

Commands are validated against your PATH and warnings are shown for missing executables.

Use --no-interactive to show current values without prompting.`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runConfigValidation(cmd.Context(), cmd.OutOrStdout(), flags)
                }</span>,
                SilenceUsage: true,
        }

        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;flags.NoInteractive, "no-interactive", false, "show current values without prompting")

        return cmd</span>
}

// AddConfigValidationCommand adds the 'validation' subcommand to the config command.
// This is called from config_ai.go where the config command is defined.
func AddConfigValidationCommand(configCmd *cobra.Command) <span class="cov0" title="0">{
        flags := &amp;ConfigValidationFlags{}
        configCmd.AddCommand(newConfigValidationCmd(flags))
}</span>

// runConfigValidation executes the config validation command.
func runConfigValidation(ctx context.Context, w io.Writer, flags *ConfigValidationFlags) error <span class="cov0" title="0">{
        // Check cancellation at entry
        if err := ctxutil.Canceled(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">styles := newConfigValidationStyles()

        // Load and display existing configuration
        existingCfg, configPath, err := loadExistingConfig()
        if err != nil </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, styles.warning.Render("⚠ No existing configuration found. Run 'atlas init' first or create a new configuration."))
        }</span>
        <span class="cov0" title="0">if existingCfg != nil </span><span class="cov0" title="0">{
                displayCurrentValidationConfig(w, existingCfg, styles)
        }</span>

        // Handle non-interactive mode
        <span class="cov0" title="0">if flags.NoInteractive </span><span class="cov0" title="0">{
                return handleNonInteractiveMode(w, existingCfg, styles)
        }</span>

        // Collect and save new configuration
        <span class="cov0" title="0">valCfg, err := collectValidationConfigStandalone(ctx, w, existingCfg, styles)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Display validation warnings
        <span class="cov0" title="0">displayCommandWarnings(w, valCfg, styles)

        // Merge with existing config (or create new one)
        var finalCfg AtlasConfig
        if existingCfg != nil </span><span class="cov0" title="0">{
                finalCfg = *existingCfg
        }</span>
        <span class="cov0" title="0">finalCfg.Validation = valCfg.ToValidationConfig()

        // Save configuration using shared function
        if err = saveAtlasConfig(finalCfg, "Updated by atlas config validation"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save configuration: %w", err)
        }</span>

        // Display success
        <span class="cov0" title="0">_, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.success.Render("✓ Validation configuration updated successfully!"))
        _, _ = fmt.Fprintln(w, styles.dim.Render("Configuration saved to: "+configPath))

        return nil</span>
}

// handleNonInteractiveMode handles the --no-interactive flag case.
func handleNonInteractiveMode(w io.Writer, existingCfg *AtlasConfig, styles *configValidationStyles) error <span class="cov0" title="0">{
        if existingCfg == nil </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, styles.dim.Render("No validation configuration found. Run 'atlas config validation' interactively to configure."))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// collectValidationConfigStandalone collects validation configuration in standalone mode.
func collectValidationConfigStandalone(ctx context.Context, w io.Writer, existingCfg *AtlasConfig, styles *configValidationStyles) (*ValidationProviderConfig, error) <span class="cov0" title="0">{
        _, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.header.Render("Update Validation Configuration"))
        _, _ = fmt.Fprintln(w, styles.dim.Render(strings.Repeat("─", 35)))

        // Run tool detection to get default suggestions
        detector := &amp;defaultToolDetector{}
        toolResult, _ := detector.Detect(ctx)

        // Prepare config from existing or defaults
        valCfg := prepareValidationProviderConfig(existingCfg, toolResult)

        // Run the main form
        form := NewValidationConfigForm(valCfg)
        if err := form.Run(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation configuration failed: %w", err)
        }</span>

        <span class="cov0" title="0">return valCfg, nil</span>
}

// prepareValidationProviderConfig creates a ValidationProviderConfig from existing config or defaults.
func prepareValidationProviderConfig(existingCfg *AtlasConfig, toolResult *config.ToolDetectionResult) *ValidationProviderConfig <span class="cov0" title="0">{
        valCfg := &amp;ValidationProviderConfig{}
        if existingCfg != nil </span><span class="cov0" title="0">{
                valCfg.FormatCmds = strings.Join(existingCfg.Validation.Commands.Format, "\n")
                valCfg.LintCmds = strings.Join(existingCfg.Validation.Commands.Lint, "\n")
                valCfg.TestCmds = strings.Join(existingCfg.Validation.Commands.Test, "\n")
                valCfg.PreCommitCmds = strings.Join(existingCfg.Validation.Commands.PreCommit, "\n")
                valCfg.CustomPrePR = strings.Join(existingCfg.Validation.Commands.CustomPrePR, "\n")
        }</span> else<span class="cov0" title="0"> {
                PopulateValidationConfigDefaults(valCfg, toolResult)
        }</span>
        <span class="cov0" title="0">return valCfg</span>
}

// displayCommandWarnings shows validation warnings for configured commands.
func displayCommandWarnings(w io.Writer, valCfg *ValidationProviderConfig, styles *configValidationStyles) <span class="cov0" title="0">{
        warnings := ValidateAllConfigCommands(valCfg)
        if len(warnings) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">_, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.warning.Render("⚠ Command validation warnings:"))
        for category, categoryWarnings := range warnings </span><span class="cov0" title="0">{
                for _, warning := range categoryWarnings </span><span class="cov0" title="0">{
                        _, _ = fmt.Fprintf(w, "  %s: %s\n", styles.key.Render(category), styles.dim.Render(warning))
                }</span>
        }
        <span class="cov0" title="0">_, _ = fmt.Fprintln(w, styles.dim.Render("  (These commands may fail when run. You can continue anyway.)"))</span>
}

// configValidationStyles contains styling for the config validation command output.
type configValidationStyles struct {
        header  lipgloss.Style
        success lipgloss.Style
        warning lipgloss.Style
        dim     lipgloss.Style
        key     lipgloss.Style
        value   lipgloss.Style
}

// newConfigValidationStyles creates styles for config validation command output.
func newConfigValidationStyles() *configValidationStyles <span class="cov0" title="0">{
        return &amp;configValidationStyles{
                header: lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("#00D7FF")).
                        MarginBottom(1),
                success: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00FF87")).
                        Bold(true),
                warning: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFD700")),
                dim: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#666666")),
                key: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00D7FF")),
                value: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFFFFF")),
        }
}</span>

// displayCurrentValidationConfig shows the current validation configuration.
func displayCurrentValidationConfig(w io.Writer, cfg *AtlasConfig, styles *configValidationStyles) <span class="cov0" title="0">{
        _, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.header.Render("Current Validation Configuration"))
        _, _ = fmt.Fprintln(w, styles.dim.Render(strings.Repeat("─", 35)))

        displayCommandCategory(w, "Pre-commit Commands", cfg.Validation.Commands.PreCommit, styles)
        displayCommandCategory(w, "Format Commands", cfg.Validation.Commands.Format, styles)
        displayCommandCategory(w, "Lint Commands", cfg.Validation.Commands.Lint, styles)
        displayCommandCategory(w, "Test Commands", cfg.Validation.Commands.Test, styles)
        displayCommandCategory(w, "Custom Pre-PR Hooks", cfg.Validation.Commands.CustomPrePR, styles)
}</span>

// displayCommandCategory displays a category of commands.
func displayCommandCategory(w io.Writer, category string, cmds []string, styles *configValidationStyles) <span class="cov0" title="0">{
        _, _ = fmt.Fprintf(w, "%s:\n", styles.key.Render(category))
        if len(cmds) == 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "  %s\n", styles.dim.Render("(none configured)"))
        }</span> else<span class="cov0" title="0"> {
                for _, cmd := range cmds </span><span class="cov0" title="0">{
                        // Check if command exists
                        exists, _ := ValidateCommand(cmd)
                        statusIcon := "✓"
                        if !exists </span><span class="cov0" title="0">{
                                statusIcon = "⚠"
                        }</span>
                        <span class="cov0" title="0">_, _ = fmt.Fprintf(w, "  %s %s\n", statusIcon, styles.value.Render(cmd))</span>
                }
        }
}

// runToolDetection runs tool detection and returns the result.
// Used by both init and config commands.
func runToolDetection(ctx context.Context) (*config.ToolDetectionResult, error) <span class="cov0" title="0">{
        return config.NewToolDetector().Detect(ctx)
}</span>
</pre>

		<pre class="file" id="file17" style="display: none">// Package cli provides the command-line interface for atlas.
// This file provides execution context resolution for worktree support.
package cli

import (
        "context"
        "fmt"
        "os"
        "path/filepath"

        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/git"
)

// ExecutionContext holds resolved paths and config for command execution.
// It enables worktree-aware operation when the --worktree flag is used.
type ExecutionContext struct {
        // WorkDir is the directory to operate on (worktree path or current repo root).
        WorkDir string

        // MainRepoPath is the path to the main repository (for config inheritance).
        MainRepoPath string

        // IsWorktree indicates if WorkDir is a linked worktree.
        IsWorktree bool

        // Config is the merged configuration.
        Config *config.Config
}

// executionContextKey is the context key for ExecutionContext.
type executionContextKey struct{}

// ResolveExecutionContext resolves the execution context from the worktree flag.
// If worktreeName is specified, finds and validates the worktree.
// Otherwise, uses current directory.
//
// Config is loaded with worktree inheritance:
//   - global config (~/.atlas/config.yaml) - lowest precedence
//   - main repo config (&lt;main-repo&gt;/.atlas/config.yaml) - middle precedence
//   - worktree config (&lt;worktree&gt;/.atlas/config.yaml) - highest precedence
func ResolveExecutionContext(ctx context.Context, worktreeName string) (*ExecutionContext, error) <span class="cov0" title="0">{
        // Get current directory
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        // Detect repository info
        <span class="cov0" title="0">repoInfo, err := git.DetectRepo(ctx, cwd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not in a git repository: %w", err)
        }</span>

        <span class="cov0" title="0">ec := &amp;ExecutionContext{
                MainRepoPath: repoInfo.Root,
        }

        if worktreeName == "" </span><span class="cov0" title="0">{
                // No worktree specified - operate on current location
                ec.WorkDir = repoInfo.WorktreePath
                ec.IsWorktree = repoInfo.IsWorktree
        }</span> else<span class="cov0" title="0"> {
                // Find specified worktree
                var wt *git.WorktreeEntry
                wt, err = git.FindWorktreeByName(ctx, repoInfo.Root, worktreeName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("worktree '%s' not found: %w", worktreeName, err)
                }</span>
                <span class="cov0" title="0">ec.WorkDir = wt.Path
                ec.IsWorktree = true</span>
        }

        // Load merged config with worktree inheritance
        <span class="cov0" title="0">ec.Config, err = config.LoadWithWorktree(ctx, ec.MainRepoPath, ec.WorkDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">return ec, nil</span>
}

// WithExecutionContext returns a new context with the ExecutionContext attached.
func WithExecutionContext(ctx context.Context, ec *ExecutionContext) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, executionContextKey{}, ec)
}</span>

// ExecutionContextFrom retrieves the ExecutionContext from the context.
// Returns nil if no execution context was set or if type assertion fails.
// Callers must check for nil before calling methods on the result.
func ExecutionContextFrom(ctx context.Context) *ExecutionContext <span class="cov0" title="0">{
        if ctx == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">ec, ok := ctx.Value(executionContextKey{}).(*ExecutionContext)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return ec</span>
}

// ProjectConfigPath returns the path to the project config file for the execution context.
// Returns the worktree config path if in a worktree, otherwise the main repo config path.
func (ec *ExecutionContext) ProjectConfigPath() string <span class="cov0" title="0">{
        return filepath.Join(ec.WorkDir, ".atlas", "config.yaml")
}</span>

// MainRepoConfigPath returns the path to the main repository's config file.
func (ec *ExecutionContext) MainRepoConfigPath() string <span class="cov0" title="0">{
        return filepath.Join(ec.MainRepoPath, ".atlas", "config.yaml")
}</span>
</pre>

		<pre class="file" id="file18" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        stderrors "errors"
        "strings"

        "github.com/mrz1836/atlas/internal/errors"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// Exit codes for the CLI.
const (
        // ExitSuccess indicates successful execution.
        ExitSuccess = 0
        // ExitError indicates a general error.
        ExitError = 1
        // ExitInvalidInput indicates invalid user input.
        ExitInvalidInput = 2
)

// Output format constants.
const (
        // OutputText is the default human-readable output format.
        OutputText = "text"
        // OutputJSON is the machine-readable JSON output format.
        OutputJSON = "json"
)

// GlobalFlags holds flags available to all commands.
type GlobalFlags struct {
        // Output specifies the output format (text or json).
        Output string
        // Verbose enables debug-level logging.
        Verbose bool
        // Quiet suppresses non-essential output (warn level only).
        Quiet bool
}

// AddGlobalFlags adds global flags to a command.
// These flags are available to all subcommands via PersistentFlags.
func AddGlobalFlags(cmd *cobra.Command, flags *GlobalFlags) <span class="cov8" title="1">{
        cmd.PersistentFlags().StringVarP(&amp;flags.Output, "output", "o", OutputText, "output format (text|json)")
        cmd.PersistentFlags().BoolVarP(&amp;flags.Verbose, "verbose", "v", false, "enable verbose output")
        cmd.PersistentFlags().BoolVarP(&amp;flags.Quiet, "quiet", "q", false, "suppress non-essential output")
        cmd.MarkFlagsMutuallyExclusive("verbose", "quiet")
}</span>

// BindGlobalFlags binds global flags to Viper for configuration file and
// environment variable support. The ATLAS_ prefix is used for environment
// variables (e.g., ATLAS_OUTPUT, ATLAS_VERBOSE).
func BindGlobalFlags(v *viper.Viper, cmd *cobra.Command) error <span class="cov0" title="0">{
        // Use Root().PersistentFlags() to find flags defined on the root command,
        // even when called from a subcommand's PersistentPreRunE.
        rootFlags := cmd.Root().PersistentFlags()

        if err := v.BindPFlag("output", rootFlags.Lookup("output")); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := v.BindPFlag("verbose", rootFlags.Lookup("verbose")); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := v.BindPFlag("quiet", rootFlags.Lookup("quiet")); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Enable environment variable support with ATLAS_ prefix
        <span class="cov0" title="0">v.SetEnvPrefix("ATLAS")
        v.AutomaticEnv()

        return nil</span>
}

// ValidOutputFormats returns the list of valid output format values.
func ValidOutputFormats() []string <span class="cov0" title="0">{
        return []string{OutputText, OutputJSON}
}</span>

// IsValidOutputFormat checks if the given format is a valid output format.
func IsValidOutputFormat(format string) bool <span class="cov0" title="0">{
        for _, valid := range ValidOutputFormats() </span><span class="cov0" title="0">{
                if format == valid </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ExitCodeForError returns the appropriate exit code for the given error.
// Returns ExitSuccess (0) for nil errors, ExitInvalidInput (2) for user input
// errors (invalid flags, bad arguments), and ExitError (1) for all other errors.
func ExitCodeForError(err error) int <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return ExitSuccess
        }</span>

        // Check for our custom exit code 2 error wrapper
        <span class="cov0" title="0">if errors.IsExitCode2Error(err) </span><span class="cov0" title="0">{
                return ExitInvalidInput
        }</span>

        // Check for our custom invalid input error
        <span class="cov0" title="0">if stderrors.Is(err, errors.ErrInvalidOutputFormat) </span><span class="cov0" title="0">{
                return ExitInvalidInput
        }</span>

        // Check for Cobra flag parsing errors (mutually exclusive flags, unknown flags, etc.)
        <span class="cov0" title="0">errMsg := err.Error()
        if isInvalidInputError(errMsg) </span><span class="cov0" title="0">{
                return ExitInvalidInput
        }</span>

        <span class="cov0" title="0">return ExitError</span>
}

// isInvalidInputError checks if an error message indicates invalid user input.
// This catches Cobra's built-in flag validation errors.
func isInvalidInputError(errMsg string) bool <span class="cov0" title="0">{
        invalidInputPatterns := []string{
                "unknown flag",
                "unknown shorthand flag",
                "flag needs an argument",
                "invalid argument",
                "if any flags in the group",
                "required flag",
                "unknown command",
        }

        for _, pattern := range invalidInputPatterns </span><span class="cov0" title="0">{
                if strings.Contains(errMsg, pattern) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>

		<pre class="file" id="file19" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "fmt"
        "io"
        "os"

        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/spf13/cobra"
)

// AddFormatCommand adds the format command to the root command.
func AddFormatCommand(root *cobra.Command) <span class="cov0" title="0">{
        root.AddCommand(newFormatCmd())
}</span>

func newFormatCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "format",
                Short: "Run code formatters",
                Long: `Run configured code formatters on the current directory.

Uses 'magex format:fix' by default if no formatters are configured.

Examples:
  atlas format
  atlas format --output json
  atlas format --verbose`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runFormat(cmd.Context(), cmd, os.Stdout)
                }</span>,
        }

        <span class="cov0" title="0">return cmd</span>
}

func runFormat(ctx context.Context, cmd *cobra.Command, w io.Writer) error <span class="cov0" title="0">{
        // Check context cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">logger := Logger()
        outputFormat := cmd.Flag("output").Value.String()
        verbose := cmd.Flag("verbose").Value.String() == "true"
        tui.CheckNoColor()

        out := tui.NewOutput(w, outputFormat)

        // Load config
        cfg, err := config.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("failed to load config, using defaults")
                cfg = config.DefaultConfig()
        }</span>

        // Get format commands
        <span class="cov0" title="0">commands := cfg.Validation.Commands.Format
        if len(commands) == 0 </span><span class="cov0" title="0">{
                commands = []string{constants.DefaultFormatCommand}
        }</span>

        <span class="cov0" title="0">workDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get working directory: %w", err)
        }</span>

        <span class="cov0" title="0">opts := UtilityOptions{
                Verbose:      verbose,
                OutputFormat: outputFormat,
                Writer:       w,
        }

        return runCommandsWithOutput(ctx, commands, workDir, "Format", out, opts, logger)</span>
}
</pre>

		<pre class="file" id="file20" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/crypto/native"
        "github.com/mrz1836/atlas/internal/domain"
        atlaserrors "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/git"
        "github.com/mrz1836/atlas/internal/hook"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/workspace"
        "github.com/spf13/cobra"
)

// AddHookCommand adds the hook command group to the root command.
func AddHookCommand(root *cobra.Command) <span class="cov0" title="0">{
        hookCmd := &amp;cobra.Command{
                Use:   "hook",
                Short: "Manage task recovery hooks",
                Long: `Commands for viewing and managing task recovery hooks.

Hooks provide crash recovery context that allows tasks to resume after
interruptions without losing progress or repeating completed steps.

Examples:
  atlas hook status                    # View current hook state
  atlas hook checkpoints               # List all checkpoints
  atlas hook verify-receipt rcpt-001   # Verify a receipt signature
  atlas hook regenerate                # Regenerate HOOK.md from hook.json
  atlas hook export                    # Export hook state as JSON`,
        }

        hookCmd.AddCommand(newHookStatusCmd())
        hookCmd.AddCommand(newHookCheckpointsCmd())
        hookCmd.AddCommand(newHookInstallCmd())
        hookCmd.AddCommand(newHookVerifyReceiptCmd())
        hookCmd.AddCommand(newHookRegenerateCmd())
        hookCmd.AddCommand(newHookExportCmd())

        root.AddCommand(hookCmd)
}</span>

// newHookStatusCmd creates the hook status command.
func newHookStatusCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "status",
                Short: "Display the current hook state",
                Long: `Display the current hook state for the active workspace.

Shows state, step progress, checkpoints, and validation receipts.

Exit codes:
  0: Success
  1: No active hook found
  2: Hook in error state`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runHookStatus(cmd.Context(), cmd, os.Stdout)
                }</span>,
        }
}

// newHookCheckpointsCmd creates the hook checkpoints command.
func newHookCheckpointsCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "checkpoints",
                Short: "List all checkpoints for the current task",
                Long: `List all checkpoints for the current task.

Checkpoints are created automatically on git commits, validation passes,
step completions, and periodically during long-running steps.

Exit codes:
  0: Success (may have 0 checkpoints)
  1: No active hook found`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runHookCheckpoints(cmd.Context(), cmd, os.Stdout)
                }</span>,
        }
}

// newHookVerifyReceiptCmd creates the hook verify-receipt command.
func newHookVerifyReceiptCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "verify-receipt &lt;receipt-id&gt;",
                Short: "Verify a validation receipt signature",
                Long: `Verify the cryptographic signature of a validation receipt.

Validation receipts are signed proofs that validation actually ran.
This command verifies the signature using the master key.

Exit codes:
  0: Signature valid
  1: Receipt not found
  2: Signature invalid
  3: Key manager error (missing master key)`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runHookVerifyReceipt(cmd.Context(), cmd, os.Stdout, args[0])
                }</span>,
        }
}

// newHookRegenerateCmd creates the hook regenerate command.
func newHookRegenerateCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "regenerate",
                Short: "Regenerate HOOK.md from hook.json",
                Long: `Regenerate the HOOK.md recovery file from hook.json.

Use this if HOOK.md is corrupted or was manually edited incorrectly.
The source of truth is always hook.json.

Exit codes:
  0: Success
  1: No active hook found
  2: Failed to regenerate`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runHookRegenerate(cmd.Context(), cmd, os.Stdout)
                }</span>,
        }
}

// newHookExportCmd creates the hook export command.
func newHookExportCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "export",
                Short: "Export hook history for debugging",
                Long: `Export the full hook.json content to stdout.

Useful for debugging or preserving hook state for analysis.

Exit codes:
  0: Success
  1: No active hook found`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runHookExport(cmd.Context(), cmd, os.Stdout)
                }</span>,
        }
}

// newHookInstallCmd creates the hook install command.
func newHookInstallCmd() *cobra.Command <span class="cov0" title="0">{
        return &amp;cobra.Command{
                Use:   "install",
                Short: "Show instructions for installing git hooks",
                Long: `Print the git hook wrapper script and installation instructions.

This command does NOT modify your .git directory. It outputs a script that you
can manually add to your .git/hooks/post-commit (or post-push) file to enable
automatic checkpoints.

Example:
  atlas hook install &gt; .git/hooks/post-commit
  chmod +x .git/hooks/post-commit

Exit codes:
  0: Success
  1: No active hook found`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runHookInstall(cmd.Context(), cmd, os.Stdout)
                }</span>,
        }
}

// runHookStatus executes the hook status command.
func runHookStatus(ctx context.Context, cmd *cobra.Command, w io.Writer) error <span class="cov0" title="0">{
        outputFormat := cmd.Flag("output").Value.String()
        out := tui.NewOutput(w, outputFormat)

        h, err := getActiveHook(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return outputHookErrorJSON(w, "status", err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(h)
        }</span>

        <span class="cov0" title="0">displayHookStatus(out, h)
        return nil</span>
}

// runHookCheckpoints executes the hook checkpoints command.
func runHookCheckpoints(ctx context.Context, cmd *cobra.Command, w io.Writer) error <span class="cov0" title="0">{
        outputFormat := cmd.Flag("output").Value.String()
        out := tui.NewOutput(w, outputFormat)

        h, err := getActiveHook(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return outputHookErrorJSON(w, "checkpoints", err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(map[string]any{
                        "checkpoints": h.Checkpoints,
                        "count":       len(h.Checkpoints),
                })
        }</span>

        <span class="cov0" title="0">displayHookCheckpoints(out, h)
        return nil</span>
}

// runHookVerifyReceipt executes the hook verify-receipt command.
func runHookVerifyReceipt(ctx context.Context, cmd *cobra.Command, w io.Writer, receiptID string) error <span class="cov0" title="0">{
        outputFormat := cmd.Flag("output").Value.String()
        out := tui.NewOutput(w, outputFormat)

        h, err := getActiveHook(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return outputHookErrorJSON(w, "verify-receipt", err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Find the receipt
        <span class="cov0" title="0">var receipt *domain.ValidationReceipt
        for i := range h.Receipts </span><span class="cov0" title="0">{
                if h.Receipts[i].ReceiptID == receiptID </span><span class="cov0" title="0">{
                        receipt = &amp;h.Receipts[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if receipt == nil </span><span class="cov0" title="0">{
                notFoundErr := fmt.Errorf("%w: %s", atlaserrors.ErrReceiptNotFound, receiptID)
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return outputHookErrorJSON(w, "verify-receipt", notFoundErr.Error())
                }</span>
                <span class="cov0" title="0">return notFoundErr</span>
        }

        // Get atlas home directory for key file
        <span class="cov0" title="0">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get home directory: %w", err)
        }</span>
        <span class="cov0" title="0">keyDir := filepath.Join(homeDir, ".atlas", "keys")

        // Load key manager
        keyMgr := native.NewKeyManager(keyDir)
        if loadErr := keyMgr.Load(ctx); loadErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load key manager: %w", loadErr)
        }</span>

        // Create receipt signer and verify
        <span class="cov0" title="0">signer, signerErr := hook.NewNativeReceiptSigner(keyMgr)
        if signerErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create signer: %w", signerErr)
        }</span>
        <span class="cov0" title="0">verifyErr := signer.VerifyReceipt(ctx, receipt)

        result := map[string]any{
                "receipt_id": receipt.ReceiptID,
                "step_name":  receipt.StepName,
                "command":    receipt.Command,
                "exit_code":  receipt.ExitCode,
                "duration":   receipt.Duration,
                "valid":      verifyErr == nil,
        }

        if verifyErr != nil </span><span class="cov0" title="0">{
                result["error"] = verifyErr.Error()
        }</span>

        <span class="cov0" title="0">if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(result)
        }</span>

        <span class="cov0" title="0">displayReceiptVerification(out, receipt, verifyErr)
        return nil</span>
}

// runHookRegenerate executes the hook regenerate command.
func runHookRegenerate(ctx context.Context, cmd *cobra.Command, w io.Writer) error <span class="cov0" title="0">{
        outputFormat := cmd.Flag("output").Value.String()
        out := tui.NewOutput(w, outputFormat)

        h, err := getActiveHook(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return outputHookErrorJSON(w, "regenerate", err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Generate HOOK.md content
        <span class="cov0" title="0">generator := hook.NewMarkdownGenerator()
        content, err := generator.Generate(h)
        if err != nil </span><span class="cov0" title="0">{
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return outputHookErrorJSON(w, "regenerate", fmt.Sprintf("failed to generate: %v", err))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to generate HOOK.md: %w", err)</span>
        }

        // Get the hook file path
        <span class="cov0" title="0">hookPath, err := getActiveHookPath(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return outputHookErrorJSON(w, "regenerate", err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Write HOOK.md alongside hook.json
        <span class="cov0" title="0">mdPath := strings.TrimSuffix(hookPath, "hook.json") + "HOOK.md"
        if err := os.WriteFile(mdPath, content, 0o600); err != nil </span><span class="cov0" title="0">{
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return outputHookErrorJSON(w, "regenerate", fmt.Sprintf("failed to write: %v", err))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to write HOOK.md: %w", err)</span>
        }

        <span class="cov0" title="0">if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(map[string]any{
                        "success": true,
                        "path":    mdPath,
                })
        }</span>

        <span class="cov0" title="0">out.Success(fmt.Sprintf("Regenerated HOOK.md at %s", mdPath))
        return nil</span>
}

// runHookExport executes the hook export command.
func runHookExport(ctx context.Context, cmd *cobra.Command, w io.Writer) error <span class="cov0" title="0">{
        outputFormat := cmd.Flag("output").Value.String()

        h, err := getActiveHook(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return outputHookErrorJSON(w, "export", err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Always export as JSON (indented)
        <span class="cov0" title="0">encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(h)</span>
}

// runHookInstall executes the hook install command.
func runHookInstall(ctx context.Context, cmd *cobra.Command, w io.Writer) error <span class="cov0" title="0">{
        outputFormat := cmd.Flag("output").Value.String()
        out := tui.NewOutput(w, outputFormat)

        h, err := getActiveHook(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return outputHookErrorJSON(w, "install", err.Error())
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Generate the script content
        <span class="cov0" title="0">script := git.GenerateHookScript(git.HookPostCommit, h.TaskID, h.WorkspaceID)

        if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(map[string]string{
                        "script":       script,
                        "instructions": "Copy the script to .git/hooks/post-commit and make it executable.",
                })
        }</span>

        // Print script and instructions
        <span class="cov0" title="0">out.Info("# ------------------------------------------------------------------")
        out.Info("# Add the following to your .git/hooks/post-commit file:")
        out.Info("# ------------------------------------------------------------------")
        out.Info("")
        if _, err := fmt.Fprint(w, script); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to print script: %w", err)
        }</span>
        <span class="cov0" title="0">out.Info("")
        out.Info("# ------------------------------------------------------------------")
        out.Info("# Then run: chmod +x .git/hooks/post-commit")
        out.Info("# ------------------------------------------------------------------")

        return nil</span>
}

// getActiveHook finds and returns the active hook for the current workspace.
func getActiveHook(ctx context.Context) (*domain.Hook, error) <span class="cov0" title="0">{
        hookPath, err := getActiveHookPath(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read and parse the hook file
        <span class="cov0" title="0">data, err := os.ReadFile(hookPath) //nolint:gosec // hookPath is constructed from validated workspace paths
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read hook file: %w", err)
        }</span>

        <span class="cov0" title="0">var h domain.Hook
        if err := json.Unmarshal(data, &amp;h); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %w", hook.ErrInvalidHook, err)
        }</span>

        <span class="cov0" title="0">return &amp;h, nil</span>
}

// getActiveHookPath finds the path to the active hook.json file.
func getActiveHookPath(ctx context.Context) (string, error) <span class="cov0" title="0">{
        // Get base path
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get home directory: %w", err)
        }</span>
        <span class="cov0" title="0">baseDir := filepath.Join(homeDir, constants.AtlasHome)

        // Get workspace store
        wsStore, err := workspace.NewFileStore("")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create workspace store: %w", err)
        }</span>

        // Find active workspaces
        <span class="cov0" title="0">workspaces, err := wsStore.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to list workspaces: %w", err)
        }</span>

        // Look for hook.json in active workspaces
        <span class="cov0" title="0">for _, ws := range workspaces </span><span class="cov0" title="0">{
                if ws.Status == "closed" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check for hook.json in this workspace's tasks
                <span class="cov0" title="0">tasksDir := filepath.Join(baseDir, "workspaces", ws.Name, "tasks")
                entries, err := os.ReadDir(tasksDir)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                        if !entry.IsDir() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">hookPath := filepath.Join(tasksDir, entry.Name(), "hook.json")
                        if _, statErr := os.Stat(hookPath); statErr == nil </span><span class="cov0" title="0">{
                                return hookPath, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("%w: no active hook found", atlaserrors.ErrHookNotFound)</span>
}

// displayHookStatus displays the hook status in text format.
func displayHookStatus(out tui.Output, h *domain.Hook) <span class="cov0" title="0">{
        out.Info(fmt.Sprintf("Hook State: %s", h.State))
        out.Info(fmt.Sprintf("Task: %s (%s)", h.TaskID, h.WorkspaceID))

        if h.CurrentStep != nil </span><span class="cov0" title="0">{
                out.Info(fmt.Sprintf("Step: %s (%d), Attempt %d/%d",
                        h.CurrentStep.StepName,
                        h.CurrentStep.StepIndex+1,
                        h.CurrentStep.Attempt,
                        h.CurrentStep.MaxAttempts))
        }</span>

        <span class="cov0" title="0">out.Info(fmt.Sprintf("Last Updated: %s", formatRelativeTime(h.UpdatedAt)))

        if len(h.Checkpoints) &gt; 0 </span><span class="cov0" title="0">{
                latest := h.Checkpoints[len(h.Checkpoints)-1]
                out.Info(fmt.Sprintf("Last Checkpoint: %s (%s, %s)",
                        latest.CheckpointID,
                        latest.Trigger,
                        formatRelativeTime(latest.CreatedAt)))
        }</span>

        <span class="cov0" title="0">validCount := 0
        for _, r := range h.Receipts </span><span class="cov0" title="0">{
                if r.Signature != "" </span><span class="cov0" title="0">{
                        validCount++
                }</span>
        }
        <span class="cov0" title="0">out.Info(fmt.Sprintf("Receipts: %d (all valid)", validCount))</span>
}

// displayHookCheckpoints displays checkpoints in text format.
func displayHookCheckpoints(out tui.Output, h *domain.Hook) <span class="cov0" title="0">{
        if len(h.Checkpoints) == 0 </span><span class="cov0" title="0">{
                out.Info("No checkpoints recorded.")
                return
        }</span>

        <span class="cov0" title="0">out.Info(fmt.Sprintf("Checkpoints for %s:", h.TaskID))
        out.Info("")
        out.Info("| Time       | Trigger       | Description                      |")
        out.Info("|------------|---------------|----------------------------------|")

        for _, cp := range h.Checkpoints </span><span class="cov0" title="0">{
                desc := cp.Description
                if len(desc) &gt; 32 </span><span class="cov0" title="0">{
                        desc = desc[:29] + "..."
                }</span>
                <span class="cov0" title="0">out.Info(fmt.Sprintf("| %-10s | %-13s | %-32s |",
                        cp.CreatedAt.Format("15:04:05"),
                        cp.Trigger,
                        desc))</span>
        }
}

// displayReceiptVerification displays receipt verification result.
func displayReceiptVerification(out tui.Output, receipt *domain.ValidationReceipt, verifyErr error) <span class="cov0" title="0">{
        out.Info(fmt.Sprintf("Receipt: %s", receipt.ReceiptID))
        out.Info(fmt.Sprintf("Step: %s", receipt.StepName))
        out.Info(fmt.Sprintf("Command: %s", receipt.Command))
        out.Info(fmt.Sprintf("Exit Code: %d", receipt.ExitCode))
        out.Info(fmt.Sprintf("Duration: %s", receipt.Duration))
        // KeyPath is available if signed
        if receipt.KeyPath != "" </span><span class="cov0" title="0">{
                out.Info(fmt.Sprintf("Key Path: %s", receipt.KeyPath))
        }</span>

        <span class="cov0" title="0">if verifyErr == nil </span><span class="cov0" title="0">{
                out.Success("Signature: VALID")
        }</span> else<span class="cov0" title="0"> {
                out.Warning(fmt.Sprintf("Signature: INVALID - %v", verifyErr))
        }</span>
}

// formatRelativeTime formats a time as relative (e.g., "2 minutes ago").
func formatRelativeTime(t time.Time) string <span class="cov0" title="0">{
        d := time.Since(t)
        if d &lt; time.Minute </span><span class="cov0" title="0">{
                return "just now"
        }</span>
        <span class="cov0" title="0">if d &lt; time.Hour </span><span class="cov0" title="0">{
                m := int(d.Minutes())
                if m == 1 </span><span class="cov0" title="0">{
                        return "1 minute ago"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d minutes ago", m)</span>
        }
        <span class="cov0" title="0">if d &lt; 24*time.Hour </span><span class="cov0" title="0">{
                h := int(d.Hours())
                if h == 1 </span><span class="cov0" title="0">{
                        return "1 hour ago"
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%d hours ago", h)</span>
        }
        <span class="cov0" title="0">days := int(d.Hours() / 24)
        if days == 1 </span><span class="cov0" title="0">{
                return "1 day ago"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d days ago", days)</span>
}

// outputHookErrorJSON outputs an error result as JSON for hook commands.
func outputHookErrorJSON(w io.Writer, command, errMsg string) error <span class="cov0" title="0">{
        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(map[string]any{
                "success": false,
                "command": command,
                "error":   errMsg,
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return atlaserrors.ErrJSONErrorOutput</span>
}
</pre>

		<pre class="file" id="file21" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "errors"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "github.com/charmbracelet/huh"
        "github.com/charmbracelet/lipgloss"
        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        atlaserrors "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/git"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

// InitFlags holds flags specific to the init command.
type InitFlags struct {
        // NoInteractive skips all prompts and uses default values.
        NoInteractive bool
        // Global forces configuration to be saved to global config only.
        Global bool
        // Project forces configuration to be saved to project config only.
        Project bool
}

// AtlasConfig represents the user's ATLAS configuration.
// This is the structure that gets written to ~/.atlas/config.yaml.
type AtlasConfig struct {
        AI            AIConfig           `yaml:"ai"`
        Validation    ValidationConfig   `yaml:"validation"`
        Notifications NotificationConfig `yaml:"notifications"`
        Hooks         HookConfig         `yaml:"hooks"`
}

// AIConfig holds AI provider configuration.
// YAML field names match internal/config/config.go AIConfig struct.
type AIConfig struct {
        // Model is the default Claude model to use (sonnet|opus|haiku).
        Model string `yaml:"model"`
        // APIKeyEnvVar is the name of the environment variable containing the API key.
        APIKeyEnvVar string `yaml:"api_key_env_var"`
        // Timeout is the default timeout for AI operations.
        Timeout string `yaml:"timeout"`
        // MaxTurns is the maximum number of turns per AI step.
        MaxTurns int `yaml:"max_turns"`
}

// ValidationConfig holds validation command configuration.
type ValidationConfig struct {
        Commands          ValidationCommands                `yaml:"commands"`
        TemplateOverrides map[string]TemplateOverrideConfig `yaml:"template_overrides,omitempty"`
}

// ValidationCommands holds the validation commands by category.
type ValidationCommands struct {
        Format      []string `yaml:"format"`
        Lint        []string `yaml:"lint"`
        Test        []string `yaml:"test"`
        PreCommit   []string `yaml:"pre_commit"`
        CustomPrePR []string `yaml:"custom_pre_pr,omitempty"`
}

// TemplateOverrideConfig holds per-template validation overrides.
type TemplateOverrideConfig struct {
        // SkipTest indicates whether to skip tests for this template type.
        SkipTest bool `yaml:"skip_test"`
        // SkipLint indicates whether to skip linting for this template type.
        SkipLint bool `yaml:"skip_lint,omitempty"`
}

// NotificationConfig holds notification preferences.
// YAML field names match internal/config/config.go NotificationsConfig struct.
type NotificationConfig struct {
        // BellEnabled enables terminal bell notifications.
        // Uses "bell" YAML tag to match internal/config/config.go for config.Load() compatibility.
        BellEnabled bool `yaml:"bell"`
        // Events is the list of events to notify on.
        Events []string `yaml:"events"`
}

// initStyles contains styling for the init command output.
// Using a struct avoids global variables while keeping styles reusable.
type initStyles struct {
        header    lipgloss.Style
        installed lipgloss.Style
        missing   lipgloss.Style
        outdated  lipgloss.Style
        success   lipgloss.Style
        err       lipgloss.Style
        info      lipgloss.Style
        dim       lipgloss.Style
}

// newInitStyles creates the styles for init command output.
func newInitStyles() *initStyles <span class="cov0" title="0">{
        return &amp;initStyles{
                header: lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("#00D7FF")).
                        MarginBottom(1),
                installed: lipgloss.NewStyle().Foreground(lipgloss.Color("#00FF87")),
                missing:   lipgloss.NewStyle().Foreground(lipgloss.Color("#FF5F5F")),
                outdated:  lipgloss.NewStyle().Foreground(lipgloss.Color("#FFD700")),
                success: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00FF87")).
                        Bold(true),
                err: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FF5F5F")).
                        Bold(true),
                info: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00D7FF")),
                dim: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#666666")),
        }
}</span>

// Default configuration values for non-interactive mode.
const (
        defaultModel     = "sonnet"
        defaultTimeout   = "30m"
        defaultMaxTurns  = 10
        defaultBell      = true
        defaultAPIKeyEnv = "ANTHROPIC_API_KEY" //nolint:gosec // Not a credential, just env var name
)

// Separator widths for consistent UI formatting.
const (
        separatorWidthTable  = 55 // Tool table header
        separatorWidthWide   = 35 // Section headers (validation)
        separatorWidthMedium = 30 // Section headers (AI)
        separatorWidthNarrow = 25 // Section headers (notifications)
)

// ToolDetector is an interface for detecting tools.
// This allows for mocking in tests.
type ToolDetector interface {
        Detect(ctx context.Context) (*config.ToolDetectionResult, error)
}

// defaultToolDetector wraps config.NewToolDetector for production use.
type defaultToolDetector struct{}

// Detect delegates to config.NewToolDetector for tool detection.
func (d *defaultToolDetector) Detect(ctx context.Context) (*config.ToolDetectionResult, error) <span class="cov0" title="0">{
        return config.NewToolDetector().Detect(ctx)
}</span>

// Notification event types are defined in notification_config.go as exported constants:
// NotifyEventAwaitingApproval, NotifyEventValidationFailed, NotifyEventCIFailed, NotifyEventGitHubFailed

// newInitCmd creates the init command for setting up ATLAS.
func newInitCmd(flags *InitFlags) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "init",
                Short: "Initialize ATLAS configuration",
                Long: `Initialize ATLAS with a guided setup wizard.

The init command walks you through configuring ATLAS for your environment,
including:
  - Tool detection and verification
  - AI provider settings (model, API key, timeouts)
  - Validation commands (format, lint, test)
  - Notification preferences

Configuration can be saved to:
  - Global: ~/.atlas/config.yaml (applies to all projects)
  - Project: .atlas/config.yaml (project-specific overrides)

In a git repository, you'll be asked whether to create project-specific config.
Project config is recommended for shared projects with team settings.

Use --no-interactive for automated setups with sensible defaults.
Use --global to save only to global config (skip project config prompt).
Use --project to save only to project config (requires being in a project directory).`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        err := runInit(cmd.Context(), cmd.OutOrStdout(), flags)
                        if errors.Is(err, atlaserrors.ErrMissingRequiredTools) </span><span class="cov0" title="0">{
                                // Exit with error code but don't print error again (already displayed)
                                os.Exit(ExitError)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                },
                SilenceUsage: true,
        }

        // Add init-specific flags
        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;flags.NoInteractive, "no-interactive", false, "skip all prompts and use default values")
        cmd.Flags().BoolVar(&amp;flags.Global, "global", false, "save to global config only (~/.atlas/config.yaml)")
        cmd.Flags().BoolVar(&amp;flags.Project, "project", false, "save to project config only (.atlas/config.yaml)")
        cmd.MarkFlagsMutuallyExclusive("global", "project")

        return cmd</span>
}

// AddInitCommand adds the init command to the root command.
func AddInitCommand(rootCmd *cobra.Command) <span class="cov0" title="0">{
        flags := &amp;InitFlags{}
        rootCmd.AddCommand(newInitCmd(flags))
}</span>

// runInit executes the init wizard using the default tool detector.
func runInit(ctx context.Context, w io.Writer, flags *InitFlags) error <span class="cov0" title="0">{
        return runInitWithDetector(ctx, w, flags, &amp;defaultToolDetector{})
}</span>

// runInitWithDetector executes the init wizard with a custom tool detector.
// This allows for mocking in tests.
func runInitWithDetector(ctx context.Context, w io.Writer, flags *InitFlags, detector ToolDetector) error <span class="cov0" title="0">{
        // Check cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">styles := newInitStyles()

        // Validate --project flag requires being in a git repo
        if flags.Project &amp;&amp; !isInGitRepo(ctx) </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, styles.err.Render("Error: --project flag requires being in a git repository."))
                _, _ = fmt.Fprintln(w, styles.dim.Render("  Project config is stored at .atlas/config.yaml relative to the git root."))
                _, _ = fmt.Fprintln(w, styles.dim.Render("  Use --global to save to ~/.atlas/config.yaml instead."))
                return atlaserrors.ErrNotInProjectDir
        }</span>

        // Display ATLAS header
        <span class="cov0" title="0">displayHeader(w, styles)

        // Step 1: Run tool detection
        _, _ = fmt.Fprintln(w, styles.info.Render("Detecting tools..."))
        _, _ = fmt.Fprintln(w)

        result, err := detector.Detect(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to detect tools: %w", err)
        }</span>

        // Display tool status table
        <span class="cov0" title="0">displayToolTable(w, result, styles)

        // Check for missing required tools
        if result.HasMissingRequired </span><span class="cov0" title="0">{
                missing := result.MissingRequiredTools()
                _, _ = fmt.Fprintln(w)
                _, _ = fmt.Fprintln(w, styles.err.Render("Required tools are missing or outdated:"))
                _, _ = fmt.Fprintln(w)
                _, _ = fmt.Fprint(w, config.FormatMissingToolsError(missing))
                _, _ = fmt.Fprintln(w)
                _, _ = fmt.Fprintln(w, styles.err.Render("Please install the required tools and run 'atlas init' again."))
                return atlaserrors.ErrMissingRequiredTools
        }</span>

        // Step 2: Handle managed tools
        <span class="cov0" title="0">managedNeedAction := getManagedToolsNeedingAction(result)
        installManaged := false

        if len(managedNeedAction) &gt; 0 &amp;&amp; !flags.NoInteractive </span><span class="cov0" title="0">{
                var promptErr error
                installManaged, promptErr = promptInstallManagedTools(w, managedNeedAction, styles)
                if promptErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to prompt for managed tools: %w", promptErr)
                }</span>
        }

        <span class="cov0" title="0">if installManaged </span><span class="cov0" title="0">{
                installManagedTools(ctx, w, managedNeedAction, styles)
        }</span>

        // Build configuration
        <span class="cov0" title="0">var cfg AtlasConfig

        if flags.NoInteractive </span><span class="cov0" title="0">{
                // Use defaults for non-interactive mode
                cfg = buildDefaultConfig(result)
        }</span> else<span class="cov0" title="0"> {
                // Interactive wizard
                var wizardErr error
                cfg, wizardErr = runInteractiveWizard(ctx, w, result, styles)
                if wizardErr != nil </span><span class="cov0" title="0">{
                        return wizardErr
                }</span>
        }

        // Determine and execute config save strategy
        <span class="cov0" title="0">saveResult, err := determineAndSaveConfig(ctx, w, flags, cfg, styles)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Display success message with config paths
        <span class="cov0" title="0">displaySuccessMessageWithPaths(w, flags.NoInteractive, saveResult.projectConfigCreated, saveResult.configPaths, styles)

        return nil</span>
}

// displayHeader shows the ATLAS banner.
func displayHeader(w io.Writer, styles *initStyles) <span class="cov0" title="0">{
        header := `
    ╔═══════════════════════════════════════╗
    ║             A T L A S                 ║
    ║     Autonomous Task &amp; Lifecycle       ║
    ║      Automation System                ║
    ╚═══════════════════════════════════════╝`

        _, _ = fmt.Fprintln(w, styles.header.Render(header))
        _, _ = fmt.Fprintln(w)
}</span>

// displayToolTable displays a formatted table of tool status.
func displayToolTable(w io.Writer, result *config.ToolDetectionResult, styles *initStyles) <span class="cov0" title="0">{
        // Table header
        _, _ = fmt.Fprintln(w, styles.dim.Render("TOOL            REQUIRED   VERSION        STATUS"))
        _, _ = fmt.Fprintln(w, styles.dim.Render(strings.Repeat("─", separatorWidthTable)))

        // Sort tools: required first, then managed
        tools := make([]config.Tool, len(result.Tools))
        copy(tools, result.Tools)

        // Simple sort: required tools first
        sortedTools := make([]config.Tool, 0, len(tools))
        for _, t := range tools </span><span class="cov0" title="0">{
                if t.Required </span><span class="cov0" title="0">{
                        sortedTools = append(sortedTools, t)
                }</span>
        }
        <span class="cov0" title="0">for _, t := range tools </span><span class="cov0" title="0">{
                if !t.Required </span><span class="cov0" title="0">{
                        sortedTools = append(sortedTools, t)
                }</span>
        }

        <span class="cov0" title="0">for _, tool := range sortedTools </span><span class="cov0" title="0">{
                requiredStr := "managed"
                if tool.Required </span><span class="cov0" title="0">{
                        requiredStr = "yes"
                }</span>

                <span class="cov0" title="0">version := tool.CurrentVersion
                if version == "" </span><span class="cov0" title="0">{
                        version = "-"
                }</span>
                <span class="cov0" title="0">if len(version) &gt; 12 </span><span class="cov0" title="0">{
                        version = version[:12]
                }</span>

                <span class="cov0" title="0">statusStr := formatToolStatus(tool, styles)

                // Pad fields for alignment
                name := fmt.Sprintf("%-15s", tool.Name)
                req := fmt.Sprintf("%-10s", requiredStr)
                ver := fmt.Sprintf("%-14s", version)

                _, _ = fmt.Fprintf(w, "%s %s %s %s\n", name, req, ver, statusStr)</span>
        }
}

// formatToolStatus returns a styled status string for a tool.
func formatToolStatus(tool config.Tool, styles *initStyles) string <span class="cov0" title="0">{
        switch tool.Status </span>{
        case config.ToolStatusInstalled:<span class="cov0" title="0">
                return styles.installed.Render("✓ installed")</span>
        case config.ToolStatusMissing:<span class="cov0" title="0">
                return styles.missing.Render("✗ missing")</span>
        case config.ToolStatusOutdated:<span class="cov0" title="0">
                return styles.outdated.Render("⚠ outdated")</span>
        default:<span class="cov0" title="0">
                return styles.dim.Render("? unknown")</span>
        }
}

// getManagedToolsNeedingAction returns managed tools that are missing or outdated.
func getManagedToolsNeedingAction(result *config.ToolDetectionResult) []config.Tool <span class="cov0" title="0">{
        var needAction []config.Tool
        for _, tool := range result.Tools </span><span class="cov0" title="0">{
                if tool.Managed &amp;&amp; (tool.Status == config.ToolStatusMissing || tool.Status == config.ToolStatusOutdated) </span><span class="cov0" title="0">{
                        needAction = append(needAction, tool)
                }</span>
        }
        <span class="cov0" title="0">return needAction</span>
}

// promptInstallManagedTools prompts the user to install managed tools.
func promptInstallManagedTools(w io.Writer, tools []config.Tool, styles *initStyles) (bool, error) <span class="cov0" title="0">{
        _, _ = fmt.Fprintln(w)

        names := make([]string, 0, len(tools))
        for _, t := range tools </span><span class="cov0" title="0">{
                names = append(names, t.Name)
        }</span>

        <span class="cov0" title="0">_, _ = fmt.Fprintln(w, styles.info.Render("Optional tools available for installation: "+strings.Join(names, ", ")))

        var install bool
        form := huh.NewForm(
                huh.NewGroup(
                        huh.NewConfirm().
                                Title("Install/upgrade ATLAS-managed tools?").
                                Affirmative("Yes").
                                Negative("No").
                                Value(&amp;install),
                ),
        ).WithTheme(tui.AtlasTheme())

        if err := form.Run(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return install, nil</span>
}

// installManagedTools installs the specified managed tools.
func installManagedTools(ctx context.Context, w io.Writer, tools []config.Tool, styles *initStyles) <span class="cov0" title="0">{
        for _, tool := range tools </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, styles.info.Render("Installing "+tool.Name+"..."))

                var cmd *exec.Cmd
                switch tool.Name </span>{
                case constants.ToolMageX:<span class="cov0" title="0">
                        cmd = exec.CommandContext(ctx, "go", "install", constants.InstallPathMageX)</span> //nolint:gosec // Install path is from constants, not user input
                case constants.ToolGoPreCommit:<span class="cov0" title="0">
                        cmd = exec.CommandContext(ctx, "go", "install", constants.InstallPathGoPreCommit)</span> //nolint:gosec // Install path is from constants, not user input
                case constants.ToolSpeckit:<span class="cov0" title="0">
                        // Speckit may have a different install method
                        _, _ = fmt.Fprintln(w, styles.dim.Render("  Skipping speckit (manual installation required)"))
                        continue</span>
                default:<span class="cov0" title="0">
                        continue</span>
                }

                <span class="cov0" title="0">output, err := cmd.CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        _, _ = fmt.Fprintln(w, styles.err.Render("  Failed to install "+tool.Name+": "+err.Error()))
                        if len(output) &gt; 0 </span><span class="cov0" title="0">{
                                _, _ = fmt.Fprintln(w, styles.dim.Render(string(output)))
                        }</span>
                } else<span class="cov0" title="0"> {
                        _, _ = fmt.Fprintln(w, styles.success.Render("  ✓ Installed "+tool.Name))
                }</span>
        }
}

// runInteractiveWizard runs the interactive configuration wizard.
func runInteractiveWizard(ctx context.Context, w io.Writer, toolResult *config.ToolDetectionResult, styles *initStyles) (AtlasConfig, error) <span class="cov0" title="0">{
        // Check cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return AtlasConfig{}, ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">var cfg AtlasConfig

        // AI Provider Configuration using reusable functions from ai_config.go
        _, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.info.Render("AI Provider Configuration"))
        _, _ = fmt.Fprintln(w, styles.dim.Render(strings.Repeat("─", separatorWidthMedium)))

        aiCfg := &amp;AIProviderConfig{}
        if err := CollectAIConfigInteractive(ctx, aiCfg); err != nil </span><span class="cov0" title="0">{
                return AtlasConfig{}, err
        }</span>

        // Check if API key environment variable is set and warn if not
        <span class="cov0" title="0">if exists, warning := CheckAPIKeyExists(aiCfg.APIKeyEnvVar); !exists </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w)
                _, _ = fmt.Fprintln(w, styles.outdated.Render("⚠ "+warning))
                _, _ = fmt.Fprintln(w, styles.dim.Render("  Make sure to set it before running ATLAS tasks"))
        }</span>

        <span class="cov0" title="0">cfg.AI = AIConfig{
                Model:        aiCfg.Model,
                APIKeyEnvVar: aiCfg.APIKeyEnvVar,
                Timeout:      aiCfg.Timeout,
                MaxTurns:     aiCfg.MaxTurns,
        }

        // Validation Commands Configuration using reusable functions from validation_config.go
        _, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.info.Render("Validation Commands Configuration"))
        _, _ = fmt.Fprintln(w, styles.dim.Render(strings.Repeat("─", separatorWidthWide)))

        valCfg := &amp;ValidationProviderConfig{}
        if err := CollectValidationConfigInteractive(ctx, valCfg, toolResult); err != nil </span><span class="cov0" title="0">{
                return AtlasConfig{}, fmt.Errorf("validation configuration failed: %w", err)
        }</span>

        // Validate commands and show warnings (AC5: command validation)
        <span class="cov0" title="0">warnings := ValidateAllConfigCommands(valCfg)
        if len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w)
                _, _ = fmt.Fprintln(w, styles.outdated.Render("⚠ Command validation warnings:"))
                for category, categoryWarnings := range warnings </span><span class="cov0" title="0">{
                        for _, warning := range categoryWarnings </span><span class="cov0" title="0">{
                                _, _ = fmt.Fprintf(w, "  %s: %s\n", styles.info.Render(category), styles.dim.Render(warning))
                        }</span>
                }
                <span class="cov0" title="0">_, _ = fmt.Fprintln(w, styles.dim.Render("  (These commands may fail when run. You can continue anyway.)"))</span>
        }

        <span class="cov0" title="0">cfg.Validation = valCfg.ToValidationConfig()

        // Notification Preferences using reusable functions from notification_config.go
        _, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.info.Render("Notification Preferences"))
        _, _ = fmt.Fprintln(w, styles.dim.Render(strings.Repeat("─", separatorWidthNarrow)))

        notifyCfg := &amp;NotificationProviderConfig{
                BellEnabled: defaultBell,
                Events:      AllNotificationEvents(),
        }
        if err := CollectNotificationConfigInteractive(ctx, notifyCfg); err != nil </span><span class="cov0" title="0">{
                return AtlasConfig{}, fmt.Errorf("notification configuration failed: %w", err)
        }</span>

        <span class="cov0" title="0">cfg.Notifications = notifyCfg.ToNotificationConfig()

        return cfg, nil</span>
}

// buildDefaultConfig creates a configuration with sensible defaults.
func buildDefaultConfig(toolResult *config.ToolDetectionResult) AtlasConfig <span class="cov0" title="0">{
        // Use reusable SuggestValidationDefaults from validation_config.go
        defaultCommands := SuggestValidationDefaults(toolResult)

        return AtlasConfig{
                AI: AIConfig{
                        Model:        defaultModel,
                        APIKeyEnvVar: defaultAPIKeyEnv,
                        Timeout:      defaultTimeout,
                        MaxTurns:     defaultMaxTurns,
                },
                Validation: ValidationConfig{
                        Commands: defaultCommands,
                },
                // Use reusable DefaultNotificationConfig from notification_config.go
                Notifications: DefaultNotificationConfig(),
                Hooks: HookConfig{
                        Crypto: CryptoConfig{
                                Provider: "native",
                        },
                },
        }
}</span>

// HookConfig holds hook system configuration.
type HookConfig struct {
        Crypto CryptoConfig `yaml:"crypto"`
}

// CryptoConfig holds cryptographic configuration.
type CryptoConfig struct {
        Provider string `yaml:"provider"`
}

// saveConfig writes the configuration to ~/.atlas/config.yaml.
// If a config file already exists, it creates a backup before overwriting.
func saveConfig(cfg AtlasConfig) error <span class="cov0" title="0">{
        return saveAtlasConfig(cfg, "Generated by atlas init")
}</span>

// saveAtlasConfig writes the configuration to ~/.atlas/config.yaml with a custom header source.
// This is the shared implementation used by saveConfig and saveConfigAI.
// If a config file already exists, it creates a backup before overwriting.
func saveAtlasConfig(cfg AtlasConfig, headerSource string) error <span class="cov0" title="0">{
        // Get home directory
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        // Create ~/.atlas directory with restrictive permissions
        <span class="cov0" title="0">atlasDir := filepath.Join(home, constants.AtlasHome)
        if err = os.MkdirAll(atlasDir, 0o700); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        <span class="cov0" title="0">configPath := filepath.Join(atlasDir, constants.GlobalConfigName)

        // Check if config file already exists and create backup
        if _, statErr := os.Stat(configPath); statErr == nil </span><span class="cov0" title="0">{
                backupPath := configPath + ".backup"
                if copyErr := copyFile(configPath, backupPath); copyErr != nil </span><span class="cov0" title="0">{
                        // Log warning but continue - backup is best effort
                        logger := Logger()
                        logger.Warn().
                                Err(copyErr).
                                Str("backup_path", backupPath).
                                Msg("failed to create config backup")
                }</span>
        }

        // Marshal config to YAML
        <span class="cov0" title="0">data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        // Add header comment
        <span class="cov0" title="0">header := fmt.Sprintf("# ATLAS Configuration\n# %s on %s\n\n",
                headerSource, time.Now().Format(constants.TimeFormatISO))
        content := header + string(data)

        // Write config file with restrictive permissions
        if err = os.WriteFile(configPath, []byte(content), 0o600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// copyFile copies a file from src to dst.
func copyFile(src, dst string) error <span class="cov0" title="0">{
        data, err := os.ReadFile(src) //nolint:gosec // Source is config file
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(dst, data, 0o600)</span>
}

// isInGitRepo checks if the current directory is inside a git repository.
// Uses git rev-parse for accurate detection even in worktrees.
func isInGitRepo(ctx context.Context) bool <span class="cov0" title="0">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">_, err = git.DetectRepo(ctx, cwd)
        return err == nil</span>
}

// findGitRoot returns the root directory of the current working tree.
// For worktrees, this returns the worktree root (not main repo root).
// Returns empty string if not in a git repository.
func findGitRoot(ctx context.Context) string <span class="cov0" title="0">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">info, err := git.DetectRepo(ctx, cwd)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return info.WorktreePath</span>
}

// configSaveResult contains the result of saving configuration.
type configSaveResult struct {
        configPaths          []string
        projectConfigCreated bool
}

// determineAndSaveConfig determines where to save config and performs the save.
// This function handles the logic for deciding between project and global config.
func determineAndSaveConfig(ctx context.Context, w io.Writer, flags *InitFlags, cfg AtlasConfig, styles *initStyles) (*configSaveResult, error) <span class="cov0" title="0">{
        result := &amp;configSaveResult{
                configPaths: []string{},
        }

        saveToProject := flags.Project
        saveToGlobal := flags.Global

        // If neither flag is set, determine based on context
        if !saveToProject &amp;&amp; !saveToGlobal </span><span class="cov0" title="0">{
                saveToProject, saveToGlobal = determineConfigLocations(ctx, w, flags, styles)
        }</span>

        // Save to project config if requested
        <span class="cov0" title="0">if saveToProject </span><span class="cov0" title="0">{
                if err := saveProjectConfig(ctx, cfg); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to save project configuration: %w", err)
                }</span>
                <span class="cov0" title="0">gitRoot := findGitRoot(ctx)
                projectPath := filepath.Join(gitRoot, constants.AtlasHome, constants.GlobalConfigName)
                result.configPaths = append(result.configPaths, projectPath)
                result.projectConfigCreated = true</span>
        }

        // Save to global config if requested
        <span class="cov0" title="0">if saveToGlobal </span><span class="cov0" title="0">{
                if err := saveGlobalConfig(cfg); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to save global configuration: %w", err)
                }</span>
                <span class="cov0" title="0">home, _ := os.UserHomeDir()
                globalPath := filepath.Join(home, constants.AtlasHome, constants.GlobalConfigName)
                result.configPaths = append(result.configPaths, globalPath)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// determineConfigLocations decides whether to save to project and/or global config.
// Returns (saveToProject, saveToGlobal).
func determineConfigLocations(ctx context.Context, w io.Writer, flags *InitFlags, styles *initStyles) (bool, bool) <span class="cov0" title="0">{
        inGitRepo := isInGitRepo(ctx)

        // Non-interactive or not in git repo: save to global only
        if flags.NoInteractive || !inGitRepo </span><span class="cov0" title="0">{
                return false, true
        }</span>

        // Interactive and in git repo: ask user
        <span class="cov0" title="0">saveToProject, promptErr := promptProjectConfigCreation(w, styles)
        if promptErr != nil </span><span class="cov0" title="0">{
                // On error, fall back to global only
                return false, true
        }</span>

        // If not project, save to global
        <span class="cov0" title="0">if !saveToProject </span><span class="cov0" title="0">{
                return false, true
        }</span>

        <span class="cov0" title="0">return true, false</span>
}

// promptProjectConfigCreation prompts the user to create project-specific config.
func promptProjectConfigCreation(w io.Writer, styles *initStyles) (bool, error) <span class="cov0" title="0">{
        _, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.info.Render("Git repository detected"))
        _, _ = fmt.Fprintln(w, styles.dim.Render("  You can create a project-specific configuration that overrides global settings."))
        _, _ = fmt.Fprintln(w, styles.dim.Render("  This is recommended for shared projects with team-specific settings."))
        _, _ = fmt.Fprintln(w)

        var createProjectConfig bool
        form := huh.NewForm(
                huh.NewGroup(
                        huh.NewConfirm().
                                Title("Create project-specific configuration?").
                                Description("Creates .atlas/config.yaml in the project root").
                                Affirmative("Yes (recommended for teams)").
                                Negative("No (use global config only)").
                                Value(&amp;createProjectConfig),
                ),
        ).WithTheme(tui.AtlasTheme())

        if err := form.Run(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return createProjectConfig, nil</span>
}

// saveProjectConfig writes the configuration to .atlas/config.yaml in the git root.
// If a config file already exists, it creates a backup before overwriting.
func saveProjectConfig(ctx context.Context, cfg AtlasConfig) error <span class="cov0" title="0">{
        gitRoot := findGitRoot(ctx)
        if gitRoot == "" </span><span class="cov0" title="0">{
                return atlaserrors.ErrNotInGitRepo
        }</span>

        // Create .atlas directory with restrictive permissions (0700)
        // This is a config directory that may contain sensitive data
        <span class="cov0" title="0">atlasDir := filepath.Join(gitRoot, constants.AtlasHome)
        if err := os.MkdirAll(atlasDir, 0o700); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create project config directory: %w", err)
        }</span>

        <span class="cov0" title="0">configPath := filepath.Join(atlasDir, constants.GlobalConfigName)

        // Check if config file already exists and create backup
        if _, statErr := os.Stat(configPath); statErr == nil </span><span class="cov0" title="0">{
                backupPath := configPath + ".backup"
                if copyErr := copyFile(configPath, backupPath); copyErr != nil </span><span class="cov0" title="0">{
                        // Log warning but continue - backup is best effort
                        logger := Logger()
                        logger.Warn().
                                Err(copyErr).
                                Str("backup_path", backupPath).
                                Msg("failed to create config backup")
                }</span>
        }

        // Marshal config to YAML
        <span class="cov0" title="0">data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        // Add header comment
        <span class="cov0" title="0">header := fmt.Sprintf("# ATLAS Project Configuration\n# Generated by atlas init on %s\n# This file overrides ~/.atlas/config.yaml for this project.\n# Consider adding .atlas/config.yaml to .gitignore if it contains sensitive data.\n\n",
                time.Now().Format(constants.TimeFormatISO))
        content := header + string(data)

        // Write config file with restrictive permissions (0600)
        if err = os.WriteFile(configPath, []byte(content), 0o600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write project config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// saveGlobalConfig writes the configuration to ~/.atlas/config.yaml.
// If a config file already exists, it creates a backup before overwriting.
func saveGlobalConfig(cfg AtlasConfig) error <span class="cov0" title="0">{
        return saveAtlasConfig(cfg, "Generated by atlas init")
}</span>

// displaySuccessMessageWithPaths shows the success message after configuration with specific paths.
func displaySuccessMessageWithPaths(w io.Writer, nonInteractive, projectConfigCreated bool, configPaths []string, styles *initStyles) <span class="cov0" title="0">{
        _, _ = fmt.Fprintln(w)
        _, _ = fmt.Fprintln(w, styles.success.Render("✓ ATLAS configuration saved successfully!"))
        _, _ = fmt.Fprintln(w)

        _, _ = fmt.Fprintln(w, styles.info.Render("Configuration saved to:"))
        for _, path := range configPaths </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, styles.dim.Render("  "+path))
        }</span>
        <span class="cov0" title="0">_, _ = fmt.Fprintln(w)

        // Show gitignore suggestion if project config was created
        if projectConfigCreated </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, styles.outdated.Render("Tip: Consider adding to .gitignore if config contains sensitive data:"))
                _, _ = fmt.Fprintln(w, styles.dim.Render("  .atlas/config.yaml"))
                _, _ = fmt.Fprintln(w)
        }</span>

        <span class="cov0" title="0">_, _ = fmt.Fprintln(w, styles.info.Render("Suggested next commands:"))
        _, _ = fmt.Fprintln(w, styles.dim.Render("  atlas status       - View current project status"))
        _, _ = fmt.Fprintln(w, styles.dim.Render("  atlas start        - Start a new task"))
        _, _ = fmt.Fprintln(w, styles.dim.Render("  atlas config show  - View effective configuration"))
        _, _ = fmt.Fprintln(w)

        if nonInteractive </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, styles.dim.Render("Note: Non-interactive mode used default values."))
                _, _ = fmt.Fprintln(w, styles.dim.Render("Edit the config file or run 'atlas init' interactively to customize."))
        }</span>
}
</pre>

		<pre class="file" id="file22" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "fmt"
        "io"
        "os"

        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/spf13/cobra"
)

// AddLintCommand adds the lint command to the root command.
func AddLintCommand(root *cobra.Command) <span class="cov0" title="0">{
        root.AddCommand(newLintCmd())
}</span>

func newLintCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "lint",
                Short: "Run code linters",
                Long: `Run configured code linters on the current directory.

Uses 'magex lint' by default if no linters are configured.

Examples:
  atlas lint
  atlas lint --output json
  atlas lint --verbose`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runLint(cmd.Context(), cmd, os.Stdout)
                }</span>,
        }

        <span class="cov0" title="0">return cmd</span>
}

func runLint(ctx context.Context, cmd *cobra.Command, w io.Writer) error <span class="cov0" title="0">{
        // Check context cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">logger := Logger()
        outputFormat := cmd.Flag("output").Value.String()
        verbose := cmd.Flag("verbose").Value.String() == "true"
        tui.CheckNoColor()

        out := tui.NewOutput(w, outputFormat)

        // Load config
        cfg, err := config.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("failed to load config, using defaults")
                cfg = config.DefaultConfig()
        }</span>

        // Get lint commands
        <span class="cov0" title="0">commands := cfg.Validation.Commands.Lint
        if len(commands) == 0 </span><span class="cov0" title="0">{
                commands = []string{constants.DefaultLintCommand}
        }</span>

        <span class="cov0" title="0">workDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get working directory: %w", err)
        }</span>

        <span class="cov0" title="0">opts := UtilityOptions{
                Verbose:      verbose,
                OutputFormat: outputFormat,
                Writer:       w,
        }

        return runCommandsWithOutput(ctx, commands, workDir, "Lint", out, opts, logger)</span>
}
</pre>

		<pre class="file" id="file23" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/logging"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "golang.org/x/term"
        "gopkg.in/natefinch/lumberjack.v2"
)

// LogFileWriter holds the log file writer for cleanup purposes.
// This is package-level to enable cleanup during shutdown.
var logFileWriter io.WriteCloser //nolint:gochecknoglobals // Needed for cleanup

// zerologConfigOnce ensures zerolog global settings are configured exactly once.
var zerologConfigOnce sync.Once //nolint:gochecknoglobals // One-time configuration

// zerologGlobalMu protects concurrent writes to the zerolog global logger.
// This is separate from globalLoggerMu to avoid deadlocks.
var zerologGlobalMu sync.Mutex //nolint:gochecknoglobals // Protects zerolog global

// configureZerologGlobals sets zerolog global field names to match our log entry structure.
// This is called once before any logger is created and is safe for concurrent use.
func configureZerologGlobals() <span class="cov0" title="0">{
        zerologConfigOnce.Do(func() </span><span class="cov0" title="0">{
                // Use "ts" for timestamp to match logEntry struct in workspace_logs.go
                zerolog.TimestampFieldName = "ts"
                // Use "event" for message to match logEntry struct
                zerolog.MessageFieldName = "event"
        }</span>)
}

// loggerSetup holds the common components needed to create a logger.
type loggerSetup struct {
        level      zerolog.Level
        hook       zerolog.Hook
        fileWriter io.WriteCloser
        console    io.Writer
}

// prepareLoggerSetup creates the common logger components.
// Returns the setup and any error from file writer creation.
// The error is non-fatal - callers can proceed with console-only logging.
func prepareLoggerSetup(verbose, quiet bool) (*loggerSetup, error) <span class="cov0" title="0">{
        configureZerologGlobals()

        setup := &amp;loggerSetup{
                level:   selectLevel(verbose, quiet),
                hook:    logging.NewSensitiveDataHook(),
                console: selectOutput(),
        }

        fileWriter, err := createLogFileWriter()
        if err == nil </span><span class="cov0" title="0">{
                setup.fileWriter = fileWriter
        }</span>
        <span class="cov0" title="0">return setup, err</span>
}

// buildLogger creates a zerolog.Logger from the setup and writer.
func buildLogger(setup *loggerSetup, writer io.Writer) zerolog.Logger <span class="cov0" title="0">{
        return zerolog.New(writer).Level(setup.level).Hook(setup.hook).With().Timestamp().Logger()
}</span>

// InitLogger creates and configures a zerolog.Logger based on verbosity flags.
//
// Log levels are set as follows:
//   - verbose=true: Debug level (most detailed)
//   - quiet=true: Warn level (errors and warnings only)
//   - default: Info level (normal operation)
//
// Output format is determined by the terminal:
//   - TTY with colors enabled: Console writer with timestamps
//   - Non-TTY or NO_COLOR set: JSON output to stderr
//
// The logger also writes to ~/.atlas/logs/atlas.log with rotation enabled.
// If the log file cannot be created, the logger will continue with console-only output.
func InitLogger(verbose, quiet bool) zerolog.Logger <span class="cov0" title="0">{
        setup, err := prepareLoggerSetup(verbose, quiet)

        var writer io.Writer
        if err != nil || setup.fileWriter == nil </span><span class="cov0" title="0">{
                // Log file creation failed; continue with console-only output
                writer = setup.console
        }</span> else<span class="cov0" title="0"> {
                // Store file writer for cleanup
                logFileWriter = setup.fileWriter
                // Multi-writer: console + file
                writer = zerolog.MultiLevelWriter(setup.console, setup.fileWriter)
        }</span>

        <span class="cov0" title="0">logger := buildLogger(setup, writer)
        setGlobalLogger(logger)
        return logger</span>
}

// setGlobalLogger configures the global zerolog logger to match our CLI logger config.
// This ensures that any code using log.Debug(), log.Info(), etc. from the
// github.com/rs/zerolog/log package uses the same formatting as our CLI logger.
// This function is safe for concurrent use.
func setGlobalLogger(cliLogger zerolog.Logger) <span class="cov0" title="0">{
        zerologGlobalMu.Lock()
        defer zerologGlobalMu.Unlock()
        log.Logger = cliLogger
}</span>

// InitLoggerWithWriter creates and configures a zerolog.Logger with a custom writer.
// This is primarily intended for testing purposes.
func InitLoggerWithWriter(verbose, quiet bool, w io.Writer) zerolog.Logger <span class="cov0" title="0">{
        // Configure zerolog global field names on first call
        configureZerologGlobals()

        level := selectLevel(verbose, quiet)
        hook := logging.NewSensitiveDataHook()
        logger := zerolog.New(w).Level(level).Hook(hook).With().Timestamp().Logger()

        // Configure global logger to match CLI logger settings
        setGlobalLogger(logger)

        return logger
}</span>

// TaskLogAppender is a minimal interface for appending logs to task-specific log files.
// This interface is satisfied by task.Store.
type TaskLogAppender interface {
        AppendLog(ctx context.Context, workspaceName, taskID string, entry []byte) error
}

// InitLoggerWithTaskStore creates a logger that persists task-specific logs.
// Log entries with workspace_name and task_id fields are written to the task's log file.
// All logs continue to go to console and global log file as normal.
func InitLoggerWithTaskStore(verbose, quiet bool, store TaskLogAppender) zerolog.Logger <span class="cov0" title="0">{
        setup, err := prepareLoggerSetup(verbose, quiet)

        var baseWriter io.Writer
        if err != nil || setup.fileWriter == nil </span><span class="cov0" title="0">{
                // Log file creation failed; continue with console-only output + task logs
                baseWriter = setup.console
        }</span> else<span class="cov0" title="0"> {
                // Store file writer for cleanup
                logFileWriter = setup.fileWriter
                // Multi-writer: console + file
                baseWriter = zerolog.MultiLevelWriter(setup.console, setup.fileWriter)
        }</span>

        // Wrap with task log writer to persist task-specific logs
        <span class="cov0" title="0">taskLogWriter := newTaskLogWriter(store, baseWriter)

        logger := buildLogger(setup, taskLogWriter)
        setGlobalLogger(logger)
        return logger</span>
}

// taskLogWriter wraps an io.Writer and persists log entries with workspace_name
// and task_id fields to the task-specific log file.
type taskLogWriter struct {
        store  TaskLogAppender
        target io.Writer
}

// newTaskLogWriter creates a taskLogWriter that persists logs with workspace/task
// context to the task store while passing all writes to the target writer.
func newTaskLogWriter(store TaskLogAppender, target io.Writer) *taskLogWriter <span class="cov0" title="0">{
        return &amp;taskLogWriter{
                store:  store,
                target: target,
        }
}</span>

// logFields represents the minimal fields we need to extract from log entries.
type logFields struct {
        WorkspaceName string `json:"workspace_name"`
        TaskID        string `json:"task_id"`
}

// Write implements io.Writer. It parses JSON log entries to extract workspace_name
// and task_id, persisting matching entries to the task log file.
func (w *taskLogWriter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        // Try to persist to task log if entry has workspace/task context
        w.persistToTaskLog(p)

        // Always pass through to target writer
        return w.target.Write(p)
}</span>

// persistToTaskLog attempts to parse the log entry and persist it to the task log.
// Failures are silently ignored to avoid disrupting normal logging.
func (w *taskLogWriter) persistToTaskLog(p []byte) <span class="cov0" title="0">{
        // Parse JSON to extract workspace_name and task_id
        var fields logFields
        if err := json.Unmarshal(p, &amp;fields); err != nil </span><span class="cov0" title="0">{
                // Not valid JSON or doesn't have our fields - skip silently
                return
        }</span>

        // Only persist if both workspace_name and task_id are present
        <span class="cov0" title="0">if fields.WorkspaceName == "" || fields.TaskID == "" </span><span class="cov0" title="0">{
                return
        }</span>

        // Persist to task log with timeout to prevent blocking on slow disk I/O.
        // Errors are ignored to avoid disrupting normal logging.
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        _ = w.store.AppendLog(ctx, fields.WorkspaceName, fields.TaskID, p)</span>
}

// spinnerAwareWriter wraps an io.Writer and clears the spinner line before writing.
// This prevents log messages from appearing on the same line as the spinner animation.
type spinnerAwareWriter struct {
        target  io.Writer
        manager interface {
                GetActive() *tui.TerminalSpinner
        }
}

// newSpinnerAwareWriter creates a spinner-aware writer that clears the active
// spinner line before writing log messages.
func newSpinnerAwareWriter(target io.Writer, manager interface {
        GetActive() *tui.TerminalSpinner
},
) *spinnerAwareWriter <span class="cov0" title="0">{
        return &amp;spinnerAwareWriter{
                target:  target,
                manager: manager,
        }
}</span>

// Write implements io.Writer. If a spinner is active, it clears the spinner line
// before writing the log message.
func (w *spinnerAwareWriter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        // Check if a spinner is currently active
        if activeSpinner := w.manager.GetActive(); activeSpinner != nil </span><span class="cov0" title="0">{
                // Combine clear sequence and log message into single write for atomicity
                // This prevents the spinner from writing between clear and log
                combined := make([]byte, 0, len("\r\033[K")+len(p))
                combined = append(combined, "\r\033[K"...)
                combined = append(combined, p...)
                written, err := w.target.Write(combined)
                // Return original length since caller expects len(p) on success
                if err == nil </span><span class="cov0" title="0">{
                        return len(p), nil
                }</span>
                // Adjust written count if partial write occurred
                <span class="cov0" title="0">if written &gt; len("\r\033[K") </span><span class="cov0" title="0">{
                        return written - len("\r\033[K"), err
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }

        // Write the actual log message
        <span class="cov0" title="0">return w.target.Write(p)</span>
}

// CloseLogFile closes the global log file writer if it was opened.
// This should be called during application shutdown for clean cleanup.
func CloseLogFile() <span class="cov0" title="0">{
        if logFileWriter != nil </span><span class="cov0" title="0">{
                _ = logFileWriter.Close()
                logFileWriter = nil
        }</span>
}

// selectLevel determines the appropriate log level based on flags.
func selectLevel(verbose, quiet bool) zerolog.Level <span class="cov0" title="0">{
        switch </span>{
        case verbose:<span class="cov0" title="0">
                return zerolog.DebugLevel</span>
        case quiet:<span class="cov0" title="0">
                return zerolog.WarnLevel</span>
        default:<span class="cov0" title="0">
                return zerolog.InfoLevel</span>
        }
}

// selectOutput determines the appropriate output writer based on
// terminal capabilities and environment settings.
func selectOutput() io.Writer <span class="cov0" title="0">{
        // Use console writer for TTY without NO_COLOR
        if term.IsTerminal(int(os.Stderr.Fd())) &amp;&amp; os.Getenv("NO_COLOR") == "" </span><span class="cov0" title="0">{
                // ConsoleWriter parses JSON from zerolog and formats it for human reading.
                // Its output goes to spinnerAwareWriter which clears the spinner line before
                // writing, preventing log/spinner line collisions.
                // Order matters: ConsoleWriter must receive raw JSON (not ANSI-prefixed data).
                consoleWriter := zerolog.ConsoleWriter{
                        Out:        newSpinnerAwareWriter(os.Stderr, tui.GlobalSpinnerManager()),
                        TimeFormat: time.Kitchen,
                }
                return consoleWriter
        }</span>

        // Default to JSON output for non-TTY or when NO_COLOR is set
        <span class="cov0" title="0">return os.Stderr</span>
}

// filteringWriteCloser wraps a WriteCloser with sensitive data filtering.
// It implements io.WriteCloser so it can be used as a drop-in replacement.
type filteringWriteCloser struct {
        filter *logging.FilteringWriter
        closer io.Closer
}

// Write implements io.Writer by delegating to the filtering writer.
func (fwc *filteringWriteCloser) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        return fwc.filter.Write(p)
}</span>

// Close implements io.Closer by delegating to the underlying closer.
func (fwc *filteringWriteCloser) Close() error <span class="cov0" title="0">{
        return fwc.closer.Close()
}</span>

// createLogFileWriter creates a rotating file writer for the global CLI log.
// Returns a lumberjack logger configured with rotation settings, wrapped with
// a filtering writer to ensure sensitive data is never written to disk.
func createLogFileWriter() (io.WriteCloser, error) <span class="cov0" title="0">{
        atlasHome, err := getAtlasHome()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">logDir := filepath.Join(atlasHome, constants.LogsDir)
        logPath := filepath.Join(logDir, constants.CLILogFileName)

        // Ensure log directory exists
        if err := os.MkdirAll(logDir, 0o750); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log directory: %w", err)
        }</span>

        // Create rotating log file writer
        <span class="cov0" title="0">lj := &amp;lumberjack.Logger{
                Filename:   logPath,
                MaxSize:    constants.LogMaxSizeMB,
                MaxBackups: constants.LogMaxBackups,
                MaxAge:     constants.LogMaxAgeDays,
                Compress:   constants.LogCompress,
        }

        // Wrap with filtering writer to redact sensitive data
        return &amp;filteringWriteCloser{
                filter: logging.NewFilteringWriter(lj),
                closer: lj,
        }, nil</span>
}

// getAtlasHome returns the atlas home directory path.
// If ATLAS_HOME environment variable is set, it uses that.
// Otherwise, it defaults to ~/.atlas.
func getAtlasHome() (string, error) <span class="cov0" title="0">{
        if atlasHome := os.Getenv("ATLAS_HOME"); atlasHome != "" </span><span class="cov0" title="0">{
                return atlasHome, nil
        }</span>

        <span class="cov0" title="0">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get user home directory: %w", err)
        }</span>

        <span class="cov0" title="0">return filepath.Join(home, constants.AtlasHome), nil</span>
}

// LogFilePath returns the path to the global CLI log file.
// This is useful for displaying the log location to users.
func LogFilePath() (string, error) <span class="cov0" title="0">{
        atlasHome, err := getAtlasHome()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return filepath.Join(atlasHome, constants.LogsDir, constants.CLILogFileName), nil</span>
}
</pre>

		<pre class="file" id="file24" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"

        "github.com/charmbracelet/huh"
        "github.com/mrz1836/atlas/internal/tui"
)

// Notification event constants.
// These define the events that can trigger notifications.
const (
        NotifyEventAwaitingApproval = "awaiting_approval"
        NotifyEventValidationFailed = "validation_failed"
        NotifyEventCIFailed         = "ci_failed"
        NotifyEventGitHubFailed     = "github_failed"
)

// AllNotificationEvents returns all supported notification event types.
func AllNotificationEvents() []string <span class="cov0" title="0">{
        return []string{
                NotifyEventAwaitingApproval,
                NotifyEventValidationFailed,
                NotifyEventCIFailed,
                NotifyEventGitHubFailed,
        }
}</span>

// NotificationProviderConfig holds notification configuration values collected from user input.
// This struct is used for collecting configuration before saving.
type NotificationProviderConfig struct {
        // BellEnabled enables terminal bell notifications.
        BellEnabled bool
        // Events is the list of events to notify on.
        Events []string
}

// NotificationConfigDefaults returns the default values for notification configuration.
// Uses granular events only (no legacy "error" event).
func NotificationConfigDefaults() NotificationProviderConfig <span class="cov0" title="0">{
        return NotificationProviderConfig{
                BellEnabled: true,
                Events: []string{
                        NotifyEventAwaitingApproval,
                        NotifyEventValidationFailed,
                        NotifyEventCIFailed,
                        NotifyEventGitHubFailed,
                },
        }
}</span>

// DefaultNotificationConfig returns a NotificationConfig with sensible defaults.
// Bell is enabled and granular events are selected (no legacy "error" event).
func DefaultNotificationConfig() NotificationConfig <span class="cov0" title="0">{
        return NotificationConfig{
                BellEnabled: true,
                Events: []string{
                        NotifyEventAwaitingApproval,
                        NotifyEventValidationFailed,
                        NotifyEventCIFailed,
                        NotifyEventGitHubFailed,
                },
        }
}</span>

// NewNotificationConfigForm creates a Charm Huh form for notification configuration.
// The form collects bell enable/disable and event selection settings.
func NewNotificationConfigForm(cfg *NotificationProviderConfig) *huh.Form <span class="cov0" title="0">{
        return huh.NewForm(
                huh.NewGroup(
                        huh.NewConfirm().
                                Title("Enable Terminal Bell").
                                Description("Play a sound when ATLAS needs your attention").
                                Affirmative("Yes").
                                Negative("No").
                                Value(&amp;cfg.BellEnabled),
                        huh.NewMultiSelect[string]().
                                Title("Notification Events").
                                Description("Select events that should trigger notifications").
                                Options(
                                        huh.NewOption("Task awaiting approval", NotifyEventAwaitingApproval).Selected(true),
                                        huh.NewOption("Validation failed", NotifyEventValidationFailed).Selected(true),
                                        huh.NewOption("CI failed", NotifyEventCIFailed).Selected(true),
                                        huh.NewOption("GitHub operation failed", NotifyEventGitHubFailed).Selected(true),
                                ).
                                Value(&amp;cfg.Events),
                ),
        ).WithTheme(tui.AtlasTheme())
}</span>

// formRunner is an interface that matches huh.Form's Run method.
// This is defined in abandon.go but repeated here for clarity.

//nolint:gochecknoglobals // Test injection point - standard Go testing pattern
var createNotificationConfigForm = defaultCreateNotificationConfigForm

// defaultCreateNotificationConfigForm is the production implementation.
func defaultCreateNotificationConfigForm(cfg *NotificationProviderConfig) formRunner <span class="cov0" title="0">{
        return NewNotificationConfigForm(cfg)
}</span>

// CollectNotificationConfigInteractive runs the notification configuration form and returns the collected config.
// It validates all inputs and handles form errors.
func CollectNotificationConfigInteractive(ctx context.Context, cfg *NotificationProviderConfig) error <span class="cov0" title="0">{
        // Check cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">defaults := NotificationConfigDefaults()

        // Initialize Events with defaults if empty (form will show current selections).
        // BellEnabled is handled by the form's default value directly.
        if len(cfg.Events) == 0 </span><span class="cov0" title="0">{
                cfg.Events = defaults.Events
        }</span>

        <span class="cov0" title="0">form := createNotificationConfigForm(cfg)
        if err := form.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CollectNotificationConfigNonInteractive returns a configuration with default values.
// Used when running in non-interactive mode.
func CollectNotificationConfigNonInteractive() NotificationProviderConfig <span class="cov0" title="0">{
        return NotificationConfigDefaults()
}</span>

// ToNotificationConfig converts the provider config to NotificationConfig struct.
func (cfg *NotificationProviderConfig) ToNotificationConfig() NotificationConfig <span class="cov0" title="0">{
        return NotificationConfig{
                BellEnabled: cfg.BellEnabled,
                Events:      cfg.Events,
        }
}</span>

// ValidateNotificationConfig validates a NotificationProviderConfig.
// Returns an error if the configuration is invalid.
func ValidateNotificationConfig(_ *NotificationProviderConfig) error <span class="cov0" title="0">{
        // Events can be empty (user may not want any notifications)
        // BellEnabled is always valid (true or false)
        // No validation errors for notification config
        return nil
}</span>

// PopulateNotificationConfigDefaults populates the config with default values.
func PopulateNotificationConfigDefaults(cfg *NotificationProviderConfig) <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">defaults := NotificationConfigDefaults()
        cfg.BellEnabled = defaults.BellEnabled
        cfg.Events = defaults.Events</span>
}
</pre>

		<pre class="file" id="file25" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/domain"
        atlaserrors "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/task"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/workspace"
        "github.com/spf13/cobra"
)

// AddRejectCommand adds the reject command to the root command.
func AddRejectCommand(root *cobra.Command) <span class="cov8" title="1">{
        root.AddCommand(newRejectCmd())
}</span>

// rejectOptions contains all options for the reject command.
type rejectOptions struct {
        workspace string // Required workspace name
        retry     bool   // For JSON mode: reject and retry
        done      bool   // For JSON mode: reject done
        feedback  string // For JSON mode with retry: feedback text
        step      int    // For JSON mode with retry: step to resume from
}

// newRejectCmd creates the reject command.
func newRejectCmd() *cobra.Command <span class="cov8" title="1">{
        opts := &amp;rejectOptions{}

        cmd := &amp;cobra.Command{
                Use:   "reject [workspace]",
                Short: "Reject work with feedback",
                Long: `Reject a task that is awaiting approval.

You can either reject and retry (AI will retry with your feedback) or
reject and be done (preserve branch for manual work).

Interactive mode:
  atlas reject my-feature

  Presents a decision flow with options:
  - "Reject and retry": Provide feedback and choose a step to resume from
  - "Reject (done)": End task, preserve branch for manual work

JSON mode (requires --output json):
  # Reject with retry (step is 1-indexed, 0 = auto-select)
  atlas reject my-feature --output json --retry --feedback "Fix auth flow" --step 3

  # Reject done
  atlas reject my-feature --output json --done

Examples:
  atlas reject                    # Interactive selection if multiple tasks
  atlas reject my-feature         # Reject task in my-feature workspace
  atlas reject -o json my-feature --done  # JSON output, reject done`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                opts.workspace = args[0]
                        }</span>
                        <span class="cov0" title="0">return runReject(cmd.Context(), cmd, os.Stdout, opts)</span>
                },
        }

        // Add JSON mode flags
        <span class="cov8" title="1">cmd.Flags().BoolVar(&amp;opts.retry, "retry", false, "Reject and retry (JSON mode)")
        cmd.Flags().BoolVar(&amp;opts.done, "done", false, "Reject and be done (JSON mode)")
        cmd.Flags().StringVar(&amp;opts.feedback, "feedback", "", "Feedback for retry (JSON mode)")
        cmd.Flags().IntVar(&amp;opts.step, "step", 0, "Step to resume from, 1-indexed (0 = auto-select, JSON mode)")

        return cmd</span>
}

// rejectResponse represents the JSON output for reject operations.
type rejectResponse struct {
        Success       bool   `json:"success"`
        Action        string `json:"action"` // "retry" or "done"
        WorkspaceName string `json:"workspace_name"`
        TaskID        string `json:"task_id"`
        Feedback      string `json:"feedback,omitempty"`
        ResumeStep    int    `json:"resume_step,omitempty"`
        BranchName    string `json:"branch_name,omitempty"`
        WorktreePath  string `json:"worktree_path,omitempty"`
        Error         string `json:"error,omitempty"`
}

// rejectAction represents the decision flow options.
type rejectAction string

const (
        rejectActionRetry rejectAction = "retry"
        rejectActionDone  rejectAction = "done"
)

// runReject executes the reject command.
func runReject(ctx context.Context, cmd *cobra.Command, w io.Writer, opts *rejectOptions) error <span class="cov8" title="1">{
        outputFormat := cmd.Flag("output").Value.String()
        return runRejectWithOutput(ctx, w, opts, "", outputFormat)
}</span>

// runRejectWithOutput executes the reject command with specified output format and base directory.
// This function is testable and accepts a storeBaseDir for dependency injection.
func runRejectWithOutput(ctx context.Context, w io.Writer, opts *rejectOptions, storeBaseDir, outputFormat string) error <span class="cov8" title="1">{
        // Check context cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return ctx.Err()</span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">logger := Logger()

        // Respect NO_COLOR environment variable
        tui.CheckNoColor()

        out := tui.NewOutput(w, outputFormat)

        // JSON mode requires workspace argument
        if outputFormat == OutputJSON &amp;&amp; opts.workspace == "" </span><span class="cov8" title="1">{
                return handleRejectError(outputFormat, w, "", fmt.Errorf("workspace argument required with --output json: %w", atlaserrors.ErrInvalidArgument))
        }</span>

        // JSON mode requires --retry or --done flag
        <span class="cov8" title="1">if outputFormat == OutputJSON &amp;&amp; !opts.retry &amp;&amp; !opts.done </span><span class="cov8" title="1">{
                return handleRejectError(outputFormat, w, opts.workspace, fmt.Errorf("--retry or --done flag required with --output json: %w", atlaserrors.ErrInvalidArgument))
        }</span>

        // Cannot specify both --retry and --done
        <span class="cov8" title="1">if opts.retry &amp;&amp; opts.done </span><span class="cov8" title="1">{
                return handleRejectError(outputFormat, w, opts.workspace, fmt.Errorf("cannot use both --retry and --done: %w", atlaserrors.ErrInvalidArgument))
        }</span>

        // Create stores
        <span class="cov8" title="1">wsStore, taskStore, err := CreateStores(storeBaseDir)
        if err != nil </span><span class="cov0" title="0">{
                return handleRejectError(outputFormat, w, "", err)
        }</span>

        // Find and select task
        <span class="cov8" title="1">selectedWS, selectedTask, err := findAndSelectTaskForReject(ctx, outputFormat, w, out, opts, wsStore, taskStore)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if selectedWS == nil </span><span class="cov8" title="1">{
                // No tasks awaiting approval (message already shown)
                return nil
        }</span>

        <span class="cov8" title="1">logger.Debug().
                Str("workspace_name", selectedWS.Name).
                Str("task_id", selectedTask.ID).
                Str("status", string(selectedTask.Status)).
                Msg("selected task for rejection")

        // Load config for notification settings
        cfg, err := config.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("failed to load config, using default notification settings")
                cfg = config.DefaultConfig()
        }</span>

        // Create notifier
        <span class="cov8" title="1">notifier := tui.NewNotifier(cfg.Notifications.Bell, false)

        // JSON mode: process directly without interactive menu
        if outputFormat == OutputJSON </span><span class="cov8" title="1">{
                return processJSONReject(ctx, w, taskStore, selectedWS, selectedTask, opts)
        }</span>

        // Interactive rejection flow
        <span class="cov0" title="0">return runInteractiveReject(ctx, out, taskStore, selectedWS, selectedTask, notifier)</span>
}

// findAndSelectTaskForReject finds awaiting tasks and selects one based on options.
func findAndSelectTaskForReject(ctx context.Context, outputFormat string, w io.Writer, out tui.Output, opts *rejectOptions, wsStore workspace.Store, taskStore task.Store) (*domain.Workspace, *domain.Task, error) <span class="cov8" title="1">{
        // Find tasks awaiting approval
        awaitingTasks, err := findAwaitingApprovalTasks(ctx, wsStore, taskStore)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, handleRejectError(outputFormat, w, "", err)
        }</span>

        // Handle case where no tasks are awaiting approval
        <span class="cov8" title="1">if len(awaitingTasks) == 0 </span><span class="cov8" title="1">{
                if outputFormat == OutputJSON </span><span class="cov8" title="1">{
                        return nil, nil, handleRejectError(outputFormat, w, "", atlaserrors.ErrNoTasksFound)
                }</span>
                <span class="cov8" title="1">out.Info("No tasks awaiting approval.")
                out.Info("Run 'atlas status' to see all workspace statuses.")
                return nil, nil, nil</span>
        }

        // If workspace provided, find it directly
        <span class="cov8" title="1">if opts.workspace != "" </span><span class="cov8" title="1">{
                for _, at := range awaitingTasks </span><span class="cov8" title="1">{
                        if at.workspace.Name == opts.workspace </span><span class="cov8" title="1">{
                                return at.workspace, at.task, nil
                        }</span>
                }
                <span class="cov0" title="0">return nil, nil, handleRejectError(outputFormat, w, opts.workspace, fmt.Errorf("workspace '%s' not found or not awaiting approval: %w", opts.workspace, atlaserrors.ErrWorkspaceNotFound))</span>
        }

        // Auto-select if only one task
        <span class="cov8" title="1">if len(awaitingTasks) == 1 </span><span class="cov8" title="1">{
                return awaitingTasks[0].workspace, awaitingTasks[0].task, nil
        }</span>

        // Present selection menu
        <span class="cov0" title="0">selected, err := selectWorkspaceForReject(awaitingTasks)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, tui.ErrMenuCanceled) </span><span class="cov0" title="0">{
                        out.Info("Rejection canceled.")
                        return nil, nil, nil
                }</span>
                <span class="cov0" title="0">return nil, nil, handleRejectError(outputFormat, w, "", err)</span>
        }

        <span class="cov0" title="0">return selected.workspace, selected.task, nil</span>
}

// selectWorkspaceForReject presents a selection menu for multiple awaiting tasks.
func selectWorkspaceForReject(tasks []awaitingTask) (*awaitingTask, error) <span class="cov0" title="0">{
        idx, err := SelectWorkspaceTask("Select a workspace to reject:", tasks)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;tasks[idx], nil</span>
}

// runInteractiveReject runs the interactive rejection flow.
func runInteractiveReject(ctx context.Context, out tui.Output, taskStore task.Store, ws *domain.Workspace, t *domain.Task, notifier *tui.Notifier) error <span class="cov0" title="0">{
        // Display task summary (AC: #1)
        displayTaskSummary(out, ws, t)

        // Present decision flow (AC: #2)
        action, err := selectRejectAction()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, tui.ErrMenuCanceled) </span><span class="cov0" title="0">{
                        out.Info("Rejection canceled.")
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">switch action </span>{
        case rejectActionRetry:<span class="cov0" title="0">
                return handleRejectAndRetry(ctx, out, taskStore, ws, t, notifier)</span>
        case rejectActionDone:<span class="cov0" title="0">
                return handleRejectDone(ctx, out, taskStore, ws, t, notifier)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// displayTaskSummary shows a brief summary of the task before the decision flow.
func displayTaskSummary(out tui.Output, ws *domain.Workspace, t *domain.Task) <span class="cov0" title="0">{
        out.Info(fmt.Sprintf("Workspace: %s", ws.Name))
        out.Info(fmt.Sprintf("Task: %s", t.Description))
        out.Info(fmt.Sprintf("Status: %s", t.Status))
        out.Info("")
}</span>

// selectRejectAction presents the decision flow menu (AC: #2).
func selectRejectAction() (rejectAction, error) <span class="cov0" title="0">{
        options := []tui.Option{
                {
                        Label:       "Reject and retry",
                        Description: "AI will retry with your feedback",
                        Value:       string(rejectActionRetry),
                },
                {
                        Label:       "Reject (done)",
                        Description: "End task, preserve branch for manual work",
                        Value:       string(rejectActionDone),
                },
        }

        selected, err := tui.Select("How would you like to proceed?", options)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return rejectAction(selected), nil</span>
}

// handleRejectAndRetry processes the "Reject and retry" flow (AC: #3, #4, #5, #6, #7).
func handleRejectAndRetry(ctx context.Context, out tui.Output, taskStore task.Store, ws *domain.Workspace, t *domain.Task, notifier *tui.Notifier) error <span class="cov0" title="0">{
        // Get feedback with validation loop (AC: #3)
        var feedback string
        for </span><span class="cov0" title="0">{
                var err error
                feedback, err = tui.TextArea("What should be changed or fixed?", "Describe what needs to be improved...")
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, tui.ErrMenuCanceled) </span><span class="cov0" title="0">{
                                out.Info("Rejection canceled.")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                // Validate feedback is not empty (AC: #3)
                <span class="cov0" title="0">feedback = strings.TrimSpace(feedback)
                if feedback != "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">out.Warning("Feedback is required for retry. Please provide details about what should be fixed.")</span>
        }

        // Get step to resume from (AC: #4)
        <span class="cov0" title="0">resumeStep, err := selectResumeStep(t)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, tui.ErrMenuCanceled) </span><span class="cov0" title="0">{
                        out.Info("Rejection canceled.")
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Save feedback as artifact (AC: #5)
        <span class="cov0" title="0">if err := saveRejectionFeedback(ctx, taskStore, ws.Name, t.ID, feedback, resumeStep); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save rejection feedback: %w", err)
        }</span>

        // Update task metadata
        <span class="cov0" title="0">if t.Metadata == nil </span><span class="cov0" title="0">{
                t.Metadata = make(map[string]any)
        }</span>
        <span class="cov0" title="0">t.Metadata["rejection_feedback"] = feedback
        t.Metadata["resume_from_step"] = resumeStep

        // Reset current step to selected step (AC: #6)
        t.CurrentStep = resumeStep

        // Transition task status to running (AC: #6)
        if err := task.Transition(ctx, t, constants.TaskStatusRunning, "User rejected with feedback, retrying"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to transition task: %w", err)
        }</span>

        // Save updated task (AC: #6)
        <span class="cov0" title="0">if err := taskStore.Update(ctx, t.WorkspaceID, t); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save task: %w", err)
        }</span>

        <span class="cov0" title="0">stepName := ""
        if resumeStep &gt;= 0 &amp;&amp; resumeStep &lt; len(t.Steps) </span><span class="cov0" title="0">{
                stepName = t.Steps[resumeStep].Name
        }</span>

        <span class="cov0" title="0">out.Success(fmt.Sprintf("Task rejected with feedback. Resuming from step %d: %s", resumeStep+1, stepName))
        notifier.Bell()

        return nil</span>
}

// selectResumeStep presents the step selection menu (AC: #4).
func selectResumeStep(t *domain.Task) (int, error) <span class="cov0" title="0">{
        if len(t.Steps) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">options := make([]tui.Option, len(t.Steps))
        defaultStep := findDefaultResumeStep(t)

        for i, step := range t.Steps </span><span class="cov0" title="0">{
                options[i] = tui.Option{
                        Label:       fmt.Sprintf("Step %d: %s", i+1, step.Name),
                        Description: fmt.Sprintf("Type: %s", step.Type),
                        Value:       strconv.Itoa(i),
                }
        }</span>

        // Reorder to put default step first
        <span class="cov0" title="0">if defaultStep &gt; 0 &amp;&amp; defaultStep &lt; len(options) </span><span class="cov0" title="0">{
                defaultOpt := options[defaultStep]
                remaining := make([]tui.Option, 0, len(options)-1)
                for i, opt := range options </span><span class="cov0" title="0">{
                        if i != defaultStep </span><span class="cov0" title="0">{
                                remaining = append(remaining, opt)
                        }</span>
                }
                <span class="cov0" title="0">options = append([]tui.Option{defaultOpt}, remaining...)</span>
        }

        <span class="cov0" title="0">selected, err := tui.Select("Resume from which step?", options)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">stepIdx, err := strconv.Atoi(selected)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid step selection: %w", err)
        }</span>

        <span class="cov0" title="0">return stepIdx, nil</span>
}

// findDefaultResumeStep finds the earliest relevant step (e.g., "implement" step) (AC: #4).
func findDefaultResumeStep(t *domain.Task) int <span class="cov8" title="1">{
        implementStepNames := []string{"implement", "implementation", "code", "develop"}

        for i, step := range t.Steps </span><span class="cov8" title="1">{
                stepNameLower := strings.ToLower(step.Name)
                for _, name := range implementStepNames </span><span class="cov8" title="1">{
                        if strings.Contains(stepNameLower, name) </span><span class="cov8" title="1">{
                                return i
                        }</span>
                }
        }

        // Default to step 0 if no "implement" step found
        <span class="cov0" title="0">return 0</span>
}

// saveRejectionFeedback saves the feedback as an artifact (AC: #5).
func saveRejectionFeedback(ctx context.Context, taskStore task.Store, workspaceName, taskID, feedback string, resumeStep int) error <span class="cov8" title="1">{
        content := fmt.Sprintf(`# Rejection Feedback

Date: %s
Resume From: Step %d

## Feedback

%s
`, time.Now().UTC().Format(time.RFC3339), resumeStep+1, feedback)

        return taskStore.SaveArtifact(ctx, workspaceName, taskID, "rejection-feedback.md", []byte(content))
}</span>

// handleRejectDone processes the "Reject (done)" flow (AC: #8, #9).
func handleRejectDone(ctx context.Context, out tui.Output, taskStore task.Store, ws *domain.Workspace, t *domain.Task, notifier *tui.Notifier) error <span class="cov0" title="0">{
        // Transition task status to rejected (AC: #8)
        if err := task.Transition(ctx, t, constants.TaskStatusRejected, "User rejected task"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to transition task: %w", err)
        }</span>

        // Save updated task (AC: #8)
        // Workspace status is NOT changed - branch and worktree preserved (AC: #9)
        <span class="cov0" title="0">if err := taskStore.Update(ctx, t.WorkspaceID, t); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save task: %w", err)
        }</span>

        <span class="cov0" title="0">out.Info(fmt.Sprintf("Task rejected. Branch '%s' preserved at '%s'", ws.Branch, ws.WorktreePath))
        out.Info("You can work on the code manually or destroy the workspace later.")
        notifier.Bell()

        return nil</span>
}

// processJSONReject handles JSON mode rejection (AC: #10).
func processJSONReject(ctx context.Context, w io.Writer, taskStore task.Store, ws *domain.Workspace, t *domain.Task, opts *rejectOptions) error <span class="cov8" title="1">{
        if opts.retry </span><span class="cov8" title="1">{
                return processJSONRejectRetry(ctx, w, taskStore, ws, t, opts)
        }</span>
        <span class="cov8" title="1">return processJSONRejectDone(ctx, w, taskStore, ws, t)</span>
}

// processJSONRejectRetry handles JSON mode "reject and retry" (AC: #10).
func processJSONRejectRetry(ctx context.Context, w io.Writer, taskStore task.Store, ws *domain.Workspace, t *domain.Task, opts *rejectOptions) error <span class="cov8" title="1">{
        // Validate feedback for retry
        feedback := strings.TrimSpace(opts.feedback)
        if feedback == "" </span><span class="cov8" title="1">{
                return outputRejectErrorJSON(w, ws.Name, t.ID, "feedback required for retry (use --feedback)")
        }</span>

        // Determine resume step (1-indexed input, 0 = auto-select)
        <span class="cov8" title="1">var resumeStep int
        if opts.step == 0 </span><span class="cov8" title="1">{
                // Auto-select default step (same logic as interactive mode)
                resumeStep = findDefaultResumeStep(t)
        }</span> else<span class="cov8" title="1"> {
                // Validate 1-indexed step input
                if opts.step &lt; 1 || (len(t.Steps) &gt; 0 &amp;&amp; opts.step &gt; len(t.Steps)) </span><span class="cov8" title="1">{
                        return outputRejectErrorJSON(w, ws.Name, t.ID, fmt.Sprintf("invalid step %d (valid range: 1-%d, or 0 for auto)", opts.step, len(t.Steps)))
                }</span>
                // Convert 1-indexed input to 0-indexed internal
                <span class="cov8" title="1">resumeStep = opts.step - 1</span>
        }

        // Save feedback as artifact
        <span class="cov8" title="1">if err := saveRejectionFeedback(ctx, taskStore, ws.Name, t.ID, feedback, resumeStep); err != nil </span><span class="cov8" title="1">{
                return outputRejectErrorJSON(w, ws.Name, t.ID, fmt.Sprintf("failed to save feedback: %v", err))
        }</span>

        // Update task metadata
        <span class="cov8" title="1">if t.Metadata == nil </span><span class="cov8" title="1">{
                t.Metadata = make(map[string]any)
        }</span>
        <span class="cov8" title="1">t.Metadata["rejection_feedback"] = feedback
        t.Metadata["resume_from_step"] = resumeStep

        // Reset current step
        t.CurrentStep = resumeStep

        // Transition to running
        if err := task.Transition(ctx, t, constants.TaskStatusRunning, "User rejected with feedback (JSON mode)"); err != nil </span><span class="cov8" title="1">{
                return outputRejectErrorJSON(w, ws.Name, t.ID, fmt.Sprintf("failed to transition task: %v", err))
        }</span>

        // Save task
        <span class="cov8" title="1">if err := taskStore.Update(ctx, t.WorkspaceID, t); err != nil </span><span class="cov8" title="1">{
                return outputRejectErrorJSON(w, ws.Name, t.ID, fmt.Sprintf("failed to save task: %v", err))
        }</span>

        // Output success (1-indexed step for consistency with UI)
        <span class="cov8" title="1">resp := rejectResponse{
                Success:       true,
                Action:        "retry",
                WorkspaceName: ws.Name,
                TaskID:        t.ID,
                Feedback:      feedback,
                ResumeStep:    resumeStep + 1, // Output 1-indexed to match UI display
                BranchName:    ws.Branch,
                WorktreePath:  ws.WorktreePath,
        }

        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(resp)</span>
}

// processJSONRejectDone handles JSON mode "reject done" (AC: #10).
func processJSONRejectDone(ctx context.Context, w io.Writer, taskStore task.Store, ws *domain.Workspace, t *domain.Task) error <span class="cov8" title="1">{
        // Transition to rejected
        if err := task.Transition(ctx, t, constants.TaskStatusRejected, "User rejected task (JSON mode)"); err != nil </span><span class="cov8" title="1">{
                return outputRejectErrorJSON(w, ws.Name, t.ID, fmt.Sprintf("failed to transition task: %v", err))
        }</span>

        // Save task
        <span class="cov8" title="1">if err := taskStore.Update(ctx, t.WorkspaceID, t); err != nil </span><span class="cov8" title="1">{
                return outputRejectErrorJSON(w, ws.Name, t.ID, fmt.Sprintf("failed to save task: %v", err))
        }</span>

        // Output success
        <span class="cov8" title="1">resp := rejectResponse{
                Success:       true,
                Action:        "done",
                WorkspaceName: ws.Name,
                TaskID:        t.ID,
                BranchName:    ws.Branch,
                WorktreePath:  ws.WorktreePath,
        }

        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(resp)</span>
}

// handleRejectError handles errors based on output format.
func handleRejectError(format string, w io.Writer, workspaceName string, err error) error <span class="cov8" title="1">{
        return HandleCommandError(format, w, rejectResponse{
                Success:       false,
                WorkspaceName: workspaceName,
                Error:         err.Error(),
        }, err)
}</span>

// outputRejectErrorJSON outputs an error result as JSON.
func outputRejectErrorJSON(w io.Writer, workspaceName, taskID, errMsg string) error <span class="cov8" title="1">{
        return HandleCommandError(OutputJSON, w, rejectResponse{
                Success:       false,
                WorkspaceName: workspaceName,
                TaskID:        taskID,
                Error:         errMsg,
        }, atlaserrors.ErrJSONErrorOutput)
}</span>
</pre>

		<pre class="file" id="file26" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/charmbracelet/huh"
        "github.com/mrz1836/atlas/internal/ai"
        "github.com/mrz1836/atlas/internal/cli/workflow"
        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/domain"
        atlaserrors "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/git"
        "github.com/mrz1836/atlas/internal/hook"
        "github.com/mrz1836/atlas/internal/signal"
        "github.com/mrz1836/atlas/internal/task"
        "github.com/mrz1836/atlas/internal/template"
        "github.com/mrz1836/atlas/internal/template/steps"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/validation"
        "github.com/mrz1836/atlas/internal/workspace"
        "github.com/rs/zerolog"
        "github.com/spf13/cobra"
)

// AddResumeCommand adds the resume command to the root command.
func AddResumeCommand(root *cobra.Command) <span class="cov0" title="0">{
        root.AddCommand(newResumeCmd())
}</span>

// resumeOptions contains all options for the resume command.
type resumeOptions struct {
        aiFix bool
        retry bool // Skip recovery menu and directly retry
        menu  bool // Force recovery menu even for interrupted tasks
}

// newResumeCmd creates the resume command.
func newResumeCmd() *cobra.Command <span class="cov0" title="0">{
        var aiFix bool
        var retry bool
        var menu bool

        cmd := &amp;cobra.Command{
                Use:   "resume &lt;workspace&gt;",
                Short: "Resume a paused or failed task",
                Long: `Resume execution of a task that was paused or failed.

This command intelligently handles all recovery scenarios:
  - Interrupted tasks: Directly resumes execution (fast path)
  - Error tasks: Shows interactive recovery menu with auto-execution
  - Awaiting approval: Continues with approval flow

Error states handled:
  - validation_failed: Validation checks failed
  - gh_failed: GitHub operations (push/PR) failed
  - ci_failed: CI pipeline checks failed
  - ci_timeout: CI pipeline exceeded timeout

Interactive mode (default):
  atlas resume auth-fix

  For interrupted tasks, directly resumes. For error tasks, shows menu with options:
  - Retry with AI fix - AI attempts to fix based on error context
  - Fix manually - Edit files in worktree, then resume
  - Rebase and retry - For non-fast-forward push failures
  - Continue waiting - For CI timeout, resume polling
  - View errors/logs - See detailed error output
  - Abandon task - End task, preserve branch for later

Power user flags:
  atlas resume auth-fix --retry   # Skip menu, directly retry
  atlas resume auth-fix --menu    # Force menu for interrupted tasks

Examples:
  atlas resume auth-fix           # Smart resume (menu for errors, direct for interrupted)
  atlas resume auth-fix --ai-fix  # Resume with AI attempting to fix errors
  atlas resume auth-fix --retry   # Skip menu and directly retry`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runResume(cmd.Context(), cmd, os.Stdout, args[0], resumeOptions{
                                aiFix: aiFix,
                                retry: retry,
                                menu:  menu,
                        })
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;aiFix, "ai-fix", false, "Retry with AI attempting to fix errors")
        cmd.Flags().BoolVarP(&amp;retry, "retry", "r", false, "Skip recovery menu and directly retry")
        cmd.Flags().BoolVar(&amp;menu, "menu", false, "Show recovery menu even for interrupted tasks")

        return cmd</span>
}

// runResume executes the resume command.
func runResume(ctx context.Context, cmd *cobra.Command, w io.Writer, workspaceName string, opts resumeOptions) error <span class="cov0" title="0">{
        // Check context cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">logger := Logger()
        outputFormat := cmd.Flag("output").Value.String()
        tui.CheckNoColor()
        out := tui.NewOutput(w, outputFormat)

        // Setup signal handler
        sigHandler := signal.NewHandler(ctx)
        defer sigHandler.Stop()
        ctx = sigHandler.Context()

        // Setup workspace and task
        ws, currentTask, taskStore, wsStore, err := setupResumeWorkspaceAndTask(ctx, workspaceName, outputFormat, w, out, logger) //nolint:contextcheck // ctx inherits from parent via signal.NewHandler
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get template
        <span class="cov0" title="0">tmpl, err := prepareResumeTemplate(currentTask, opts, outputFormat, w, workspaceName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create engine and get progress state for process termination
        <span class="cov0" title="0">engine, state, err := createResumeEngine(ctx, ws, taskStore, currentTask, logger, out) //nolint:contextcheck // ctx inherits from parent via signal.NewHandler
        if err != nil </span><span class="cov0" title="0">{
                return handleResumeError(outputFormat, w, workspaceName, currentTask.ID, err)
        }</span>

        // Intelligent status-based behavior routing
        //nolint:exhaustive // Only handling specific resumable states
        <span class="cov0" title="0">switch currentTask.Status </span>{
        case constants.TaskStatusInterrupted:<span class="cov0" title="0">
                // Fast path: directly resume unless --menu flag is set
                if opts.menu </span><span class="cov0" title="0">{
                        // User explicitly wants the recovery menu
                        //nolint:contextcheck // context properly propagated through function calls
                        return handleRecoveryMenu(ctx, cmd, out, taskStore, ws, currentTask, engine, tmpl, state, sigHandler, wsStore, outputFormat, w, workspaceName, logger)
                }</span>
                // Direct resume for interrupted tasks
                <span class="cov0" title="0">displayResumeInfo(out, workspaceName, currentTask)
                if currentTask.Metadata == nil </span><span class="cov0" title="0">{
                        currentTask.Metadata = make(map[string]any)
                }</span>
                <span class="cov0" title="0">currentTask.Metadata["worktree_dir"] = ws.WorktreePath
                //nolint:contextcheck // context properly propagated through function calls
                return executeResumeAndHandleResult(ctx, engine, currentTask, tmpl, state, sigHandler, out, ws, wsStore, outputFormat, w, workspaceName, logger)</span>

        case constants.TaskStatusValidationFailed,
                constants.TaskStatusGHFailed,
                constants.TaskStatusCIFailed,
                constants.TaskStatusCITimeout:<span class="cov0" title="0">
                // Error states: show recovery menu unless --retry flag is set
                if opts.retry </span><span class="cov0" title="0">{
                        // Skip menu and directly retry
                        displayResumeInfo(out, workspaceName, currentTask)
                        if currentTask.Metadata == nil </span><span class="cov0" title="0">{
                                currentTask.Metadata = make(map[string]any)
                        }</span>
                        <span class="cov0" title="0">currentTask.Metadata["worktree_dir"] = ws.WorktreePath
                        //nolint:contextcheck // context properly propagated through function calls
                        return executeResumeAndHandleResult(ctx, engine, currentTask, tmpl, state, sigHandler, out, ws, wsStore, outputFormat, w, workspaceName, logger)</span>
                }
                // Show interactive recovery menu with auto-execution
                //nolint:contextcheck // context properly propagated through function calls
                <span class="cov0" title="0">return handleRecoveryMenu(ctx, cmd, out, taskStore, ws, currentTask, engine, tmpl, state, sigHandler, wsStore, outputFormat, w, workspaceName, logger)</span>

        case constants.TaskStatusAwaitingApproval:<span class="cov0" title="0">
                // Existing approval flow
                displayResumeInfo(out, workspaceName, currentTask)
                if currentTask.Metadata == nil </span><span class="cov0" title="0">{
                        currentTask.Metadata = make(map[string]any)
                }</span>
                <span class="cov0" title="0">currentTask.Metadata["worktree_dir"] = ws.WorktreePath
                //nolint:contextcheck // context properly propagated through function calls
                return executeResumeAndHandleResult(ctx, engine, currentTask, tmpl, state, sigHandler, out, ws, wsStore, outputFormat, w, workspaceName, logger)</span>

        default:<span class="cov0" title="0">
                return handleResumeError(outputFormat, w, workspaceName, currentTask.ID,
                        fmt.Errorf("%w: %s", atlaserrors.ErrInvalidStatus, currentTask.Status))</span>
        }
}

// setupResumeWorkspaceAndTask sets up the workspace, task, and stores for resume.
func setupResumeWorkspaceAndTask(ctx context.Context, workspaceName, outputFormat string, w io.Writer, out tui.Output, logger zerolog.Logger) (*domain.Workspace, *domain.Task, *task.FileStore, workspace.Store, error) <span class="cov0" title="0">{
        // Setup workspace
        _, ws, err := setupWorkspace(ctx, workspaceName, "", outputFormat, w, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, fmt.Errorf("setup workspace: %w", err)
        }</span>

        // Get task store and latest task
        <span class="cov0" title="0">taskStore, currentTask, err := getLatestTask(ctx, workspaceName, "", outputFormat, w, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, fmt.Errorf("get latest task: %w", err)
        }</span>

        // Validate task is in resumable state
        <span class="cov0" title="0">if !isResumableStatus(currentTask.Status) </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, handleResumeError(outputFormat, w, workspaceName, currentTask.ID,
                        fmt.Errorf("%w: task status %s is not resumable", atlaserrors.ErrInvalidTransition, currentTask.Status))
        }</span>

        // Check for hook-based recovery context
        <span class="cov0" title="0">if shouldShowRecoveryContext(ctx, currentTask, out, outputFormat, logger) </span><span class="cov0" title="0">{
                proceed, recoveryErr := showRecoveryContextAndPrompt(ctx, currentTask, out, logger)
                if recoveryErr != nil </span><span class="cov0" title="0">{
                        logger.Warn().Err(recoveryErr).Msg("failed to show recovery context")
                }</span>
                <span class="cov0" title="0">if !proceed </span><span class="cov0" title="0">{
                        return nil, nil, nil, nil, atlaserrors.ErrOperationCanceled
                }</span>
        }

        // Ensure worktree exists
        <span class="cov0" title="0">ws, err = ensureWorktreeExists(ctx, ws, out, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, handleResumeError(outputFormat, w, workspaceName, currentTask.ID,
                        fmt.Errorf("failed to ensure worktree exists: %w", err))
        }</span>

        // Create workspace store and update status
        <span class="cov0" title="0">wsStore, wsStoreErr := workspace.NewFileStore("")
        if wsStoreErr != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(wsStoreErr).Msg("failed to create workspace store for status updates")
        }</span>

        <span class="cov0" title="0">ws.Status = constants.WorkspaceStatusActive
        if wsStore != nil </span><span class="cov0" title="0">{
                if updateErr := wsStore.Update(ctx, ws); updateErr != nil </span><span class="cov0" title="0">{
                        logger.Warn().Err(updateErr).
                                Str("workspace_name", ws.Name).
                                Msg("failed to update workspace status to active")
                }</span>
        }

        <span class="cov0" title="0">return ws, currentTask, taskStore, wsStore, nil</span>
}

// prepareResumeTemplate gets the template and checks AI fix option.
func prepareResumeTemplate(currentTask *domain.Task, opts resumeOptions, outputFormat string, w io.Writer, workspaceName string) (*domain.Template, error) <span class="cov0" title="0">{
        registry := template.NewDefaultRegistry()
        tmpl, err := registry.Get(currentTask.TemplateID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, handleResumeError(outputFormat, w, workspaceName, currentTask.ID, fmt.Errorf("failed to get template: %w", err))
        }</span>

        // Re-apply CLI overrides from original start command
        <span class="cov0" title="0">workflow.ApplyCLIOverridesFromTask(currentTask, tmpl)

        if opts.aiFix </span><span class="cov0" title="0">{
                return nil, handleResumeError(outputFormat, w, workspaceName, currentTask.ID,
                        fmt.Errorf("--ai-fix not yet implemented: %w", atlaserrors.ErrResumeNotImplemented))
        }</span>

        <span class="cov0" title="0">return tmpl, nil</span>
}

// executeResumeAndHandleResult executes the resume and handles the result/interruption.
// The state parameter contains the AI runner for process termination on interrupt.
func executeResumeAndHandleResult(ctx context.Context, engine *task.Engine, currentTask *domain.Task, tmpl *domain.Template, state *progressState, sigHandler *signal.Handler, out tui.Output, ws *domain.Workspace, wsStore workspace.Store, outputFormat string, w io.Writer, workspaceName string, logger zerolog.Logger) error <span class="cov0" title="0">{
        // Resume task execution
        if err := engine.Resume(ctx, currentTask, tmpl); err != nil </span><span class="cov0" title="0">{
                // Check if we were interrupted by Ctrl+C
                select </span>{
                case &lt;-sigHandler.Interrupted():<span class="cov0" title="0">
                        return handleResumeInterruption(ctx, out, ws, currentTask, state, wsStore, logger)</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">if currentTask.Status == constants.TaskStatusValidationFailed </span><span class="cov0" title="0">{
                        tui.DisplayManualFixInstructions(out, currentTask, ws)
                }</span>
                <span class="cov0" title="0">return handleResumeError(outputFormat, w, workspaceName, currentTask.ID, err)</span>
        }

        // Check if we were interrupted by Ctrl+C (even if no error)
        <span class="cov0" title="0">select </span>{
        case &lt;-sigHandler.Interrupted():<span class="cov0" title="0">
                return handleResumeInterruption(ctx, out, ws, currentTask, state, wsStore, logger)</span>
        default:<span class="cov0" title="0"></span>
        }

        // Handle JSON output format
        <span class="cov0" title="0">if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return outputResumeSuccessJSON(out, ws, currentTask)
        }</span>

        <span class="cov0" title="0">displayResumeResult(out, ws, currentTask, nil)
        return nil</span>
}

// isResumableStatus returns true if the task status allows resuming.
func isResumableStatus(status constants.TaskStatus) bool <span class="cov0" title="0">{
        return task.IsErrorStatus(status) || status == constants.TaskStatusAwaitingApproval
}</span>

// resumeResponse represents the JSON output for resume operations.
type resumeResponse struct {
        Success   bool          `json:"success"`
        Workspace workspaceInfo `json:"workspace"`
        Task      taskInfo      `json:"task"`
        Error     string        `json:"error,omitempty"`
}

// handleResumeError handles errors based on output format.
func handleResumeError(format string, w io.Writer, workspaceName, taskID string, err error) error <span class="cov0" title="0">{
        if format == OutputJSON </span><span class="cov0" title="0">{
                return outputResumeErrorJSON(w, workspaceName, taskID, err.Error())
        }</span>
        <span class="cov0" title="0">return err</span>
}

// outputResumeErrorJSON outputs an error result as JSON.
func outputResumeErrorJSON(w io.Writer, workspaceName, taskID, errMsg string) error <span class="cov0" title="0">{
        if err := encodeJSONIndented(w, resumeResponse{
                Success: false,
                Workspace: workspaceInfo{
                        Name: workspaceName,
                },
                Task: taskInfo{
                        ID: taskID,
                },
                Error: errMsg,
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return atlaserrors.ErrJSONErrorOutput</span>
}

// displayResumeResult outputs the resume result in the appropriate format.
func displayResumeResult(out tui.Output, ws *domain.Workspace, t *domain.Task, execErr error) <span class="cov0" title="0">{
        // TTY output
        out.Success(fmt.Sprintf("Task resumed successfully. Status: %s", t.Status))
        out.Info(fmt.Sprintf("  Workspace: %s", ws.Name))
        out.Info(fmt.Sprintf("  Task ID:   %s", t.ID))
        out.Info(fmt.Sprintf("  Progress:  Step %d/%d", t.CurrentStep+1, len(t.Steps)))

        if execErr != nil </span><span class="cov0" title="0">{
                out.Warning(fmt.Sprintf("Execution paused: %s", execErr.Error()))
        }</span>
}

// createResumeEngine creates the task engine with all required dependencies.
// Returns the engine and a progressState containing the AI runner for process termination.
func createResumeEngine(ctx context.Context, ws *domain.Workspace, taskStore *task.FileStore, currentTask *domain.Task, logger zerolog.Logger, out tui.Output) (*task.Engine, *progressState, error) <span class="cov0" title="0">{
        cfg, err := config.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("failed to load config, using default notification settings")
                cfg = config.DefaultConfig()
        }</span>

        // Create hook manager for resume (via service factory for consistency)
        <span class="cov0" title="0">services := workflow.NewServiceFactory(logger)
        hookManager := services.CreateHookManager(cfg, logger)

        notifier := tui.NewNotifier(cfg.Notifications.Bell, false)
        stateNotifier := task.NewStateChangeNotifier(task.NotificationConfig{
                BellEnabled: cfg.Notifications.Bell,
                Quiet:       false,
                Events:      cfg.Notifications.Events,
        })

        // Create shared progress state for activity and progress callbacks
        // This enables activity events to update the spinner inline
        state := &amp;progressState{}

        // Create activity options for AI execution (uses shared state)
        //nolint:contextcheck // git stats refresh uses background context intentionally
        activityOpts := createActivityOptions(cfg, state, ws.Name, logger)

        // Create AI runner with activity streaming
        aiRunner := services.CreateAIRunnerWithActivity(cfg, activityOpts)

        // Store runner in state for termination on interrupt
        state.aiRunner = aiRunner

        gitRunner, err := git.NewRunner(ctx, ws.WorktreePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create git runner: %w", err)
        }</span>

        // Create git stats provider for live status display
        <span class="cov0" title="0">state.gitStatsProvider = git.NewStatsProvider(ws.WorktreePath)

        // Resolve git config settings with fallbacks
        gitCfg := ResolveGitConfig(cfg)

        smartCommitter := git.NewSmartCommitRunner(gitRunner, ws.WorktreePath, aiRunner,
                git.WithAgent(gitCfg.CommitAgent),
                git.WithModel(gitCfg.CommitModel),
                git.WithTimeout(gitCfg.CommitTimeout),
                git.WithMaxRetries(gitCfg.CommitMaxRetries),
                git.WithRetryBackoffFactor(gitCfg.CommitBackoffFactor),
                git.WithLogger(logger),
        )
        pusher := git.NewPushRunner(gitRunner)
        hubRunner := git.NewCLIGitHubRunner(ws.WorktreePath)
        prDescGen := git.NewAIDescriptionGenerator(aiRunner,
                git.WithAIDescAgent(gitCfg.PRDescAgent),
                git.WithAIDescModel(gitCfg.PRDescModel),
                git.WithAIDescLogger(logger),
        )
        ciFailureHandler := task.NewCIFailureHandler(hubRunner)

        // Create progress callback for both engine and executors (uses shared state)
        progressCallback := createProgressCallback(ctx, out, ws.Name, state)

        // Create executor progress callback wrapper that handles both task.StepProgressEvent
        // and steps.AutoFixProgressEvent
        executorProgressCallback := func(event interface{}) </span><span class="cov0" title="0">{
                switch e := event.(type) </span>{
                case task.StepProgressEvent:<span class="cov0" title="0">
                        progressCallback(e)</span>
                case steps.AutoFixProgressEvent:<span class="cov0" title="0">
                        // Convert AutoFixProgressEvent to task.StepProgressEvent
                        progressCallback(task.StepProgressEvent{
                                Type:              e.Type,
                                TaskID:            e.TaskID,
                                WorkspaceName:     e.WorkspaceName,
                                Agent:             e.Agent,
                                Model:             e.Model,
                                Status:            e.Status,
                                DurationMs:        e.DurationMs,
                                NumTurns:          e.NumTurns,
                                FilesChangedCount: e.FilesChangedCount,
                        })</span>
                }
        }

        // Create validation progress callback for consistent step progress display (like start.go)
        <span class="cov0" title="0">validationProgressCallback := createValidationProgressAdapter(progressCallback, ws.Name, len(currentTask.Steps))

        // Create executor registry using service factory (same approach as start.go)
        execRegistry := services.CreateExecutorRegistry(workflow.RegistryDeps{
                WorkDir:   ws.WorktreePath,
                TaskStore: taskStore,
                Notifier:  notifier,
                AIRunner:  aiRunner,
                Logger:    logger,
                GitServices: &amp;workflow.GitServices{
                        Runner:           gitRunner,
                        SmartCommitter:   smartCommitter,
                        Pusher:           pusher,
                        HubRunner:        hubRunner,
                        PRDescGen:        prDescGen,
                        CIFailureHandler: ciFailureHandler,
                },
                Config:                     cfg,
                ProgressCallback:           executorProgressCallback,
                ValidationProgressCallback: validationProgressCallback,
        })

        validationRetryHandler := createResumeValidationRetryHandler(aiRunner, cfg, logger)

        engineCfg := task.DefaultEngineConfig()
        engineCfg.ProgressCallback = progressCallback
        engineOpts := []task.EngineOption{task.WithNotifier(stateNotifier)}
        if validationRetryHandler != nil </span><span class="cov0" title="0">{
                engineOpts = append(engineOpts, task.WithValidationRetryHandler(validationRetryHandler))
        }</span>
        <span class="cov0" title="0">if hookManager != nil </span><span class="cov0" title="0">{
                engineOpts = append(engineOpts, task.WithHookManager(hookManager))
        }</span>

        <span class="cov0" title="0">return task.NewEngine(taskStore, execRegistry, engineCfg, logger, engineOpts...), state, nil</span>
}

// handleResumeInterruption handles graceful shutdown when user presses Ctrl+C during resume.
// It saves the task and workspace state so the user can resume later.
// The state parameter contains the AI runner for process termination.
// The wsStore parameter allows dependency injection for testing - pass nil to skip persistence.
func handleResumeInterruption(ctx context.Context, out tui.Output, ws *domain.Workspace, t *domain.Task, state *progressState, wsStore workspace.Store, logger zerolog.Logger) error <span class="cov0" title="0">{
        logger.Info().
                Str("workspace_name", ws.Name).
                Str("task_id", t.ID).
                Msg("received interrupt signal during resume, initiating graceful shutdown")

        out.Warning("\n⚠ Interrupt received - saving state...")

        // Terminate any running AI process first to prevent orphaned processes
        terminateAIProcess(state, logger)

        // Use a context without cancellation for cleanup since the original is canceled
        cleanupCtx := context.WithoutCancel(ctx)

        // Save interrupted task state (reuse the function from start.go)
        saveInterruptedTaskState(cleanupCtx, ws, t, logger)

        // Update workspace to paused
        ws.Status = constants.WorkspaceStatusPaused

        // Persist workspace state if store is provided (allows nil for testing)
        if wsStore != nil </span><span class="cov0" title="0">{
                if updateErr := wsStore.Update(cleanupCtx, ws); updateErr != nil </span><span class="cov0" title="0">{
                        logger.Warn().Err(updateErr).
                                Str("workspace_name", ws.Name).
                                Msg("failed to persist workspace pause status")
                }</span>
        }

        // Display summary (reuse the function from start.go)
        <span class="cov0" title="0">displayInterruptionSummary(out, ws, t)

        return atlaserrors.ErrTaskInterrupted</span>
}

// displayResumeInfo displays information about the task being resumed.
func displayResumeInfo(out tui.Output, workspaceName string, currentTask *domain.Task) <span class="cov0" title="0">{
        out.Info(fmt.Sprintf("Resuming task in workspace '%s'...", workspaceName))
        out.Info(fmt.Sprintf("  Task ID: %s", currentTask.ID))
        out.Info(fmt.Sprintf("  Status: %s → running", currentTask.Status))
        out.Info(fmt.Sprintf("  Current Step: %d/%d", currentTask.CurrentStep+1, len(currentTask.Steps)))

        // Show specific message for interrupted tasks
        if currentTask.Status == constants.TaskStatusInterrupted </span><span class="cov0" title="0">{
                stepName := "unknown"
                if currentTask.CurrentStep &lt; len(currentTask.Steps) </span><span class="cov0" title="0">{
                        stepName = currentTask.Steps[currentTask.CurrentStep].Name
                }</span>
                <span class="cov0" title="0">out.Info(fmt.Sprintf("  Note: Task was interrupted by user, resuming from step %d (%s)", currentTask.CurrentStep+1, stepName))</span>
        }
}

// outputResumeSuccessJSON outputs a successful resume result as JSON.
func outputResumeSuccessJSON(out tui.Output, ws *domain.Workspace, currentTask *domain.Task) error <span class="cov0" title="0">{
        resp := resumeResponse{
                Success: true,
                Workspace: workspaceInfo{
                        Name:         ws.Name,
                        Branch:       ws.Branch,
                        WorktreePath: ws.WorktreePath,
                        Status:       string(ws.Status),
                },
                Task: taskInfo{
                        ID:           currentTask.ID,
                        TemplateName: currentTask.TemplateID,
                        Description:  currentTask.Description,
                        Status:       string(currentTask.Status),
                        CurrentStep:  currentTask.CurrentStep,
                        TotalSteps:   len(currentTask.Steps),
                },
        }
        return out.JSON(resp)
}</span>

// createResumeValidationRetryHandler creates the validation retry handler for automatic AI-assisted fixes.
func createResumeValidationRetryHandler(aiRunner ai.Runner, cfg *config.Config, logger zerolog.Logger) *validation.RetryHandler <span class="cov0" title="0">{
        if !cfg.Validation.AIRetryEnabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">executor := validation.NewExecutorWithRunner(validation.DefaultTimeout, &amp;validation.DefaultCommandRunner{})

        handler := validation.NewRetryHandlerFromConfig(
                aiRunner,
                executor,
                cfg.Validation.AIRetryEnabled,
                cfg.Validation.MaxAIRetryAttempts,
                logger,
        )

        // Set operations config for per-operation AI settings
        handler.SetOperationsConfig(&amp;cfg.Operations)

        return handler</span>
}

// ensureWorktreeExists checks if the workspace worktree exists and recreates it if missing.
// This handles the case where a task failed and the worktree was removed (e.g., due to a bug),
// but the branch still exists and can be recovered.
func ensureWorktreeExists(ctx context.Context, ws *domain.Workspace, out tui.Output, logger zerolog.Logger) (*domain.Workspace, error) <span class="cov0" title="0">{
        // Check if worktree path is set and exists
        if ws.WorktreePath != "" </span><span class="cov0" title="0">{
                if _, err := os.Stat(ws.WorktreePath); err == nil </span><span class="cov0" title="0">{
                        // Worktree exists, nothing to do
                        return ws, nil
                }</span>
        }

        // Worktree is missing - try to recreate it
        <span class="cov0" title="0">logger.Info().
                Str("workspace_name", ws.Name).
                Str("branch", ws.Branch).
                Msg("worktree missing, attempting to recreate")

        out.Warning("Worktree is missing. Attempting to recreate from branch...")

        // Get the main repo path (parent directory of expected worktree)
        repoPath, err := detectMainRepoPath(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to detect main repository: %w", err)
        }</span>

        // Check if branch exists
        <span class="cov0" title="0">branchExists := checkBranchExists(ctx, repoPath, ws.Branch)
        if !branchExists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %s", atlaserrors.ErrBranchNotFound, ws.Branch)
        }</span>

        // Calculate worktree path (sibling to main repo)
        <span class="cov0" title="0">worktreePath := calculateWorktreePath(repoPath, ws.Name)

        // Create worktree for existing branch
        if createErr := createWorktreeForBranch(ctx, repoPath, worktreePath, ws.Branch); createErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create worktree: %w", createErr)
        }</span>

        // Update workspace with new worktree path
        <span class="cov0" title="0">ws.WorktreePath = worktreePath
        ws.Status = constants.WorkspaceStatusActive

        // Save updated workspace
        wsStore, err := workspace.NewFileStore("")
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("failed to create workspace store for update")
        }</span> else<span class="cov0" title="0"> if updateErr := wsStore.Update(ctx, ws); updateErr != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(updateErr).Msg("failed to update workspace with new worktree path")
        }</span>

        <span class="cov0" title="0">out.Success(fmt.Sprintf("Worktree recreated at '%s'", worktreePath))
        logger.Info().
                Str("workspace_name", ws.Name).
                Str("worktree_path", worktreePath).
                Msg("worktree recreated successfully")

        return ws, nil</span>
}

// detectMainRepoPath finds the main repository path.
func detectMainRepoPath(ctx context.Context) (string, error) <span class="cov0" title="0">{
        // Start from current directory and find git repo root
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get current directory: %w", err)
        }</span>

        // Use git rev-parse to find repo root
        <span class="cov0" title="0">output, err := git.RunCommand(ctx, cwd, "rev-parse", "--show-toplevel")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return output, nil</span>
}

// checkBranchExists checks if a branch exists locally or on remote.
func checkBranchExists(ctx context.Context, repoPath, branchName string) bool <span class="cov0" title="0">{
        // Check local branch
        _, localErr := git.RunCommand(ctx, repoPath, "rev-parse", "--verify", branchName)
        if localErr == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check remote branch (try to fetch first)
        <span class="cov0" title="0">_, _ = git.RunCommand(ctx, repoPath, "fetch", "origin", branchName)
        _, remoteErr := git.RunCommand(ctx, repoPath, "rev-parse", "--verify", "origin/"+branchName)
        return remoteErr == nil</span>
}

// calculateWorktreePath calculates the worktree path as a sibling to the main repo.
func calculateWorktreePath(repoPath, workspaceName string) string <span class="cov0" title="0">{
        parentDir := filepath.Dir(repoPath)
        repoBaseName := filepath.Base(repoPath)
        return filepath.Join(parentDir, repoBaseName+"-"+workspaceName)
}</span>

// createWorktreeForBranch creates a worktree for an existing branch.
func createWorktreeForBranch(ctx context.Context, repoPath, worktreePath, branchName string) error <span class="cov0" title="0">{
        // Remove any existing directory at the worktree path
        if _, err := os.Stat(worktreePath); err == nil </span><span class="cov0" title="0">{
                if removeErr := os.RemoveAll(worktreePath); removeErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove existing directory at worktree path: %w", removeErr)
                }</span>
        }

        // Create worktree for existing branch (no -b flag)
        <span class="cov0" title="0">_, err := git.RunCommand(ctx, repoPath, "worktree", "add", worktreePath, branchName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// shouldShowRecoveryContext checks if hook-based recovery context should be displayed.
func shouldShowRecoveryContext(ctx context.Context, t *domain.Task, _ tui.Output, outputFormat string, _ zerolog.Logger) bool <span class="cov0" title="0">{
        // Skip for JSON output
        if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return false
        }</span>

        // Get base path for hook store
        <span class="cov0" title="0">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">baseDir := filepath.Join(homeDir, constants.AtlasHome)

        // Try to get the hook
        hookStore := hook.NewFileStore(baseDir)
        exists, _ := hookStore.Exists(ctx, t.ID)
        return exists</span>
}

// showRecoveryContextAndPrompt displays recovery context from hook and prompts for confirmation.
func showRecoveryContextAndPrompt(ctx context.Context, t *domain.Task, out tui.Output, _ zerolog.Logger) (bool, error) <span class="cov0" title="0">{
        // Get base path for hook store
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return true, err
        }</span>
        <span class="cov0" title="0">baseDir := filepath.Join(homeDir, constants.AtlasHome)

        // Get the hook
        hookStore := hook.NewFileStore(baseDir)
        h, err := hookStore.Get(ctx, t.ID)
        if err != nil </span><span class="cov0" title="0">{
                return true, err // Continue without hook context
        }</span>

        // Load config for stale threshold
        <span class="cov0" title="0">cfg, err := config.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                cfg = config.DefaultConfig()
        }</span>

        // Create recovery detector and get recommendation
        <span class="cov0" title="0">detector := hook.NewRecoveryDetector(&amp;cfg.Hooks)
        _ = detector.DiagnoseAndRecommend(ctx, h)

        // Display recovery context
        out.Info("")
        out.Info("Recovery Context (from HOOK.md):")
        out.Info(fmt.Sprintf("  State: %s", h.State))
        if h.CurrentStep != nil </span><span class="cov0" title="0">{
                out.Info(fmt.Sprintf("  Step: %s (index %d)", h.CurrentStep.StepName, h.CurrentStep.StepIndex+1))
                out.Info(fmt.Sprintf("  Attempt: %d/%d", h.CurrentStep.Attempt, h.CurrentStep.MaxAttempts))
        }</span>
        <span class="cov0" title="0">out.Info(fmt.Sprintf("  Checkpoints: %d", len(h.Checkpoints)))
        if h.Recovery != nil </span><span class="cov0" title="0">{
                out.Info(fmt.Sprintf("  Recommendation: %s", h.Recovery.RecommendedAction))
                out.Info(fmt.Sprintf("  Reason: %s", h.Recovery.Reason))
        }</span>
        <span class="cov0" title="0">out.Info("")

        // Prompt for confirmation
        var proceed bool
        err = huh.NewConfirm().
                Title("Continue with resume?").
                Affirmative("Yes").
                Negative("No").
                Value(&amp;proceed).
                Run()
        if err != nil </span><span class="cov0" title="0">{
                return true, err // On error (e.g., non-interactive), return error
        }</span>

        <span class="cov0" title="0">return proceed, nil</span>
}

// handleRecoveryMenu shows the interactive recovery menu and executes the chosen action with auto-resume.
// The state parameter contains the AI runner for process termination on interrupt.
func handleRecoveryMenu(ctx context.Context, _ *cobra.Command, out tui.Output, taskStore *task.FileStore, ws *domain.Workspace, t *domain.Task, engine *task.Engine, tmpl *domain.Template, state *progressState, sigHandler *signal.Handler, wsStore workspace.Store, outputFormat string, w io.Writer, workspaceName string, logger zerolog.Logger) error <span class="cov0" title="0">{
        // Load config for notification settings
        cfg, err := config.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("failed to load config, using default notification settings")
                cfg = config.DefaultConfig()
        }</span>
        <span class="cov0" title="0">notifier := tui.NewNotifier(cfg.Notifications.Bell, false)

        // Display error context
        displayRecoveryErrorContext(out, ws, t)

        // Action menu loop - view actions return to menu
        for </span><span class="cov0" title="0">{
                action, err := selectRecoveryAction(t)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, tui.ErrMenuCanceled) </span><span class="cov0" title="0">{
                                out.Info("Recovery canceled.")
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov0" title="0">done, autoResume, err := executeRecoveryActionWithResume(ctx, out, taskStore, ws, t, notifier, action)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if done </span><span class="cov0" title="0">{
                        // Check if we should auto-resume
                        if autoResume </span><span class="cov0" title="0">{
                                // Display info and prepare task for execution
                                displayResumeInfo(out, workspaceName, t)
                                if t.Metadata == nil </span><span class="cov0" title="0">{
                                        t.Metadata = make(map[string]any)
                                }</span>
                                <span class="cov0" title="0">t.Metadata["worktree_dir"] = ws.WorktreePath

                                // Auto-resume execution
                                out.Info("Auto-resuming task execution...")
                                return executeResumeAndHandleResult(ctx, engine, t, tmpl, state, sigHandler, out, ws, wsStore, outputFormat, w, workspaceName, logger)</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
                // Continue loop for view actions
        }
}

// displayRecoveryErrorContext shows the error state and relevant information before the recovery menu.
func displayRecoveryErrorContext(out tui.Output, ws *domain.Workspace, t *domain.Task) <span class="cov0" title="0">{
        out.Info("")
        out.Info(fmt.Sprintf("❌ Task failed: %s", t.Description))
        out.Info(fmt.Sprintf("   Workspace: %s", ws.Name))

        // Show which step failed
        if t.CurrentStep &lt; len(t.Steps) </span><span class="cov0" title="0">{
                stepName := t.Steps[t.CurrentStep].Name
                out.Info(fmt.Sprintf("   Failed at step %d/%d: %s", t.CurrentStep+1, len(t.Steps), stepName))
        }</span>

        <span class="cov0" title="0">out.Info(fmt.Sprintf("   Status: %s", tui.TaskStatusIcon(t.Status)+" "+string(t.Status)))

        displayStatusSpecificContext(out, t)

        out.Info("")
        out.Info("What would you like to do?")</span>
}

// displayStatusSpecificContext shows context specific to the task's error status.
func displayStatusSpecificContext(out tui.Output, t *domain.Task) <span class="cov0" title="0">{
        // Collect error message from step or metadata
        errMsg := getTaskErrorMessage(t)

        // Show error-specific context
        //nolint:exhaustive // Only showing context for specific error states
        switch t.Status </span>{
        case constants.TaskStatusValidationFailed:<span class="cov0" title="0">
                displayValidationContext(out, t)</span>
        case constants.TaskStatusGHFailed:<span class="cov0" title="0">
                // Error details may also be in metadata (fallback if step error is empty)
                if errMsg == "" </span><span class="cov0" title="0">{
                        errMsg = getMetadataError(t)
                }</span>
        case constants.TaskStatusCIFailed, constants.TaskStatusCITimeout:<span class="cov0" title="0">
                displayCIContext(out, t)</span>
        }

        // Display error message (truncate if too long)
        <span class="cov0" title="0">if errMsg != "" </span><span class="cov0" title="0">{
                if len(errMsg) &gt; 150 </span><span class="cov0" title="0">{
                        errMsg = errMsg[:150] + "..."
                }</span>
                <span class="cov0" title="0">out.Info(fmt.Sprintf("   Error: %s", errMsg))</span>
        }
}

// getTaskErrorMessage retrieves the error message from the current step.
func getTaskErrorMessage(t *domain.Task) string <span class="cov0" title="0">{
        if t.CurrentStep &lt; len(t.Steps) &amp;&amp; t.Steps[t.CurrentStep].Error != "" </span><span class="cov0" title="0">{
                return t.Steps[t.CurrentStep].Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// getMetadataError retrieves the error message from task metadata.
func getMetadataError(t *domain.Task) string <span class="cov0" title="0">{
        if t.Metadata != nil </span><span class="cov0" title="0">{
                if metaErr, ok := t.Metadata["error"].(string); ok </span><span class="cov0" title="0">{
                        return metaErr
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// displayValidationContext shows validation-specific error details.
func displayValidationContext(out tui.Output, t *domain.Task) <span class="cov0" title="0">{
        if t.Metadata != nil </span><span class="cov0" title="0">{
                if errCount, ok := t.Metadata["validation_error_count"].(int); ok </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("   Errors: %d validation failures", errCount))
                }</span>
        }
}

// displayCIContext shows CI-specific error details.
func displayCIContext(out tui.Output, t *domain.Task) <span class="cov0" title="0">{
        if t.Metadata != nil </span><span class="cov0" title="0">{
                if ciURL, ok := t.Metadata["ci_url"].(string); ok &amp;&amp; ciURL != "" </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("   CI Run: %s", ciURL))
                }</span>
        }
}

// selectRecoveryAction selects the appropriate recovery menu based on task state.
func selectRecoveryAction(t *domain.Task) (tui.RecoveryAction, error) <span class="cov0" title="0">{
        // For GH failed state, use step-aware recovery
        if t.Status == constants.TaskStatusGHFailed </span><span class="cov0" title="0">{
                return selectGHFailedRecovery(t)
        }</span>

        // Default: use standard recovery menu
        <span class="cov0" title="0">return tui.SelectErrorRecovery(t.Status)</span>
}

// getTaskStepName returns the current step name from the task, or empty string if unavailable.
func getTaskStepName(t *domain.Task) string <span class="cov0" title="0">{
        if t.CurrentStep &gt;= 0 &amp;&amp; t.CurrentStep &lt; len(t.Steps) </span><span class="cov0" title="0">{
                return t.Steps[t.CurrentStep].Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// selectGHFailedRecovery shows step-aware recovery options for gh_failed status.
func selectGHFailedRecovery(t *domain.Task) (tui.RecoveryAction, error) <span class="cov0" title="0">{
        // Get step name for context-aware options
        stepName := getTaskStepName(t)

        // Check for specific push error type (existing logic for rebase option)
        action, handled, err := trySelectPushErrorRecovery(t, stepName)
        if handled </span><span class="cov0" title="0">{
                return action, err
        }</span>

        // Use step-aware options and title
        <span class="cov0" title="0">options := tui.OptionsForGHFailedStep(stepName)
        baseOptions := make([]tui.Option, len(options))
        for i, opt := range options </span><span class="cov0" title="0">{
                baseOptions[i] = opt.Option
        }</span>

        <span class="cov0" title="0">title := tui.MenuTitleForGHFailedStep(stepName)
        selected, err := tui.Select(title, baseOptions)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return tui.RecoveryAction(selected), nil</span>
}

// trySelectPushErrorRecovery attempts to handle push-specific error recovery.
// Returns (action, handled, error) where handled indicates if push error was found.
func trySelectPushErrorRecovery(t *domain.Task, stepName string) (tui.RecoveryAction, bool, error) <span class="cov0" title="0">{
        if t.Metadata == nil </span><span class="cov0" title="0">{
                return "", false, nil
        }</span>

        <span class="cov0" title="0">pushErrorType, ok := t.Metadata["push_error_type"].(string)
        if !ok || pushErrorType == "" </span><span class="cov0" title="0">{
                return "", false, nil
        }</span>

        <span class="cov0" title="0">options := tui.GHFailedOptionsForPushError(pushErrorType)
        if len(options) == 0 </span><span class="cov0" title="0">{
                return "", false, nil
        }</span>

        <span class="cov0" title="0">baseOptions := make([]tui.Option, len(options))
        for i, opt := range options </span><span class="cov0" title="0">{
                baseOptions[i] = opt.Option
        }</span>

        // Use step-aware title even for push error type
        <span class="cov0" title="0">title := tui.MenuTitleForGHFailedStep(stepName)
        selected, err := tui.Select(title, baseOptions)
        if err != nil </span><span class="cov0" title="0">{
                return "", true, err
        }</span>

        <span class="cov0" title="0">return tui.RecoveryAction(selected), true, nil</span>
}

// executeRecoveryActionWithResume executes the selected recovery action.
// Returns (done, autoResume, error) where:
//   - done: true if action loop should exit
//   - autoResume: true if task should automatically resume execution after this action
//   - error: any error that occurred
func executeRecoveryActionWithResume(ctx context.Context, out tui.Output, taskStore *task.FileStore, ws *domain.Workspace, t *domain.Task, notifier *tui.Notifier, action tui.RecoveryAction) (bool, bool, error) <span class="cov0" title="0">{
        switch action </span>{
        case tui.RecoveryActionRetryAI, tui.RecoveryActionRetryGH, tui.RecoveryActionRetryCommit:<span class="cov0" title="0">
                err := handleRetryAction(ctx, out, taskStore, t, notifier)
                return true, err == nil, err</span>

        case tui.RecoveryActionRebaseRetry:<span class="cov0" title="0">
                err := handleRebaseRetry(ctx, out, taskStore, ws, t, notifier)
                return true, err == nil, err</span>

        case tui.RecoveryActionFixManually:<span class="cov0" title="0">
                err := handleFixManually(out, ws, notifier)
                return true, false, err</span> // No auto-resume for manual fix

        case tui.RecoveryActionViewErrors:<span class="cov0" title="0">
                err := handleViewErrors(ctx, out, taskStore, ws.Name, t.ID)
                return false, false, err</span> // Return to menu

        case tui.RecoveryActionViewLogs:<span class="cov0" title="0">
                err := handleViewLogs(ctx, out, ws, t)
                return false, false, err</span> // Return to menu

        case tui.RecoveryActionContinueWaiting:<span class="cov0" title="0">
                err := handleContinueWaiting(ctx, out, taskStore, t, notifier)
                return true, err == nil, err</span>

        case tui.RecoveryActionAbandon:<span class="cov0" title="0">
                err := handleAbandon(ctx, out, taskStore, ws, t, notifier)
                return true, false, err</span> // No auto-resume for abandon
        }

        <span class="cov0" title="0">return false, false, nil</span>
}

// handleRetryAction handles retry with AI fix actions.
func handleRetryAction(ctx context.Context, out tui.Output, taskStore *task.FileStore, t *domain.Task, notifier *tui.Notifier) error <span class="cov0" title="0">{
        // Transition task back to running
        if err := task.Transition(ctx, t, constants.TaskStatusRunning, "User requested retry from recovery menu"); err != nil </span><span class="cov0" title="0">{
                out.Error(tui.WrapWithSuggestion(fmt.Errorf("failed to transition task: %w", err)))
                return err
        }</span>

        // Save updated task
        <span class="cov0" title="0">if err := taskStore.Update(ctx, t.WorkspaceID, t); err != nil </span><span class="cov0" title="0">{
                out.Error(tui.WrapWithSuggestion(fmt.Errorf("failed to save task: %w", err)))
                return err
        }</span>

        <span class="cov0" title="0">out.Success("Retrying with AI fix...")
        notifier.Bell()
        return nil</span>
}

// handleFixManually shows worktree path and resume instructions.
//
//nolint:unparam // error return maintained for consistent interface with other handlers
func handleFixManually(out tui.Output, ws *domain.Workspace, notifier *tui.Notifier) error <span class="cov0" title="0">{
        out.Info("Fix the issue in the worktree manually:")
        out.Info("")
        if ws.WorktreePath != "" </span><span class="cov0" title="0">{
                out.Info(fmt.Sprintf("  cd %s", ws.WorktreePath))
        }</span> else<span class="cov0" title="0"> {
                out.Info(fmt.Sprintf("  cd &lt;worktree for %s&gt;", ws.Name))
        }</span>
        <span class="cov0" title="0">out.Info("  # Make your fixes")
        out.Info(fmt.Sprintf("  atlas resume %s", ws.Name))
        out.Info("")
        notifier.Bell()
        return nil</span>
}

// handleRebaseRetry handles the "Rebase and retry" action for non-fast-forward push failures.
func handleRebaseRetry(ctx context.Context, out tui.Output, taskStore *task.FileStore, ws *domain.Workspace, t *domain.Task, notifier *tui.Notifier) error <span class="cov0" title="0">{
        // Validate worktree path
        if ws.WorktreePath == "" </span><span class="cov0" title="0">{
                out.Error(tui.WrapWithSuggestion(fmt.Errorf("worktree path not available: %w", atlaserrors.ErrWorktreeNotFound)))
                return fmt.Errorf("worktree path not available: %w", atlaserrors.ErrWorktreeNotFound)
        }</span>

        // Get branch name
        <span class="cov0" title="0">branch := ws.Branch
        if branch == "" </span><span class="cov0" title="0">{
                out.Error(tui.WrapWithSuggestion(fmt.Errorf("branch name not available: %w", atlaserrors.ErrEmptyValue)))
                return fmt.Errorf("branch name not available: %w", atlaserrors.ErrEmptyValue)
        }</span>
        <span class="cov0" title="0">remote := "origin"

        // Create git runner for worktree
        runner, err := git.NewRunner(ctx, ws.WorktreePath)
        if err != nil </span><span class="cov0" title="0">{
                out.Error(tui.WrapWithSuggestion(fmt.Errorf("failed to create git runner: %w", err)))
                return err
        }</span>

        // Fetch latest from remote
        <span class="cov0" title="0">out.Info(fmt.Sprintf("Fetching latest from %s...", remote))
        if err := runner.Fetch(ctx, remote); err != nil </span><span class="cov0" title="0">{
                out.Error(tui.WrapWithSuggestion(fmt.Errorf("fetch failed: %w", err)))
                return err
        }</span>

        // Attempt rebase
        <span class="cov0" title="0">rebaseTarget := fmt.Sprintf("%s/%s", remote, branch)
        out.Info(fmt.Sprintf("Rebasing onto %s...", rebaseTarget))
        if err := runner.Rebase(ctx, rebaseTarget); err != nil </span><span class="cov0" title="0">{
                // Check for conflicts
                if errors.Is(err, atlaserrors.ErrRebaseConflict) </span><span class="cov0" title="0">{
                        // Abort the failed rebase
                        _ = runner.RebaseAbort(ctx)

                        out.Warning("Rebase has conflicts that require manual resolution:")
                        out.Info("")
                        out.Info(fmt.Sprintf("  cd %s", ws.WorktreePath))
                        out.Info(fmt.Sprintf("  git fetch %s", remote))
                        out.Info(fmt.Sprintf("  git rebase %s", rebaseTarget))
                        out.Info("  # Resolve conflicts in your editor")
                        out.Info("  git add &lt;resolved-files&gt;")
                        out.Info("  git rebase --continue")
                        out.Info(fmt.Sprintf("  atlas resume %s", ws.Name))
                        out.Info("")
                        notifier.Bell()
                        return nil // Don't auto-resume, user needs to fix conflicts
                }</span>

                <span class="cov0" title="0">out.Error(tui.WrapWithSuggestion(fmt.Errorf("rebase failed: %w", err)))
                return err</span>
        }

        // Rebase succeeded, transition task back to running
        <span class="cov0" title="0">if err := task.Transition(ctx, t, constants.TaskStatusRunning, "Rebased and retrying push"); err != nil </span><span class="cov0" title="0">{
                out.Error(tui.WrapWithSuggestion(fmt.Errorf("failed to transition task: %w", err)))
                return err
        }</span>

        // Save updated task
        <span class="cov0" title="0">if err := taskStore.Update(ctx, t.WorkspaceID, t); err != nil </span><span class="cov0" title="0">{
                out.Error(tui.WrapWithSuggestion(fmt.Errorf("failed to save task: %w", err)))
                return err
        }</span>

        <span class="cov0" title="0">out.Success("Rebase successful. Auto-resuming execution...")
        notifier.Bell()
        return nil</span>
}

// handleViewErrors displays the validation errors.
//
//nolint:unparam // error return maintained for consistent interface with other handlers
func handleViewErrors(ctx context.Context, out tui.Output, taskStore *task.FileStore, workspaceName, taskID string) error <span class="cov0" title="0">{
        // Try to get validation artifact
        data, err := taskStore.GetArtifact(ctx, workspaceName, taskID, "validation.json")
        if err != nil </span><span class="cov0" title="0">{
                // Try alternate filename
                data, err = taskStore.GetArtifact(ctx, workspaceName, taskID, "validation-result.json")
                if err != nil </span><span class="cov0" title="0">{
                        out.Warning(fmt.Sprintf("Could not load validation results: %v", err))
                        return nil
                }</span>
        }

        <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                out.Info("No validation errors recorded.")
                return nil
        }</span>

        // Display the validation output
        <span class="cov0" title="0">out.Info("")
        out.Info("--- Validation Output ---")
        out.Info(string(data))
        out.Info("-------------------------")
        out.Info("")

        return nil</span>
}

// handleViewLogs opens GitHub Actions in browser for CI states.
//
//nolint:unparam // error return maintained for consistent interface with other handlers
func handleViewLogs(ctx context.Context, out tui.Output, ws *domain.Workspace, t *domain.Task) error <span class="cov0" title="0">{
        // Extract GitHub Actions URL from task metadata or PR URL
        ghURL := extractGitHubActionsURL(t)
        if ghURL == "" </span><span class="cov0" title="0">{
                // Fall back to PR URL if available
                prURL := extractPRURL(t)
                if prURL != "" </span><span class="cov0" title="0">{
                        ghURL = prURL + "/checks"
                }</span>
        }

        <span class="cov0" title="0">if ghURL == "" </span><span class="cov0" title="0">{
                out.Warning("No GitHub Actions URL available.")
                out.Info(fmt.Sprintf("You can manually check: https://github.com/%s/actions", extractRepoInfo(ws)))
                return nil
        }</span>

        // Open in browser
        <span class="cov0" title="0">if err := openInBrowser(ctx, ghURL); err != nil </span><span class="cov0" title="0">{
                out.Warning(fmt.Sprintf("Could not open browser: %v", err))
                out.Info(fmt.Sprintf("URL: %s", ghURL))
        }</span> else<span class="cov0" title="0"> {
                out.Info(fmt.Sprintf("Opened %s in browser.", ghURL))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleContinueWaiting resumes CI polling.
func handleContinueWaiting(ctx context.Context, out tui.Output, taskStore *task.FileStore, t *domain.Task, notifier *tui.Notifier) error <span class="cov0" title="0">{
        // Transition task back to running to continue CI polling
        if err := task.Transition(ctx, t, constants.TaskStatusRunning, "User requested to continue waiting"); err != nil </span><span class="cov0" title="0">{
                out.Error(tui.WrapWithSuggestion(fmt.Errorf("failed to transition task: %w", err)))
                return err
        }</span>

        // Save updated task
        <span class="cov0" title="0">if err := taskStore.Update(ctx, t.WorkspaceID, t); err != nil </span><span class="cov0" title="0">{
                out.Error(tui.WrapWithSuggestion(fmt.Errorf("failed to save task: %w", err)))
                return err
        }</span>

        <span class="cov0" title="0">out.Success("Continuing CI polling. Auto-resuming execution...")
        notifier.Bell()
        return nil</span>
}

// handleAbandon transitions task to abandoned state.
func handleAbandon(ctx context.Context, out tui.Output, taskStore *task.FileStore, ws *domain.Workspace, t *domain.Task, notifier *tui.Notifier) error <span class="cov0" title="0">{
        // Transition task to abandoned
        if err := task.Transition(ctx, t, constants.TaskStatusAbandoned, "User abandoned from recovery menu"); err != nil </span><span class="cov0" title="0">{
                out.Error(tui.WrapWithSuggestion(fmt.Errorf("failed to transition task: %w", err)))
                return err
        }</span>

        // Save updated task
        <span class="cov0" title="0">if err := taskStore.Update(ctx, t.WorkspaceID, t); err != nil </span><span class="cov0" title="0">{
                out.Error(tui.WrapWithSuggestion(fmt.Errorf("failed to save task: %w", err)))
                return err
        }</span>

        <span class="cov0" title="0">out.Info(fmt.Sprintf("Task abandoned. Branch '%s' preserved at '%s'", ws.Branch, ws.WorktreePath))
        out.Info("You can work on the code manually or destroy the workspace later.")
        notifier.Bell()
        return nil</span>
}

// extractGitHubActionsURL extracts the GitHub Actions URL from task metadata.
func extractGitHubActionsURL(t *domain.Task) string <span class="cov0" title="0">{
        if t == nil || t.Metadata == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if url, ok := t.Metadata["ci_url"].(string); ok </span><span class="cov0" title="0">{
                return url
        }</span>
        <span class="cov0" title="0">if url, ok := t.Metadata["github_actions_url"].(string); ok </span><span class="cov0" title="0">{
                return url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// extractRepoInfo extracts repository info from workspace for manual URL construction.
func extractRepoInfo(ws *domain.Workspace) string <span class="cov0" title="0">{
        if ws == nil || ws.Metadata == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if repo, ok := ws.Metadata["repository"].(string); ok </span><span class="cov0" title="0">{
                return repo
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>

		<pre class="file" id="file27" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "fmt"
        "sync"

        "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/rs/zerolog"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// BuildInfo contains version information set at build time via ldflags.
type BuildInfo struct {
        // Version is the semantic version (e.g., "1.0.0").
        Version string
        // Commit is the git commit hash.
        Commit string
        // Date is the build date.
        Date string
}

// globalLogger stores the initialized logger for use by subcommands.
// This is set during PersistentPreRunE and should be accessed via Logger.
// This is a necessary global for CLI logger access across command handlers.
// Access is protected by globalLoggerMu for thread safety.
var (
        globalLogger   zerolog.Logger //nolint:gochecknoglobals // CLI logger requires global access
        globalLoggerMu sync.RWMutex   //nolint:gochecknoglobals // Protects globalLogger

        // globalLogFlags stores the verbose/quiet flags used to initialize the logger.
        // These are needed to create task-specific loggers with the same settings.
        globalLogFlags struct { //nolint:gochecknoglobals // CLI flags require global access
                verbose bool
                quiet   bool
        }
)

// Logger returns the initialized logger for use by subcommands.
//
// IMPORTANT: This function MUST only be called after the root command's
// PersistentPreRunE has executed. Calling it before initialization will
// return a zero-value logger that discards all log output.
//
// This function is safe for concurrent use.
//
// Typical usage is within a subcommand's Run/RunE function:
//
//        RunE: func(cmd *cobra.Command, args []string) error {
//            logger := cli.Logger()
//            logger.Info().Msg("executing command")
//            ...
//        }
func Logger() zerolog.Logger <span class="cov8" title="1">{
        globalLoggerMu.RLock()
        defer globalLoggerMu.RUnlock()
        return globalLogger
}</span>

// LoggerWithTaskStore returns a logger configured to persist task-specific logs.
// Log entries containing workspace_name and task_id fields will be written to
// the task's log file in addition to the console and global log.
//
// This function is safe for concurrent use.
func LoggerWithTaskStore(store TaskLogAppender) zerolog.Logger <span class="cov0" title="0">{
        // Read the global flags with lock protection
        globalLoggerMu.RLock()
        verbose := globalLogFlags.verbose
        quiet := globalLogFlags.quiet
        globalLoggerMu.RUnlock()

        // Call InitLoggerWithTaskStore without holding the lock to avoid deadlock
        return InitLoggerWithTaskStore(verbose, quiet, store)
}</span>

// newRootCmd creates and returns the root command for the atlas CLI.
// This function-based approach avoids package-level globals, making the
// code more testable and avoiding gochecknoglobals linter warnings.
func newRootCmd(flags *GlobalFlags, info BuildInfo) *cobra.Command <span class="cov0" title="0">{
        v := viper.New()

        cmd := &amp;cobra.Command{
                Use:     "atlas",
                Short:   "ATLAS - AI Task Lifecycle Automation System",
                Long:    tui.RenderHeaderAuto(),
                Version: formatVersion(info),
                // Run displays help when the root command is invoked without subcommands.
                // This ensures PersistentPreRunE is called for flag validation.
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return cmd.Help()
                }</span>,
                PersistentPreRunE: func(cmd *cobra.Command, _ []string) error <span class="cov0" title="0">{
                        // Bind flags to Viper
                        if err := BindGlobalFlags(v, cmd); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to bind flags: %w", err)
                        }</span>

                        // Validate output format
                        <span class="cov0" title="0">if !IsValidOutputFormat(flags.Output) </span><span class="cov0" title="0">{
                                return fmt.Errorf("%w: %q must be one of %v", errors.ErrInvalidOutputFormat, flags.Output, ValidOutputFormats())
                        }</span>

                        // Initialize logger based on flags (protected by mutex for thread safety)
                        <span class="cov0" title="0">globalLoggerMu.Lock()
                        globalLogger = InitLogger(flags.Verbose, flags.Quiet)
                        globalLogFlags.verbose = flags.Verbose
                        globalLogFlags.quiet = flags.Quiet
                        logger := globalLogger // Get a copy while holding the lock
                        globalLoggerMu.Unlock()

                        // Log verbose mode status (only visible when verbose is enabled)
                        if flags.Verbose </span><span class="cov0" title="0">{
                                logger.Debug().Msg("verbose mode enabled")
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
                // SilenceUsage prevents printing usage on error
                // (we handle our own error messages)
                SilenceUsage: true,
        }

        // Add global flags
        <span class="cov0" title="0">AddGlobalFlags(cmd, flags)

        // Add subcommands
        AddInitCommand(cmd)
        AddConfigCommand(cmd)
        AddUpgradeCommand(cmd)
        AddWorkspaceCommand(cmd)
        AddStartCommand(cmd)
        AddStatusCommand(cmd)
        AddResumeCommand(cmd)
        AddAbandonCommand(cmd)
        AddValidateCommand(cmd)
        AddFormatCommand(cmd)
        AddLintCommand(cmd)
        AddTestCommand(cmd)
        AddApproveCommand(cmd)
        AddRejectCommand(cmd)
        AddCompletionCommand(cmd)
        AddHookCommand(cmd)
        AddCheckpointCommand(cmd)
        AddCleanupCommand(cmd)
        AddBacklogCommand(cmd)

        return cmd</span>
}

// formatVersion creates the version string from build info.
func formatVersion(info BuildInfo) string <span class="cov0" title="0">{
        if info.Version == "" </span><span class="cov0" title="0">{
                info.Version = "dev"
        }</span>
        <span class="cov0" title="0">if info.Commit == "" </span><span class="cov0" title="0">{
                info.Commit = "none"
        }</span>
        <span class="cov0" title="0">if info.Date == "" </span><span class="cov0" title="0">{
                info.Date = "unknown"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s (commit: %s, built: %s)", info.Version, info.Commit, info.Date)</span>
}

// Execute runs the root command with the provided context and build info.
func Execute(ctx context.Context, info BuildInfo) error <span class="cov0" title="0">{
        flags := &amp;GlobalFlags{}
        //nolint:contextcheck // Cobra command pattern uses cmd.Context() internally
        cmd := newRootCmd(flags, info)
        return cmd.ExecuteContext(ctx)
}</span>
</pre>

		<pre class="file" id="file28" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/mrz1836/atlas/internal/ai"
        "github.com/mrz1836/atlas/internal/backlog"
        "github.com/mrz1836/atlas/internal/cli/workflow"
        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/domain"
        atlaserrors "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/git"
        "github.com/mrz1836/atlas/internal/signal"
        "github.com/mrz1836/atlas/internal/task"
        "github.com/mrz1836/atlas/internal/template"
        "github.com/mrz1836/atlas/internal/template/steps"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/validation"
        "github.com/mrz1836/atlas/internal/workspace"
        "github.com/rs/zerolog"
        "github.com/spf13/cobra"
)

// AddStartCommand adds the start command to the root command.
func AddStartCommand(root *cobra.Command) <span class="cov0" title="0">{
        root.AddCommand(newStartCmd())
}</span>

// startOptions contains all options for the start command.
type startOptions struct {
        templateName  string
        workspaceName string
        agent         string
        model         string
        baseBranch    string
        targetBranch  string // Existing branch to checkout (mutually exclusive with baseBranch)
        useLocal      bool
        noInteractive bool
        verify        bool
        noVerify      bool
        dryRun        bool
        fromBacklogID string // Discovery ID to link and promote after task creation
}

// newStartCmd creates the start command.
func newStartCmd() *cobra.Command <span class="cov0" title="0">{
        var (
                templateName  string
                workspaceName string
                agent         string
                model         string
                baseBranch    string
                targetBranch  string
                useLocal      bool
                noInteractive bool
                verify        bool
                noVerify      bool
                dryRun        bool
                fromBacklogID string
        )

        cmd := &amp;cobra.Command{
                Use:   "start &lt;description&gt;",
                Short: "Start a new task with the given description",
                Long: `Start a new task by creating a workspace, selecting a template,
and beginning execution of the template steps.

Examples:
  atlas start "fix null pointer in parseConfig"
  atlas start "add retry logic to HTTP client" --template feature
  atlas start "update dependencies" --workspace deps-update --template commit
  atlas start "add new feature" --template feature --verify
  atlas start "quick fix" --template bugfix --no-verify
  atlas start "fix from develop" --template bugfix --branch develop
  atlas start "review changes" --template bugfix --dry-run
  atlas start "fix lint errors" --template hotfix --target feat/my-feature`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return runStart(cmd.Context(), cmd, cmd.OutOrStdout(), args[0], startOptions{
                                templateName:  templateName,
                                workspaceName: workspaceName,
                                agent:         agent,
                                model:         model,
                                baseBranch:    baseBranch,
                                targetBranch:  targetBranch,
                                useLocal:      useLocal,
                                noInteractive: noInteractive,
                                verify:        verify,
                                noVerify:      noVerify,
                                dryRun:        dryRun,
                                fromBacklogID: fromBacklogID,
                        })
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().StringVarP(&amp;templateName, "template", "t", "",
                "Template to use (bugfix, feature, commit, hotfix)")
        cmd.Flags().StringVarP(&amp;workspaceName, "workspace", "w", "",
                "Custom workspace name")
        cmd.Flags().StringVarP(&amp;agent, "agent", "a", "",
                "AI agent/CLI to use (claude, gemini, codex)")
        cmd.Flags().StringVarP(&amp;model, "model", "m", "",
                "AI model to use (claude: sonnet, opus, haiku; gemini: flash, pro; codex: codex, max, mini)")
        cmd.Flags().StringVarP(&amp;baseBranch, "branch", "b", "",
                "Base branch to create workspace from (fetches from remote by default)")
        cmd.Flags().StringVar(&amp;targetBranch, "target", "",
                "Existing branch to checkout and work on (skips new branch creation, mutually exclusive with --branch)")
        cmd.Flags().BoolVar(&amp;useLocal, "use-local", false,
                "Prefer local branch over remote when both exist")
        cmd.Flags().BoolVar(&amp;noInteractive, "no-interactive", false,
                "Disable interactive prompts")
        cmd.Flags().BoolVar(&amp;verify, "verify", false,
                "Enable AI verification step (cross-model validation)")
        cmd.Flags().BoolVar(&amp;noVerify, "no-verify", false,
                "Disable AI verification step")
        cmd.Flags().BoolVar(&amp;dryRun, "dry-run", false,
                "Show what would happen without making changes")
        cmd.Flags().StringVar(&amp;fromBacklogID, "from-backlog", "",
                "Link this task to a backlog discovery (auto-promotes the discovery)")

        return cmd</span>
}

// startContext holds shared state for the start command execution.
type startContext struct {
        ctx          context.Context //nolint:containedctx // context needed for error handling
        outputFormat string
        out          tui.Output
        w            io.Writer
}

// runStart executes the start command.
func runStart(ctx context.Context, cmd *cobra.Command, w io.Writer, description string, opts startOptions) error <span class="cov0" title="0">{
        // Check context cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        // Create signal handler for graceful shutdown on Ctrl+C
        <span class="cov0" title="0">sigHandler := signal.NewHandler(ctx)
        defer sigHandler.Stop()
        ctx = sigHandler.Context()

        logger := Logger()
        outputFormat := cmd.Flag("output").Value.String()

        // Respect NO_COLOR environment variable
        tui.CheckNoColor()

        out := tui.NewOutput(w, outputFormat)
        sc := &amp;startContext{
                ctx:          ctx,
                outputFormat: outputFormat,
                out:          out,
                w:            w,
        }

        // Validate CLI flags
        if err := validateStartOptions(opts, sc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Setup orchestrator and find repository
        <span class="cov0" title="0">orchestrator := workflow.NewOrchestrator(logger, out)
        repoPath, err := orchestrator.Initializer().FindGitRepository(ctx) //nolint:contextcheck // context is properly checked and used
        if err != nil </span><span class="cov0" title="0">{
                return sc.handleError("", fmt.Errorf("not in a git repository: %w", err))
        }</span>
        <span class="cov0" title="0">logger.Debug().Str("repo_path", repoPath).Msg("found git repository")

        // Load config and template
        cfg, tmpl, wsName, err := setupConfigAndTemplate(ctx, sc, logger, orchestrator, repoPath, description, opts) //nolint:contextcheck // context is properly checked and used
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Handle dry-run mode early
        <span class="cov0" title="0">if opts.dryRun </span><span class="cov0" title="0">{
                return runDryRun(ctx, sc, tmpl, description, wsName, cfg, logger) //nolint:contextcheck // context is properly checked and used
        }</span>

        // Create workspace and execute task
        <span class="cov0" title="0">return executeTask(ctx, sc, sigHandler, orchestrator, repoPath, outputFormat, tmpl, description, wsName, opts, logger, out)</span> //nolint:contextcheck // context is properly checked and used
}

// validateStartOptions validates all CLI option flags.
func validateStartOptions(opts startOptions, sc *startContext) error <span class="cov0" title="0">{
        // Validate agent flag if provided
        if err := validateAgent(opts.agent); err != nil </span><span class="cov0" title="0">{
                return sc.handleError("", err)
        }</span>

        // Validate model flag if provided
        <span class="cov0" title="0">if err := validateModel(opts.agent, opts.model); err != nil </span><span class="cov0" title="0">{
                return sc.handleError("", err)
        }</span>

        // Validate verify flags - cannot use both
        <span class="cov0" title="0">if opts.verify &amp;&amp; opts.noVerify </span><span class="cov0" title="0">{
                return sc.handleError("", atlaserrors.NewExitCode2Error(
                        fmt.Errorf("%w: cannot use both --verify and --no-verify", atlaserrors.ErrConflictingFlags)))
        }</span>

        // Validate branch flags - cannot use both --branch and --target
        <span class="cov0" title="0">if opts.baseBranch != "" &amp;&amp; opts.targetBranch != "" </span><span class="cov0" title="0">{
                return sc.handleError("", atlaserrors.NewExitCode2Error(
                        fmt.Errorf("%w: cannot use both --branch and --target", atlaserrors.ErrConflictingFlags)))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// setupConfigAndTemplate loads config, template registry, and selects template.
func setupConfigAndTemplate(ctx context.Context, sc *startContext, logger zerolog.Logger, orchestrator *workflow.Orchestrator, repoPath, description string, opts startOptions) (*config.Config, *domain.Template, string, error) <span class="cov0" title="0">{
        // Load config for custom templates
        cfg, cfgErr := config.Load(ctx)
        if cfgErr != nil </span><span class="cov0" title="0">{
                // Log warning but continue with defaults - don't fail task start for config issues
                logger.Error().Err(cfgErr).
                        Str("project_config", config.ProjectConfigPath()).
                        Msg("failed to load project config - falling back to defaults")
                cfg = config.DefaultConfig()
        }</span>

        <span class="cov0" title="0">if cfgErr == nil </span><span class="cov0" title="0">{
                logConfigSources(cfg, logger)
        }</span>

        // Load template registry with custom templates from config
        <span class="cov0" title="0">registry, err := template.NewRegistryWithConfig(repoPath, cfg.Templates.CustomTemplates)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, "", sc.handleError("", fmt.Errorf("failed to load templates: %w", err))
        }</span>

        // Select template
        <span class="cov0" title="0">tmpl, err := orchestrator.Prompter().SelectTemplate(ctx, registry, opts.templateName, opts.noInteractive, sc.outputFormat)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, "", sc.handleError("", err)
        }</span>

        <span class="cov0" title="0">logger.Debug().
                Str("template_name", tmpl.Name).
                Msg("template selected")

        // Determine workspace name
        wsName := opts.workspaceName
        if wsName == "" </span><span class="cov0" title="0">{
                wsName = workflow.GenerateWorkspaceName(description)
        }</span> else<span class="cov0" title="0"> {
                wsName = workflow.SanitizeWorkspaceName(wsName)
        }</span>

        // Apply verify flag overrides to template (needed for dry-run too)
        <span class="cov0" title="0">workflow.ApplyVerifyOverrides(tmpl, opts.verify, opts.noVerify)

        return cfg, tmpl, wsName, nil</span>
}

// executeTask creates workspace and executes the task.
func executeTask(ctx context.Context, sc *startContext, sigHandler *signal.Handler, orchestrator *workflow.Orchestrator, repoPath, outputFormat string, tmpl *domain.Template, description, wsName string, opts startOptions, logger zerolog.Logger, out tui.Output) error <span class="cov0" title="0">{
        // Create and configure workspace
        ws, err := orchestrator.Initializer().CreateWorkspace(ctx, workflow.WorkspaceOptions{
                Name:          wsName,
                RepoPath:      repoPath,
                BranchPrefix:  tmpl.BranchPrefix,
                BaseBranch:    opts.baseBranch,
                TargetBranch:  opts.targetBranch,
                UseLocal:      opts.useLocal,
                NoInteractive: opts.noInteractive,
                OutputFormat:  outputFormat,
                ErrorHandler:  sc.handleError,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create workspace: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info().
                Str("workspace_name", ws.Name).
                Str("branch", ws.Branch).
                Str("worktree_path", ws.WorktreePath).
                Msg("workspace created")

        // Start task execution
        t, taskStore, state, err := startTaskExecution(ctx, ws, tmpl, description, opts.agent, opts.model, opts.fromBacklogID, logger, out)

        // Store CLI overrides in task metadata for resume (if task was created)
        storeCLIOverridesIfNeeded(ctx, t, taskStore, ws.Name, &amp;opts, logger)

        // Check if we were interrupted by Ctrl+C
        select </span>{
        case &lt;-sigHandler.Interrupted():<span class="cov0" title="0">
                return handleInterruption(ctx, sc, ws, t, state, logger, out)</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                sc.handleTaskStartError(ctx, ws, repoPath, t, logger)
                if t != nil </span><span class="cov0" title="0">{
                        return displayTaskStatus(out, outputFormat, ws, t, err)
                }</span>
                <span class="cov0" title="0">return sc.handleError(wsName, fmt.Errorf("failed to start task: %w", err))</span>
        }

        <span class="cov0" title="0">logger.Info().
                Str("task_id", t.ID).
                Str("workspace_name", ws.Name).
                Str("template_name", tmpl.Name).
                Int("total_steps", len(t.Steps)).
                Msg("task started")

        return displayTaskStatus(out, outputFormat, ws, t, nil)</span>
}

// logConfigSources logs which config sources were loaded and key metrics.
func logConfigSources(cfg *config.Config, logger zerolog.Logger) <span class="cov0" title="0">{
        // Determine which config files were loaded
        var sources []string
        var globalPathErr error
        var globalPath string
        globalPath, globalPathErr = config.GlobalConfigPath()
        if globalPathErr == nil </span><span class="cov0" title="0">{
                if _, statErr := os.Stat(globalPath); statErr == nil </span><span class="cov0" title="0">{
                        sources = append(sources, "global")
                }</span>
        }
        <span class="cov0" title="0">projectPath := config.ProjectConfigPath()
        if _, statErr := os.Stat(projectPath); statErr == nil </span><span class="cov0" title="0">{
                sources = append(sources, "project")
        }</span>
        <span class="cov0" title="0">if len(sources) == 0 </span><span class="cov0" title="0">{
                sources = []string{"defaults"}
        }</span>

        // Count validation commands
        <span class="cov0" title="0">validationCmds := len(cfg.Validation.Commands.Format) +
                len(cfg.Validation.Commands.Lint) +
                len(cfg.Validation.Commands.Test) +
                len(cfg.Validation.Commands.PreCommit) +
                len(cfg.Validation.Commands.CustomPrePR)

        // Log with sources and key metrics
        logger.Debug().
                Str("sources", strings.Join(sources, ",")).
                Str("agent", cfg.AI.Agent).
                Str("model", cfg.AI.Model).
                Int("custom_templates", len(cfg.Templates.CustomTemplates)).
                Int("required_workflows", len(cfg.CI.RequiredWorkflows)).
                Int("validation_cmds", validationCmds).
                Msg("config loaded")</span>
}

// handleError handles errors based on output format.
func (sc *startContext) handleError(wsName string, err error) error <span class="cov0" title="0">{
        if sc.outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return outputStartErrorJSON(sc.w, wsName, "", err.Error())
        }</span>
        <span class="cov0" title="0">return err</span>
}

// handleTaskStartError handles cleanup when task execution fails.
// Only cleans up workspace if the task was never created (t == nil).
// If the task exists, the workspace must be preserved for investigation and resume.
func (sc *startContext) handleTaskStartError(ctx context.Context, ws *domain.Workspace, repoPath string, t *domain.Task, logger zerolog.Logger) <span class="cov0" title="0">{
        // If task was created, workspace should be preserved for resume
        if t != nil </span><span class="cov0" title="0">{
                logger.Debug().
                        Str("workspace_name", ws.Name).
                        Str("task_id", t.ID).
                        Str("task_status", string(t.Status)).
                        Msg("preserving workspace for resume (task exists)")

                sc.updateWorkspaceStatusToPaused(ctx, ws, logger)
                return
        }</span>

        // Only cleanup if task creation failed entirely (no task to preserve)
        <span class="cov0" title="0">logger.Debug().
                Str("workspace_name", ws.Name).
                Msg("task was never created, destroying workspace")
        cleanupErr := cleanupWorkspace(ctx, ws.Name, repoPath)
        if cleanupErr != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(cleanupErr).
                        Str("workspace_name", ws.Name).
                        Msg("failed to cleanup workspace after task creation failure")
        }</span>
}

// updateWorkspaceStatusToPaused updates the workspace status to paused to preserve it for resume.
func (sc *startContext) updateWorkspaceStatusToPaused(ctx context.Context, ws *domain.Workspace, logger zerolog.Logger) <span class="cov0" title="0">{
        ws.Status = constants.WorkspaceStatusPaused
        wsStore, err := workspace.NewFileStore("")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).
                        Str("workspace_name", ws.Name).
                        Msg("CRITICAL: failed to create workspace store for pause update - workspace may not be resumable")
                return
        }</span>

        <span class="cov0" title="0">updateErr := wsStore.Update(ctx, ws)
        if updateErr != nil </span><span class="cov0" title="0">{
                logger.Error().Err(updateErr).
                        Str("workspace_name", ws.Name).
                        Msg("CRITICAL: failed to persist workspace pause status - workspace may not be resumable")
                return
        }</span>

        <span class="cov0" title="0">logger.Debug().
                Str("workspace_name", ws.Name).
                Str("workspace_status", string(ws.Status)).
                Msg("workspace status updated to paused for resume")

        // Verify worktree still exists after pause to detect race conditions
        if ws.WorktreePath != "" </span><span class="cov0" title="0">{
                if _, statErr := os.Stat(ws.WorktreePath); os.IsNotExist(statErr) </span><span class="cov0" title="0">{
                        logger.Error().
                                Str("workspace_name", ws.Name).
                                Str("worktree_path", ws.WorktreePath).
                                Msg("CRITICAL: worktree directory missing after pause - possible race condition or external deletion")
                }</span>
        }
}

// storeCLIOverridesIfNeeded stores CLI overrides and backlog metadata in the task if present.
func storeCLIOverridesIfNeeded(ctx context.Context, t *domain.Task, taskStore *task.FileStore, workspaceName string, opts *startOptions, logger zerolog.Logger) <span class="cov0" title="0">{
        if t == nil || taskStore == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">workflow.StoreCLIOverrides(t, opts.verify, opts.noVerify, opts.agent, opts.model)

        // Store backlog discovery ID in metadata so approve can complete it
        if opts.fromBacklogID != "" </span><span class="cov0" title="0">{
                if t.Metadata == nil </span><span class="cov0" title="0">{
                        t.Metadata = make(map[string]any)
                }</span>
                <span class="cov0" title="0">t.Metadata["from_backlog_id"] = opts.fromBacklogID</span>
        }

        <span class="cov0" title="0">if updateErr := taskStore.Update(ctx, workspaceName, t); updateErr != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(updateErr).Msg("failed to persist CLI overrides")
        }</span>
}

// terminateAIProcess terminates any running AI process to prevent orphaned processes.
func terminateAIProcess(state *progressState, logger zerolog.Logger) <span class="cov0" title="0">{
        if state == nil || state.aiRunner == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">termRunner, ok := state.aiRunner.(ai.TerminatableRunner)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if err := termRunner.TerminateRunningProcess(); err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("failed to terminate AI process")
        }</span> else<span class="cov0" title="0"> {
                logger.Debug().Msg("AI process terminated on interrupt")
        }</span>
}

// handleInterruption handles graceful shutdown when user presses Ctrl+C.
// It saves the task and workspace state so the user can resume later.
func handleInterruption(ctx context.Context, sc *startContext, ws *domain.Workspace, t *domain.Task, state *progressState, logger zerolog.Logger, out tui.Output) error <span class="cov0" title="0">{
        logger.Info().
                Str("workspace_name", ws.Name).
                Str("task_id", safeTaskID(t)).
                Msg("received interrupt signal, initiating graceful shutdown")

        out.Warning("\n⚠ Interrupt received - saving state...")

        // Terminate any running AI process first to prevent orphaned processes
        terminateAIProcess(state, logger)

        // Use a context without cancellation for cleanup since the original is canceled
        cleanupCtx := context.WithoutCancel(ctx)

        // Save interrupted task state
        if t != nil </span><span class="cov0" title="0">{
                saveInterruptedTaskState(cleanupCtx, ws, t, logger)
        }</span>

        // Update workspace to paused
        <span class="cov0" title="0">sc.updateWorkspaceStatusToPaused(cleanupCtx, ws, logger)

        // Display summary
        displayInterruptionSummary(out, ws, t)

        return atlaserrors.ErrTaskInterrupted</span>
}

// saveInterruptedTaskState saves the task state when interrupted by Ctrl+C.
func handleHookInterrupt(ctx context.Context, hookManager task.HookManager, t *domain.Task, logger zerolog.Logger) <span class="cov0" title="0">{
        // Determine current step name
        stepName := ""
        if t.CurrentStep &gt;= 0 &amp;&amp; t.CurrentStep &lt; len(t.Steps) </span><span class="cov0" title="0">{
                stepName = t.Steps[t.CurrentStep].Name
        }</span>

        // Stop interval checkpointing first
        <span class="cov0" title="0">if err := hookManager.StopIntervalCheckpointing(ctx, t); err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Str("task_id", t.ID).Msg("failed to stop interval checkpointing")
        }</span>

        // Transition hook to awaiting_human state
        <span class="cov0" title="0">if err := hookManager.InterruptStep(ctx, t, stepName); err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).
                        Str("task_id", t.ID).
                        Str("step_name", stepName).
                        Msg("failed to update hook state on interrupt")
        }</span> else<span class="cov0" title="0"> {
                logger.Debug().
                        Str("task_id", t.ID).
                        Str("step_name", stepName).
                        Msg("hook state updated to awaiting_human on interrupt")
        }</span>
}

func saveInterruptedTaskState(ctx context.Context, ws *domain.Workspace, t *domain.Task, logger zerolog.Logger) <span class="cov0" title="0">{
        // Transition hook state to awaiting_human before task state transition.
        // This ensures resume can properly transition hook from awaiting_human → step_running.
        cfg, cfgErr := config.Load(ctx)
        if cfgErr != nil </span><span class="cov0" title="0">{
                cfg = config.DefaultConfig()
        }</span>
        <span class="cov0" title="0">services := workflow.NewServiceFactory(logger)
        hookManager := services.CreateHookManager(cfg, logger)
        if hookManager != nil </span><span class="cov0" title="0">{
                handleHookInterrupt(ctx, hookManager, t, logger)
        }</span>

        // Transition task to interrupted status if it's running or validating
        <span class="cov0" title="0">if t.Status == constants.TaskStatusRunning || t.Status == constants.TaskStatusValidating </span><span class="cov0" title="0">{
                if err := task.Transition(ctx, t, constants.TaskStatusInterrupted, "user pressed Ctrl+C"); err != nil </span><span class="cov0" title="0">{
                        logger.Error().Err(err).
                                Str("task_id", t.ID).
                                Str("from_status", string(t.Status)).
                                Msg("failed to transition task to interrupted status")
                }</span>
        }

        // Save task state
        <span class="cov0" title="0">taskStore, err := task.NewFileStore("")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).Msg("failed to create task store for interrupted state save")
                return
        }</span>

        <span class="cov0" title="0">if saveErr := taskStore.Update(ctx, ws.Name, t); saveErr != nil </span><span class="cov0" title="0">{
                logger.Error().Err(saveErr).
                        Str("task_id", t.ID).
                        Str("workspace_name", ws.Name).
                        Msg("failed to save interrupted task state")
        }</span> else<span class="cov0" title="0"> {
                logger.Debug().
                        Str("task_id", t.ID).
                        Str("status", string(t.Status)).
                        Int("current_step", t.CurrentStep).
                        Msg("interrupted task state saved")
        }</span>
}

// displayInterruptionSummary shows the user what happened and how to resume.
func displayInterruptionSummary(out tui.Output, ws *domain.Workspace, t *domain.Task) <span class="cov0" title="0">{
        out.Success("\n✓ Task state saved")
        out.Info("─────────────────────────────────────────")
        out.Info(fmt.Sprintf("📁 Workspace:    %s", ws.Name))
        out.Info(fmt.Sprintf("📁 Worktree:     %s", ws.WorktreePath))

        if t != nil </span><span class="cov0" title="0">{
                out.Info(fmt.Sprintf("📋 Task:         %s", t.ID))
                out.Info(fmt.Sprintf("📊 Status:       %s", t.Status))
                if t.CurrentStep &lt; len(t.Steps) </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("⏸ Stopped at:    Step %d/%d (%s)", t.CurrentStep+1, len(t.Steps), t.Steps[t.CurrentStep].Name))
                }</span>
        }

        <span class="cov0" title="0">out.Info("")
        out.Info(fmt.Sprintf("▶ To resume:  atlas resume %s", ws.Name))
        out.Info("")
        out.Info("💡 Your workspace and all changes are preserved.")</span>
}

// safeTaskID returns the task ID or a placeholder if task is nil.
func safeTaskID(t *domain.Task) string <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return "(none)"
        }</span>
        <span class="cov0" title="0">return t.ID</span>
}

// startTaskExecution creates and starts the task engine.
// Returns the task, task store (for subsequent updates), progress state, and any error.
// The progress state contains the AI runner for process termination on interrupt.
func startTaskExecution(ctx context.Context, ws *domain.Workspace, tmpl *domain.Template, description, agent, model, fromBacklogID string, logger zerolog.Logger, out tui.Output) (*domain.Task, *task.FileStore, *progressState, error) <span class="cov0" title="0">{
        // Create service factory
        services := workflow.NewServiceFactory(logger)

        // Create task store and load config
        taskStore, cfg, err := services.SetupTaskStoreAndConfig(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        // Create hook manager for crash recovery
        <span class="cov0" title="0">hookManager := services.CreateHookManager(cfg, logger)
        if hookManager != nil </span><span class="cov0" title="0">{
                logger.Debug().Msg("hook manager enabled for crash recovery")
        }</span>

        // Create notifiers
        <span class="cov0" title="0">notifier, stateNotifier := services.CreateNotifiers(cfg)

        // Create shared progress state for activity and progress callbacks
        // This enables activity events to update the spinner inline
        state := &amp;progressState{}

        // Create activity options for AI execution (uses shared state)
        //nolint:contextcheck // git stats refresh uses background context intentionally
        activityOpts := createActivityOptions(cfg, state, ws.Name, logger)

        // Create AI runner with activity streaming
        aiRunner := services.CreateAIRunnerWithActivity(cfg, activityOpts)

        // Store runner in state for termination on interrupt
        state.aiRunner = aiRunner

        // Resolve git config settings with fallbacks
        gitCfg := ResolveGitConfig(cfg)

        // Create git services
        gitServices, err := services.CreateGitServices(ctx, ws.WorktreePath, cfg, aiRunner, workflow.GitConfig{
                CommitAgent:         gitCfg.CommitAgent,
                CommitModel:         gitCfg.CommitModel,
                CommitTimeout:       gitCfg.CommitTimeout,
                CommitMaxRetries:    gitCfg.CommitMaxRetries,
                CommitBackoffFactor: gitCfg.CommitBackoffFactor,
                PRDescAgent:         gitCfg.PRDescAgent,
                PRDescModel:         gitCfg.PRDescModel,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        // Create git stats provider for live status display
        <span class="cov0" title="0">state.gitStatsProvider = git.NewStatsProvider(ws.WorktreePath)

        // Create progress callback for both engine and executors (uses shared state)
        progressCallback := createProgressCallback(ctx, out, ws.Name, state)

        // Create executor progress callback wrapper that handles both task.StepProgressEvent
        // and steps.AutoFixProgressEvent
        executorProgressCallback := func(event interface{}) </span><span class="cov0" title="0">{
                switch e := event.(type) </span>{
                case task.StepProgressEvent:<span class="cov0" title="0">
                        progressCallback(e)</span>
                case steps.AutoFixProgressEvent:<span class="cov0" title="0">
                        // Convert AutoFixProgressEvent to task.StepProgressEvent
                        progressCallback(task.StepProgressEvent{
                                Type:              e.Type,
                                TaskID:            e.TaskID,
                                WorkspaceName:     e.WorkspaceName,
                                Agent:             e.Agent,
                                Model:             e.Model,
                                Status:            e.Status,
                                DurationMs:        e.DurationMs,
                                NumTurns:          e.NumTurns,
                                FilesChangedCount: e.FilesChangedCount,
                        })</span>
                }
        }

        // Create validation progress callback that converts validation progress to task events
        <span class="cov0" title="0">validationProgressCallback := createValidationProgressAdapter(progressCallback, ws.Name, len(tmpl.Steps))

        // Create executor registry
        execRegistry := services.CreateExecutorRegistry(workflow.RegistryDeps{
                WorkDir:                    ws.WorktreePath,
                TaskStore:                  taskStore,
                Notifier:                   notifier,
                AIRunner:                   aiRunner,
                Logger:                     logger,
                GitServices:                gitServices,
                Config:                     cfg,
                ProgressCallback:           executorProgressCallback,
                ValidationProgressCallback: validationProgressCallback,
        })

        // Create validation retry handler for automatic AI-assisted fixes
        validationRetryHandler := services.CreateValidationRetryHandler(aiRunner, cfg)
        logger.Debug().
                Bool("handler_created", validationRetryHandler != nil).
                Bool("ai_retry_enabled", cfg.Validation.AIRetryEnabled).
                Int("max_retry_attempts", cfg.Validation.MaxAIRetryAttempts).
                Msg("validation retry handler status")

        // Create engine with progress callback
        engine := services.CreateEngine(workflow.EngineDeps{
                TaskStore:              taskStore,
                ExecRegistry:           execRegistry,
                Logger:                 LoggerWithTaskStore(taskStore),
                StateNotifier:          stateNotifier,
                ProgressCallback:       progressCallback,
                ValidationRetryHandler: validationRetryHandler,
                HookManager:            hookManager,
        }, cfg)

        // Apply agent and model overrides to template
        workflow.ApplyAgentModelOverrides(tmpl, agent, model)

        // Start task
        t, err := startTask(ctx, engine, ws, tmpl, description, fromBacklogID, logger)
        return t, taskStore, state, err</span>
}

// progressState holds shared state for progress and activity callbacks.
// This enables activity events to update the spinner message inline.
type progressState struct {
        activeSpinner    tui.Spinner
        baseMessage      string             // e.g., "Step 1/8: implement (claude/sonnet)"
        gitStatsProvider *git.StatsProvider // Provider for live git stats display
        aiRunner         ai.Runner          // AI runner for process termination on interrupt
}

// createProgressCallback creates the progress callback for UI feedback.
func createProgressCallback(ctx context.Context, out tui.Output, _ string, state *progressState) func(task.StepProgressEvent) <span class="cov0" title="0">{
        logPathShown := false

        return func(event task.StepProgressEvent) </span><span class="cov0" title="0">{
                switch event.Type </span>{
                case "start":<span class="cov0" title="0">
                        handleProgressStart(ctx, out, event, &amp;logPathShown, state)</span>
                case "complete":<span class="cov0" title="0">
                        handleProgressComplete(out, event, state)</span>
                case "progress":<span class="cov0" title="0">
                        handleProgressUpdate(out, event, state)</span>
                case "retry_ai_start":<span class="cov0" title="0">
                        handleRetryAIStart(ctx, out, event, state)</span>
                case "retry_ai_complete":<span class="cov0" title="0">
                        handleRetryAIComplete(out, event, state)</span>
                case "retry_validation_start":<span class="cov0" title="0">
                        handleRetryValidationStart(ctx, out, event, state)</span>
                case "auto_fix_start":<span class="cov0" title="0">
                        handleAutoFixStart(ctx, out, event, state)</span>
                case "auto_fix_complete":<span class="cov0" title="0">
                        handleAutoFixComplete(out, event, state)</span>
                }
        }
}

// handleProgressStart handles the start event of a step progress.
func handleProgressStart(ctx context.Context, out tui.Output, event task.StepProgressEvent, logPathShown *bool, state *progressState) <span class="cov0" title="0">{
        // Show log path on first step start
        if !*logPathShown &amp;&amp; event.TaskID != "" </span><span class="cov0" title="0">{
                logPath := fmt.Sprintf("~/.atlas/workspaces/%s/tasks/%s/task.log", event.WorkspaceName, event.TaskID)
                out.Info(fmt.Sprintf("Logs: %s", logPath))
                *logPathShown = true
        }</span>

        <span class="cov0" title="0">msg := buildStepStartMessage(event)

        // Store base message for activity updates
        state.baseMessage = msg

        // Show spinner for ALL step types during execution
        state.activeSpinner = out.Spinner(ctx, msg)</span>
}

// buildStepStartMessage builds the step start message based on the event.
func buildStepStartMessage(event task.StepProgressEvent) string <span class="cov0" title="0">{
        if event.Agent != "" &amp;&amp; event.Model != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Step %d/%d: %s (%s/%s)...", event.StepIndex+1, event.TotalSteps, event.StepName, event.Agent, event.Model)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Step %d/%d: %s...", event.StepIndex+1, event.TotalSteps, event.StepName)</span>
}

// handleProgressComplete handles the complete event of a step progress.
func handleProgressComplete(out tui.Output, event task.StepProgressEvent, state *progressState) <span class="cov0" title="0">{
        // Stop the spinner if one was running
        if state.activeSpinner != nil </span><span class="cov0" title="0">{
                state.activeSpinner.Stop()
                state.activeSpinner = nil
        }</span>
        <span class="cov0" title="0">state.baseMessage = ""

        // Check if step is awaiting approval vs completed
        if event.Status == constants.StepStatusAwaitingApproval </span><span class="cov0" title="0">{
                statusMsg := fmt.Sprintf("Step %d/%d: %s requires approval",
                        event.StepIndex+1, event.TotalSteps, event.StepName)
                out.Warning(statusMsg)

                // Show the reason if available
                if event.Output != "" </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("  Reason: %s", event.Output))
                }</span>
                <span class="cov0" title="0">out.Info("  Run 'atlas approve' to continue")
                return</span>
        }

        // Display completion message
        <span class="cov0" title="0">statusMsg := fmt.Sprintf("Step %d/%d: %s completed", event.StepIndex+1, event.TotalSteps, event.StepName)
        out.Success(statusMsg)

        // Display metrics for AI steps
        if event.Agent != "" &amp;&amp; (event.DurationMs &gt; 0 || event.NumTurns &gt; 0 || event.FilesChangedCount &gt; 0) </span><span class="cov0" title="0">{
                metrics := buildStepMetrics(event.DurationMs, event.NumTurns, event.FilesChangedCount)
                if metrics != "" </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("  %s", metrics))
                }</span>
        }

        // Display PR URL if present
        <span class="cov0" title="0">displayPRURL(out, event.Output)</span>
}

// displayPRURL displays PR URLs from the output if present.
func displayPRURL(out tui.Output, output string) <span class="cov0" title="0">{
        if output != "" &amp;&amp; strings.Contains(output, "Created PR #") </span><span class="cov0" title="0">{
                lines := strings.Split(output, "\n")
                for _, line := range lines </span><span class="cov0" title="0">{
                        if strings.HasPrefix(line, "https://") || strings.HasPrefix(line, "http://") </span><span class="cov0" title="0">{
                                out.URL(line, line)
                        }</span>
                }
        }
}

// handleProgressUpdate handles sub-step progress updates during multi-phase operations.
func handleProgressUpdate(_ tui.Output, event task.StepProgressEvent, state *progressState) <span class="cov0" title="0">{
        if state.activeSpinner == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Build message with sub-step progress
        <span class="cov0" title="0">var msg string
        if event.TotalSteps &gt; 0 </span><span class="cov0" title="0">{
                // Full step context available
                msg = fmt.Sprintf("Step %d/%d: %s", event.StepIndex+1, event.TotalSteps, event.StepName)
        }</span> else<span class="cov0" title="0"> {
                // No step context, just show step name
                msg = event.StepName
        }</span>

        <span class="cov0" title="0">if event.SubStep != "" </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("%s - %s (%d/%d)", msg, event.SubStep, event.SubStepIndex+1, event.SubStepTotal)
        }</span>

        <span class="cov0" title="0">state.activeSpinner.Update(msg)</span>
}

// createValidationProgressAdapter creates a validation progress callback that converts
// validation sub-step progress to task.StepProgressEvent format for UI display.
func createValidationProgressAdapter(progressCallback func(task.StepProgressEvent), workspaceName string, _ int) func(step, status string, info *validation.ProgressInfo) <span class="cov0" title="0">{
        // Map validation phase names to 0-indexed positions
        phaseIndex := map[string]int{
                "pre-commit": 0,
                "format":     1,
                "lint":       2,
                "test":       3,
        }

        return func(step, status string, info *validation.ProgressInfo) </span><span class="cov0" title="0">{
                // Only report on starting status (to update spinner message)
                if status != "starting" </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">subStepTotal := 4
                if info != nil &amp;&amp; info.TotalSteps &gt; 0 </span><span class="cov0" title="0">{
                        subStepTotal = info.TotalSteps
                }</span>

                <span class="cov0" title="0">progressCallback(task.StepProgressEvent{
                        Type:          "progress",
                        WorkspaceName: workspaceName,
                        // StepIndex and TotalSteps are 0 here since we don't have task context.
                        // The validation step will update its own position when it starts.
                        StepName:     "validation",
                        StepType:     domain.StepTypeValidation,
                        SubStep:      step,
                        SubStepIndex: phaseIndex[step],
                        SubStepTotal: subStepTotal,
                })</span>
        }
}

// handleRetryAIStart handles the retry_ai_start event of a validation retry.
func handleRetryAIStart(ctx context.Context, out tui.Output, event task.StepProgressEvent, state *progressState) <span class="cov0" title="0">{
        msg := buildRetryAIStartMessage(event)
        // Store base message for activity updates
        state.baseMessage = msg
        state.activeSpinner = out.Spinner(ctx, msg)
}</span>

// handleRetryAIComplete handles the retry_ai_complete event of a validation retry.
func handleRetryAIComplete(out tui.Output, event task.StepProgressEvent, state *progressState) <span class="cov0" title="0">{
        // Stop the spinner if one was running
        if state.activeSpinner != nil </span><span class="cov0" title="0">{
                state.activeSpinner.Stop()
                state.activeSpinner = nil
        }</span>
        <span class="cov0" title="0">state.baseMessage = ""

        // Display completion message only if we have metrics (final completion)
        // If no metrics, this is the intermediate notification before validation
        if event.DurationMs &gt; 0 || event.NumTurns &gt; 0 || event.FilesChangedCount &gt; 0 </span><span class="cov0" title="0">{
                out.Success("Retry AI fix completed")
                metrics := buildStepMetrics(event.DurationMs, event.NumTurns, event.FilesChangedCount)
                if metrics != "" </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("  %s", metrics))
                }</span>
        }
}

// handleRetryValidationStart handles the retry_validation_start event.
// This is called after AI fix completes but before validation re-runs.
func handleRetryValidationStart(ctx context.Context, out tui.Output, event task.StepProgressEvent, state *progressState) <span class="cov0" title="0">{
        msg := event.Status
        if msg == "" </span><span class="cov0" title="0">{
                msg = "Validating after AI fix..."
        }</span>
        // Store base message for activity updates
        <span class="cov0" title="0">state.baseMessage = msg
        state.activeSpinner = out.Spinner(ctx, msg)</span>
}

// buildRetryAIStartMessage builds the retry AI start message based on the event.
func buildRetryAIStartMessage(event task.StepProgressEvent) string <span class="cov0" title="0">{
        if event.Status != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s (%s/%s)...", event.Status, event.Agent, event.Model)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Retry AI fix (%s/%s)...", event.Agent, event.Model)</span>
}

// handleAutoFixStart handles the auto_fix_start event of a verification auto-fix.
func handleAutoFixStart(ctx context.Context, out tui.Output, event task.StepProgressEvent, state *progressState) <span class="cov0" title="0">{
        msg := buildAutoFixStartMessage(event)
        // Store base message for activity updates
        state.baseMessage = msg
        state.activeSpinner = out.Spinner(ctx, msg)
}</span>

// handleAutoFixComplete handles the auto_fix_complete event of a verification auto-fix.
func handleAutoFixComplete(out tui.Output, event task.StepProgressEvent, state *progressState) <span class="cov0" title="0">{
        // Stop the spinner if one was running
        if state.activeSpinner != nil </span><span class="cov0" title="0">{
                state.activeSpinner.Stop()
                state.activeSpinner = nil
        }</span>
        <span class="cov0" title="0">state.baseMessage = ""

        // Display completion message
        out.Success("Auto-fix completed")

        // Display metrics if available
        if event.DurationMs &gt; 0 || event.NumTurns &gt; 0 || event.FilesChangedCount &gt; 0 </span><span class="cov0" title="0">{
                metrics := buildStepMetrics(event.DurationMs, event.NumTurns, event.FilesChangedCount)
                if metrics != "" </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("  %s", metrics))
                }</span>
        }
}

// buildAutoFixStartMessage builds the auto-fix start message based on the event.
func buildAutoFixStartMessage(event task.StepProgressEvent) string <span class="cov0" title="0">{
        if event.Status != "" &amp;&amp; event.Agent != "" &amp;&amp; event.Model != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s (%s/%s)...", event.Status, event.Agent, event.Model)
        }</span>
        <span class="cov0" title="0">if event.Agent != "" &amp;&amp; event.Model != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Auto-fixing verification issues (%s/%s)...", event.Agent, event.Model)
        }</span>
        <span class="cov0" title="0">return "Auto-fixing verification issues..."</span>
}

// startTask starts the task execution and handles errors.
func startTask(ctx context.Context, engine *task.Engine, ws *domain.Workspace, tmpl *domain.Template, description, fromBacklogID string, logger zerolog.Logger) (*domain.Task, error) <span class="cov0" title="0">{
        // Enrich description with backlog discovery metadata
        enrichedDescription := enrichDescriptionFromBacklog(ctx, description, fromBacklogID, logger)

        t, err := engine.Start(ctx, ws.Name, ws.Branch, ws.WorktreePath, tmpl, enrichedDescription, fromBacklogID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).
                        Str("workspace_name", ws.Name).
                        Msg("task start failed")
                return t, err
        }</span>
        <span class="cov0" title="0">return t, nil</span>
}

// enrichDescriptionFromBacklog fetches the discovery and enriches the description
// with its metadata (file, line, category, severity, tags).
func enrichDescriptionFromBacklog(ctx context.Context, description, backlogID string, logger zerolog.Logger) string <span class="cov0" title="0">{
        if backlogID == "" </span><span class="cov0" title="0">{
                return description
        }</span>

        <span class="cov0" title="0">mgr, err := backlog.NewManager("")
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(err).Msg("failed to create backlog manager for enrichment")
                return description // Fall back to original on error
        }</span>

        <span class="cov0" title="0">discovery, err := mgr.Get(ctx, backlogID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(err).Str("backlog_id", backlogID).Msg("failed to get discovery for enrichment")
                return description // Fall back to original on error
        }</span>

        <span class="cov0" title="0">logger.Debug().
                Str("backlog_id", backlogID).
                Str("category", string(discovery.Content.Category)).
                Str("severity", string(discovery.Content.Severity)).
                Msg("enriching description with discovery metadata")

        return buildEnrichedDescription(description, discovery)</span>
}

// buildEnrichedDescription constructs an enriched description from discovery metadata.
func buildEnrichedDescription(description string, d *backlog.Discovery) string <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteString(description)
        sb.WriteString("\n\nContext from backlog discovery:")

        // Add file location
        if d.Location != nil &amp;&amp; d.Location.File != "" </span><span class="cov0" title="0">{
                if d.Location.Line &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Fprintf(&amp;sb, "\n- File: %s:%d", d.Location.File, d.Location.Line)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(&amp;sb, "\n- File: %s", d.Location.File)
                }</span>
        }

        // Add category and severity
        <span class="cov0" title="0">fmt.Fprintf(&amp;sb, "\n- Category: %s", d.Content.Category)
        fmt.Fprintf(&amp;sb, "\n- Severity: %s", d.Content.Severity)

        // Add tags if present
        if len(d.Content.Tags) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;sb, "\n- Tags: %s", strings.Join(d.Content.Tags, ", "))
        }</span>

        // Add discovery description if different from task description
        <span class="cov0" title="0">if d.Content.Description != "" &amp;&amp; d.Content.Description != description </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;sb, "\n- Details: %s", d.Content.Description)
        }</span>

        <span class="cov0" title="0">return sb.String()</span>
}

// startResponse represents the JSON output for start operations.
type startResponse struct {
        Success   bool          `json:"success"`
        Workspace workspaceInfo `json:"workspace"`
        Task      taskInfo      `json:"task"`
        Error     string        `json:"error,omitempty"`
}

// workspaceInfo contains workspace details for JSON output.
type workspaceInfo struct {
        Name         string `json:"name"`
        Branch       string `json:"branch"`
        WorktreePath string `json:"worktree_path"`
        Status       string `json:"status"`
}

// taskInfo contains task details for JSON output.
type taskInfo struct {
        ID           string `json:"task_id"`
        TemplateName string `json:"template_name"`
        Description  string `json:"description"`
        Status       string `json:"status"`
        CurrentStep  int    `json:"current_step"`
        TotalSteps   int    `json:"total_steps"`
}

// cleanupWorkspace removes a workspace after a failed task start.
// This calls Destroy() (complete removal), not Close() (archive).
func cleanupWorkspace(ctx context.Context, wsName, repoPath string) error <span class="cov0" title="0">{
        logger := Logger()
        logger.Debug().
                Str("workspace_name", wsName).
                Str("repo_path", repoPath).
                Msg("cleanupWorkspace called - will call Destroy() (not Close())")

        wsStore, err := workspace.NewFileStore("")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create workspace store: %w", err)
        }</span>

        <span class="cov0" title="0">wtRunner, err := workspace.NewGitWorktreeRunner(ctx, repoPath, logger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create worktree runner: %w", err)
        }</span>

        <span class="cov0" title="0">mgr := workspace.NewManager(wsStore, wtRunner, logger)
        return mgr.Destroy(ctx, wsName)</span>
}

// isValidAgent checks if the agent name is valid.
func isValidAgent(agent string) bool <span class="cov0" title="0">{
        a := domain.Agent(agent)
        return a.IsValid()
}</span>

// validateAgent checks if the agent name is valid.
func validateAgent(agent string) error <span class="cov0" title="0">{
        if agent == "" </span><span class="cov0" title="0">{
                return nil // Empty is valid (use default)
        }</span>
        <span class="cov0" title="0">if !isValidAgent(agent) </span><span class="cov0" title="0">{
                return atlaserrors.NewExitCode2Error(
                        fmt.Errorf("%w: '%s' (must be one of claude, gemini, codex)", atlaserrors.ErrAgentNotFound, agent))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// isValidModelForAgent checks if the model name is valid for the given agent.
func isValidModelForAgent(agent, model string) bool <span class="cov0" title="0">{
        // If no agent specified, validate against Claude (default)
        a := domain.Agent(agent)
        if a == "" </span><span class="cov0" title="0">{
                a = domain.AgentClaude
        }</span>

        // Check if model is in the agent's valid aliases
        <span class="cov0" title="0">for _, alias := range a.ModelAliases() </span><span class="cov0" title="0">{
                if model == alias </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// validateModel checks if the model name is valid for the given agent.
func validateModel(agent, model string) error <span class="cov0" title="0">{
        if model == "" </span><span class="cov0" title="0">{
                return nil // Empty is valid (use default)
        }</span>

        // If agent not specified, check against all agents
        <span class="cov0" title="0">if agent == "" </span><span class="cov0" title="0">{
                // Accept models from either agent
                if isValidModelForAgent("claude", model) || isValidModelForAgent("gemini", model) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return atlaserrors.NewExitCode2Error(
                        fmt.Errorf("%w: '%s' (must be sonnet, opus, haiku for claude or flash, pro for gemini)", atlaserrors.ErrInvalidModel, model))</span>
        }

        // Validate against specific agent
        <span class="cov0" title="0">if !isValidModelForAgent(agent, model) </span><span class="cov0" title="0">{
                a := domain.Agent(agent)
                return atlaserrors.NewExitCode2Error(
                        fmt.Errorf("%w: '%s' is not valid for agent '%s' (valid models: %v)", atlaserrors.ErrInvalidModel, model, agent, a.ModelAliases()))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// displayTaskStatus outputs the task status in the appropriate format.
func displayTaskStatus(out tui.Output, format string, ws *domain.Workspace, t *domain.Task, execErr error) error <span class="cov0" title="0">{
        if format == OutputJSON </span><span class="cov0" title="0">{
                resp := startResponse{
                        Success: execErr == nil,
                        Workspace: workspaceInfo{
                                Name:         ws.Name,
                                Branch:       ws.Branch,
                                WorktreePath: ws.WorktreePath,
                                Status:       string(ws.Status),
                        },
                        Task: taskInfo{
                                ID:           t.ID,
                                TemplateName: t.TemplateID,
                                Description:  t.Description,
                                Status:       string(t.Status),
                                CurrentStep:  t.CurrentStep,
                                TotalSteps:   len(t.Steps),
                        },
                }
                if execErr != nil </span><span class="cov0" title="0">{
                        resp.Error = execErr.Error()
                }</span>
                <span class="cov0" title="0">return out.JSON(resp)</span>
        }

        // TTY output
        <span class="cov0" title="0">out.Success(fmt.Sprintf("Task started: %s", t.ID))
        out.Info(fmt.Sprintf("  Workspace: %s", ws.Name))
        out.Info(fmt.Sprintf("  Branch:    %s", ws.Branch))
        out.Info(fmt.Sprintf("  Template:  %s", t.TemplateID))
        out.Info(fmt.Sprintf("  Status:    %s", t.Status))
        out.Info(fmt.Sprintf("  Progress:  Step %d/%d", t.CurrentStep+1, len(t.Steps)))

        if execErr != nil </span><span class="cov0" title="0">{
                out.Warning(fmt.Sprintf("Execution paused: %s", execErr.Error()))

                // Display manual fix instructions for validation failures
                if t.Status == constants.TaskStatusValidationFailed </span><span class="cov0" title="0">{
                        tui.DisplayManualFixInstructions(out, t, ws)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// outputStartErrorJSON outputs an error result as JSON.
func outputStartErrorJSON(w io.Writer, workspaceName, taskID, errMsg string) error <span class="cov0" title="0">{
        return encodeJSONIndented(w, startResponse{
                Success: false,
                Workspace: workspaceInfo{
                        Name: workspaceName,
                },
                Task: taskInfo{
                        ID: taskID,
                },
                Error: errMsg,
        })
}</span>

// dryRunResponse represents the JSON output for dry-run mode.
type dryRunResponse struct {
        DryRun    bool                `json:"dry_run"`
        Template  string              `json:"template"`
        Workspace dryRunWorkspaceInfo `json:"workspace"`
        Steps     []dryRunStepInfo    `json:"steps"`
        Summary   dryRunSummary       `json:"summary"`
}

// dryRunWorkspaceInfo contains simulated workspace details.
type dryRunWorkspaceInfo struct {
        Name        string `json:"name"`
        Branch      string `json:"branch"`
        WouldCreate bool   `json:"would_create"`
}

// dryRunStepInfo contains information about what a step would do.
type dryRunStepInfo struct {
        Index       int            `json:"index"`
        Name        string         `json:"name"`
        Type        string         `json:"type"`
        Description string         `json:"description,omitempty"`
        Required    bool           `json:"required"`
        Status      string         `json:"status"`
        WouldDo     []string       `json:"would_do"`
        Config      map[string]any `json:"config,omitempty"`
}

// dryRunSummary contains summary information.
type dryRunSummary struct {
        TotalSteps           int      `json:"total_steps"`
        SideEffectsPrevented []string `json:"side_effects_prevented"`
}

// getSideEffectForStepType returns the side effect description for a given step type.
func getSideEffectForStepType(step domain.StepDefinition) string <span class="cov0" title="0">{
        switch step.Type </span>{
        case domain.StepTypeAI:<span class="cov0" title="0">
                return "AI execution (file modifications)"</span>
        case domain.StepTypeValidation:<span class="cov0" title="0">
                return "Validation commands (format may modify files)"</span>
        case domain.StepTypeGit:<span class="cov0" title="0">
                if op, ok := step.Config["operation"].(string); ok </span><span class="cov0" title="0">{
                        switch op </span>{
                        case "commit":<span class="cov0" title="0">
                                return "Git commits"</span>
                        case "push":<span class="cov0" title="0">
                                return "Git push to remote"</span>
                        case "create_pr":<span class="cov0" title="0">
                                return "Pull request creation"</span>
                        default:<span class="cov0" title="0">
                                return "Git operations"</span>
                        }
                }
                <span class="cov0" title="0">return "Git operations"</span>
        case domain.StepTypeVerify:<span class="cov0" title="0">
                return "AI verification"</span>
        case domain.StepTypeSDD:<span class="cov0" title="0">
                return "SDD generation"</span>
        case domain.StepTypeCI:<span class="cov0" title="0">
                return "CI execution"</span>
        case domain.StepTypeHuman:<span class="cov0" title="0">
                return ""</span>
        case domain.StepTypeLoop:<span class="cov0" title="0">
                return "Loop execution (iterative steps)"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// runDryRun simulates task execution without making any changes.
func runDryRun(ctx context.Context, sc *startContext, tmpl *domain.Template, description, wsName string, cfg *config.Config, logger zerolog.Logger) error <span class="cov0" title="0">{
        // Check context cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">logger.Debug().
                Str("template", tmpl.Name).
                Str("workspace", wsName).
                Msg("running dry-run simulation")

        // Create simulated workspace info
        simulatedBranch := fmt.Sprintf("%s%s", tmpl.BranchPrefix, wsName)

        // Create dry-run executor registry
        dryRunRegistry := steps.NewDryRunRegistry(steps.ExecutorDeps{
                WorkDir:           "(simulated)",
                BaseBranch:        cfg.Git.BaseBranch,
                FormatCommands:    cfg.Validation.Commands.Format,
                LintCommands:      cfg.Validation.Commands.Lint,
                TestCommands:      cfg.Validation.Commands.Test,
                PreCommitCommands: cfg.Validation.Commands.PreCommit,
                CIConfig:          &amp;cfg.CI,
                OperationsConfig:  &amp;cfg.Operations,
        })

        // Create simulated task for dry-run
        simulatedTask := &amp;domain.Task{
                Description: description,
                TemplateID:  tmpl.Name,
                Metadata: map[string]any{
                        "branch": simulatedBranch,
                },
        }

        // Collect step plans
        stepPlans := make([]dryRunStepInfo, 0, len(tmpl.Steps))
        var sideEffects []string

        for i, step := range tmpl.Steps </span><span class="cov0" title="0">{
                simulatedTask.CurrentStep = i

                // Get dry-run executor for this step type
                executor, err := dryRunRegistry.Get(step.Type)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn().Err(err).Str("step_type", string(step.Type)).Msg("no executor for step type")
                        continue</span>
                }

                // Execute dry-run (returns plan, no side effects)
                <span class="cov0" title="0">result, err := executor.Execute(ctx, simulatedTask, &amp;step)
                if err != nil </span><span class="cov0" title="0">{
                        return sc.handleError(wsName, fmt.Errorf("dry-run failed for step %s: %w", step.Name, err))
                }</span>

                // Extract plan from result metadata
                <span class="cov0" title="0">var wouldDo []string
                var stepConfig map[string]any
                if result.Metadata != nil </span><span class="cov0" title="0">{
                        if plan, ok := result.Metadata["plan"].(*steps.DryRunPlan); ok </span><span class="cov0" title="0">{
                                wouldDo = plan.WouldDo
                                stepConfig = plan.Config
                        }</span>
                }

                <span class="cov0" title="0">stepPlans = append(stepPlans, dryRunStepInfo{
                        Index:       i,
                        Name:        step.Name,
                        Type:        string(step.Type),
                        Description: step.Description,
                        Required:    step.Required,
                        Status:      "would_execute",
                        WouldDo:     wouldDo,
                        Config:      stepConfig,
                })

                // Track side effects that would occur
                if sideEffect := getSideEffectForStepType(step); sideEffect != "" </span><span class="cov0" title="0">{
                        sideEffects = append(sideEffects, sideEffect)
                }</span>
        }

        // Add workspace creation to side effects
        <span class="cov0" title="0">sideEffects = append([]string{"Workspace creation (git worktree)"}, sideEffects...)

        // Output results
        if sc.outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return outputDryRunJSON(sc.w, tmpl.Name, wsName, simulatedBranch, stepPlans, sideEffects)
        }</span>

        <span class="cov0" title="0">return outputDryRunTTY(sc.out, tmpl, wsName, simulatedBranch, stepPlans, sideEffects)</span>
}

// outputDryRunJSON outputs the dry-run results as JSON.
func outputDryRunJSON(w io.Writer, templateName, wsName, branch string, stepPlans []dryRunStepInfo, sideEffects []string) error <span class="cov0" title="0">{
        resp := dryRunResponse{
                DryRun:   true,
                Template: templateName,
                Workspace: dryRunWorkspaceInfo{
                        Name:        wsName,
                        Branch:      branch,
                        WouldCreate: true,
                },
                Steps: stepPlans,
                Summary: dryRunSummary{
                        TotalSteps:           len(stepPlans),
                        SideEffectsPrevented: sideEffects,
                },
        }

        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(resp)
}</span>

// outputDryRunTTY outputs the dry-run results for terminal display.
func outputDryRunTTY(out tui.Output, tmpl *domain.Template, wsName, branch string, stepPlans []dryRunStepInfo, sideEffects []string) error <span class="cov0" title="0">{
        // Header
        out.Info("=== DRY-RUN MODE ===")
        out.Info("Showing what would happen without making changes.\n")

        // Workspace info
        out.Info(fmt.Sprintf("[0/%d] Workspace Creation", len(stepPlans)))
        out.Info(fmt.Sprintf("      Name:   %s", wsName))
        out.Info(fmt.Sprintf("      Branch: %s", branch))
        out.Info("      Status: WOULD CREATE\n")

        // Step details
        for _, step := range stepPlans </span><span class="cov0" title="0">{
                requiredStr := ""
                if !step.Required </span><span class="cov0" title="0">{
                        requiredStr = " (optional)"
                }</span>
                <span class="cov0" title="0">out.Info(fmt.Sprintf("[%d/%d] %s Step: '%s'%s", step.Index+1, len(stepPlans), step.Type, step.Name, requiredStr))

                if step.Description != "" </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("      Description: %s", step.Description))
                }</span>

                <span class="cov0" title="0">if len(step.WouldDo) &gt; 0 </span><span class="cov0" title="0">{
                        out.Info("      Would:")
                        for _, action := range step.WouldDo </span><span class="cov0" title="0">{
                                out.Info(fmt.Sprintf("        - %s", action))
                        }</span>
                }

                <span class="cov0" title="0">out.Info(fmt.Sprintf("      Status: %s\n", step.Status))</span>
        }

        // Summary
        <span class="cov0" title="0">out.Info("=== Summary ===")
        out.Info(fmt.Sprintf("Template: %s", tmpl.Name))
        out.Info(fmt.Sprintf("Steps: %d total", len(stepPlans)))
        out.Info("Side Effects Prevented:")
        for _, effect := range sideEffects </span><span class="cov0" title="0">{
                out.Info(fmt.Sprintf("  - %s", effect))
        }</span>
        <span class="cov0" title="0">out.Info("")
        out.Success("Run without --dry-run to execute.")

        return nil</span>
}

// buildStepMetrics formats step completion metrics for display.
// Returns a formatted string like "Duration: 2m 15s | Turns: 4 | Files: 3"
func buildStepMetrics(durationMs int64, numTurns, filesChangedCount int) string <span class="cov0" title="0">{
        var parts []string

        if durationMs &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, "Duration: "+formatDuration(durationMs))
        }</span>
        <span class="cov0" title="0">if numTurns &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("Turns: %d", numTurns))
        }</span>
        <span class="cov0" title="0">if filesChangedCount &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("Files: %d", filesChangedCount))
        }</span>

        <span class="cov0" title="0">if len(parts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return strings.Join(parts, " | ")</span>
}

// formatDuration converts milliseconds to a human-readable duration string.
func formatDuration(ms int64) string <span class="cov0" title="0">{
        seconds := ms / 1000
        if seconds &lt; 60 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%ds", seconds)
        }</span>
        <span class="cov0" title="0">minutes := seconds / 60
        secs := seconds % 60
        if secs == 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm", minutes)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%dm %ds", minutes, secs)</span>
}

// createActivityOptions creates activity options for AI execution with streaming.
// Returns nil if activity streaming should be disabled.
func createActivityOptions(cfg *config.Config, state *progressState, workspaceName string, logger zerolog.Logger) *ai.ActivityOptions <span class="cov0" title="0">{
        // Parse verbosity from config
        verbosity := ai.ParseVerbosity(cfg.AI.ActivityVerbosity)

        // Create activity logger
        activityLogger, err := ai.NewActivityLogger(ai.ActivityLoggerConfig{
                TaskID:      "", // Will be set per-task
                MaxLogFiles: 50,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("failed to create activity logger, activity logging disabled")
                activityLogger = nil
        }</span>

        // Create callback that sends events to both UI and logger
        <span class="cov0" title="0">uiCallback := createActivityUICallback(state, verbosity)
        var callback ai.ActivityCallback
        if activityLogger != nil </span><span class="cov0" title="0">{
                callback = ai.CombineCallbacks(uiCallback, activityLogger.CreateCallback())
        }</span> else<span class="cov0" title="0"> {
                callback = uiCallback
        }</span>

        <span class="cov0" title="0">return &amp;ai.ActivityOptions{
                Callback:      callback,
                Verbosity:     verbosity,
                WorkspaceName: workspaceName,
        }</span>
}

// createActivityUICallback creates a callback that updates the spinner with activity events.
// Instead of printing separate lines, activity events are integrated into the spinner message.
// Git stats are included when available to show real-time file changes.
func createActivityUICallback(state *progressState, verbosity ai.VerbosityLevel) ai.ActivityCallback <span class="cov0" title="0">{
        return func(event ai.ActivityEvent) </span><span class="cov0" title="0">{
                // Filter by verbosity
                if !verbosity.ShouldShow(event.Type) </span><span class="cov0" title="0">{
                        return
                }</span>

                // Skip if no active spinner or base message
                <span class="cov0" title="0">if state.activeSpinner == nil || state.baseMessage == "" </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">icon := event.Type.Icon()
                msg := event.FormatMessage()
                statsStr := getGitStatsString(state.gitStatsProvider)

                // Integrate activity into spinner with optional stats
                // Format: "Step 1/8: implement (claude/sonnet) 3M +120/-45 | 🔍 Analyzing..."
                if statsStr != "" </span><span class="cov0" title="0">{
                        state.activeSpinner.Update(fmt.Sprintf("%s %s | %s %s", state.baseMessage, statsStr, icon, msg))
                }</span> else<span class="cov0" title="0"> {
                        state.activeSpinner.Update(fmt.Sprintf("%s %s %s", state.baseMessage, icon, msg))
                }</span>
        }
}

// getGitStatsString returns formatted git stats string, triggering async refresh.
// Returns empty string if no stats available or provider is nil.
func getGitStatsString(provider *git.StatsProvider) string <span class="cov0" title="0">{
        if provider == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Trigger async refresh (debounced internally)
        // Uses background context because the refresh runs in a goroutine and should
        // not be tied to the caller's context lifecycle
        <span class="cov0" title="0">provider.RefreshAsync(context.Background())

        stats := provider.GetCachedStats()
        if stats == nil || stats.IsEmpty() </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return tui.FormatGitStats(stats.NewFiles, stats.ModifiedFiles, stats.Additions, stats.Deletions)</span>
}
</pre>

		<pre class="file" id="file29" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/domain"
        "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/task"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/workspace"
        "github.com/spf13/cobra"
)

// WorkspaceLister defines the interface for listing workspaces.
// Used for dependency injection in tests.
type WorkspaceLister interface {
        List(ctx context.Context) ([]*domain.Workspace, error)
}

// TaskLister defines the interface for listing tasks.
// Used for dependency injection in tests.
type TaskLister interface {
        List(ctx context.Context, workspaceName string) ([]*domain.Task, error)
}

// MinWatchInterval is the minimum allowed refresh interval for watch mode.
// Prevents excessive CPU usage from too-frequent refreshes.
const MinWatchInterval = 500 * time.Millisecond

// DefaultWatchInterval is the default refresh interval for watch mode.
const DefaultWatchInterval = 2 * time.Second

// statusOptions contains all options for the status command.
// Using a struct instead of individual boolean parameters improves readability
// at call sites and makes it easier to add new options.
type statusOptions struct {
        WatchMode     bool
        WatchInterval time.Duration
        ShowProgress  bool
}

// StatusRenderOptions contains display-related options for status rendering.
// Using a struct reduces parameter count and improves readability.
type StatusRenderOptions struct {
        Output       string
        Quiet        bool
        ShowProgress bool
}

// StatusDeps contains dependencies for status command execution.
// Using a struct enables easier testing with mock implementations.
type StatusDeps struct {
        WorkspaceMgr WorkspaceLister
        TaskStore    TaskLister
}

// AddStatusCommand adds the status command to the root command.
func AddStatusCommand(parent *cobra.Command) <span class="cov0" title="0">{
        var watchMode bool
        var watchInterval time.Duration
        var showProgress bool

        cmd := &amp;cobra.Command{
                Use:   "status",
                Short: "Show workspace status dashboard",
                Long: `Display status of all ATLAS workspaces with their current task state,
showing which workspaces need attention, are running, or completed.

The status table shows:
  • WORKSPACE - Name of the workspace
  • BRANCH    - Git branch being worked on
  • STATUS    - Current task status with icon
  • STEP      - Progress as current/total steps
  • ACTION    - Suggested next action if any

Workspaces are sorted by priority: attention-required states first,
then running states, then others.

Watch mode (-w) enables live updates with automatic refresh.
Progress mode (-p) shows visual progress bars for active tasks.

Examples:
  atlas status              # Display styled status table
  atlas status --output json # Display as JSON array
  atlas status --quiet      # Show table only (no header/footer)
  atlas status --watch      # Live updating dashboard
  atlas status -w --interval 5s # Update every 5 seconds
  atlas status --progress   # Show progress bars for active tasks
  atlas status -w -p        # Watch mode with progress bars`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runStatus(cmd.Context(), cmd, os.Stdout, statusOptions{
                                WatchMode:     watchMode,
                                WatchInterval: watchInterval,
                                ShowProgress:  showProgress,
                        })
                }</span>,
        }

        // Watch mode flags
        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;watchMode, "watch", "w", false, "Enable watch mode with live updates")
        cmd.Flags().DurationVar(&amp;watchInterval, "interval", DefaultWatchInterval, "Refresh interval in watch mode (minimum 500ms)")
        cmd.Flags().BoolVarP(&amp;showProgress, "progress", "p", false, "Show progress bars for active tasks")

        parent.AddCommand(cmd)</span>
}

// runStatus executes the status command with production dependencies.
func runStatus(ctx context.Context, cmd *cobra.Command, w io.Writer, opts statusOptions) error <span class="cov0" title="0">{
        // Check for cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("status command canceled: %w", ctx.Err())</span>
        default:<span class="cov0" title="0"></span>
        }

        // Get flags
        <span class="cov0" title="0">output := cmd.Flag("output").Value.String()
        quiet := cmd.Flag("quiet").Value.String() == "true"

        // Respect NO_COLOR
        tui.CheckNoColor()

        logger := Logger()

        // Create production dependencies
        wsStore, err := workspace.NewFileStore("")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create workspace store: %w", err)
        }</span>

        <span class="cov0" title="0">wsMgr := workspace.NewManager(wsStore, nil, logger)

        taskStore, err := task.NewFileStore("")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create task store: %w", err)
        }</span>

        // Handle watch mode
        <span class="cov0" title="0">if opts.WatchMode </span><span class="cov0" title="0">{
                // Validate interval
                if opts.WatchInterval &lt; MinWatchInterval </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: minimum is %v", errors.ErrWatchIntervalTooShort, MinWatchInterval)
                }</span>

                // Watch mode doesn't support JSON output
                <span class="cov0" title="0">if output == OutputJSON </span><span class="cov0" title="0">{
                        return errors.ErrWatchModeJSONUnsupported
                }</span>

                <span class="cov0" title="0">return runWatchMode(ctx, wsMgr, taskStore, opts.WatchInterval, quiet, opts.ShowProgress)</span>
        }

        <span class="cov0" title="0">renderOpts := StatusRenderOptions{
                Output:       output,
                Quiet:        quiet,
                ShowProgress: opts.ShowProgress,
        }
        deps := StatusDeps{
                WorkspaceMgr: wsMgr,
                TaskStore:    taskStore,
        }
        return runStatusWithDeps(ctx, w, renderOpts, deps)</span>
}

// runStatusWithDeps executes the status command with injected dependencies.
// This enables testing with mock implementations.
func runStatusWithDeps(
        ctx context.Context,
        w io.Writer,
        opts StatusRenderOptions,
        deps StatusDeps,
) error <span class="cov0" title="0">{
        // Check for cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("status check canceled: %w", ctx.Err())</span>
        default:<span class="cov0" title="0"></span>
        }

        // Load workspaces
        <span class="cov0" title="0">workspaces, err := deps.WorkspaceMgr.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list workspaces: %w", err)
        }</span>

        // Handle empty case
        <span class="cov0" title="0">if len(workspaces) == 0 </span><span class="cov0" title="0">{
                if opts.Output == OutputJSON </span><span class="cov0" title="0">{
                        // Story 7.9: Use structured JSON format for consistency
                        emptyOutput := hierarchicalJSONOutput{
                                Workspaces: []tui.HierarchicalJSONWorkspace{},
                        }
                        encoder := json.NewEncoder(w)
                        encoder.SetIndent("", "  ")
                        return encoder.Encode(emptyOutput)
                }</span>
                <span class="cov0" title="0">_, _ = fmt.Fprintln(w, "No workspaces. Run 'atlas start' to create one.")
                return nil</span>
        }

        // Build hierarchical workspace groups
        <span class="cov0" title="0">groups, err := buildWorkspaceGroups(ctx, workspaces, deps.TaskStore)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build workspace groups: %w", err)
        }</span>

        // Sort by status priority (attention first)
        <span class="cov0" title="0">sortGroupsByStatusPriority(groups)

        // Output based on format
        if opts.Output == OutputJSON </span><span class="cov0" title="0">{
                return outputHierarchicalJSON(w, groups)
        }</span>

        <span class="cov0" title="0">return outputHierarchicalTable(w, groups, opts.Quiet, opts.ShowProgress)</span>
}

// buildWorkspaceGroups builds hierarchical workspace groups from workspaces.
// Each workspace includes all its tasks for nested display.
func buildWorkspaceGroups(
        ctx context.Context,
        workspaces []*domain.Workspace,
        taskStore TaskLister,
) ([]tui.WorkspaceGroup, error) <span class="cov0" title="0">{
        groups := make([]tui.WorkspaceGroup, 0, len(workspaces))

        for _, ws := range workspaces </span><span class="cov0" title="0">{
                // Check for cancellation during iteration
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, fmt.Errorf("building workspace groups canceled: %w", ctx.Err())</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">group := tui.WorkspaceGroup{
                        Name:   ws.Name,
                        Branch: ws.Branch,
                        Status: constants.TaskStatusPending, // Default
                }

                // Load all tasks for the workspace
                tasks, err := taskStore.List(ctx, ws.Name)
                if err == nil &amp;&amp; len(tasks) &gt; 0 </span><span class="cov0" title="0">{
                        group.TotalTasks = len(tasks)
                        group.Status = tasks[0].Status // Aggregate status from most recent

                        // Build task info list
                        group.Tasks = make([]tui.TaskInfo, len(tasks))
                        for i, t := range tasks </span><span class="cov0" title="0">{
                                group.Tasks[i] = tui.TaskInfo{
                                        ID:          t.ID,
                                        Path:        taskPath(ws.Name, t.ID),
                                        Template:    t.TemplateID,
                                        Status:      t.Status,
                                        CurrentStep: t.CurrentStep + 1, // 1-indexed for display
                                        TotalSteps:  len(t.Steps),
                                }
                        }</span>
                }

                <span class="cov0" title="0">groups = append(groups, group)</span>
        }

        <span class="cov0" title="0">return groups, nil</span>
}

// taskPath computes the full file system path to a task directory.
// Used for generating clickable hyperlinks in terminals that support OSC 8.
// Task data is stored in ~/.atlas/, not the project directory.
func taskPath(workspaceName, taskID string) string <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return filepath.Join(homeDir, ".atlas", constants.WorkspacesDir, workspaceName, constants.TasksDir, taskID)</span>
}

// sortByStatusPriority sorts rows by status priority (attention first, then running).
func sortByStatusPriority(rows []tui.StatusRow) <span class="cov0" title="0">{
        sort.SliceStable(rows, func(i, j int) bool </span><span class="cov0" title="0">{
                return statusPriority(rows[i].Status) &gt; statusPriority(rows[j].Status)
        }</span>)
}

// sortGroupsByStatusPriority sorts workspace groups by status priority.
func sortGroupsByStatusPriority(groups []tui.WorkspaceGroup) <span class="cov0" title="0">{
        sort.SliceStable(groups, func(i, j int) bool </span><span class="cov0" title="0">{
                return statusPriority(groups[i].Status) &gt; statusPriority(groups[j].Status)
        }</span>)
}

// statusPriority returns the priority level for a task status.
// Higher values = higher priority (shown first).
func statusPriority(status constants.TaskStatus) int <span class="cov0" title="0">{
        if tui.IsAttentionStatus(status) </span><span class="cov0" title="0">{
                return 2 // Highest priority
        }</span>
        <span class="cov0" title="0">if status == constants.TaskStatusRunning || status == constants.TaskStatusValidating </span><span class="cov0" title="0">{
                return 1 // Middle priority
        }</span>
        <span class="cov0" title="0">return 0</span> // Lowest priority
}

// hierarchicalJSONOutput is the structured JSON output with nested tasks.
type hierarchicalJSONOutput struct {
        Workspaces     []tui.HierarchicalJSONWorkspace `json:"workspaces"`
        AttentionItems []attentionItem                 `json:"attention_items,omitempty"`
}

// attentionItem represents an item that needs user attention.
type attentionItem struct {
        Workspace string `json:"workspace"`
        TaskID    string `json:"task_id"`
        Status    string `json:"status"`
        Action    string `json:"action"`
}

// toLowerCamelCase converts UPPER_CASE to lowercase.
func toLowerCamelCase(s string) string <span class="cov0" title="0">{
        switch s </span>{
        case "WORKSPACE":<span class="cov0" title="0">
                return "workspace"</span>
        case "BRANCH":<span class="cov0" title="0">
                return "branch"</span>
        case "STATUS":<span class="cov0" title="0">
                return "status"</span>
        case "STEP":<span class="cov0" title="0">
                return "step"</span>
        case "ACTION":<span class="cov0" title="0">
                return "action"</span>
        default:<span class="cov0" title="0">
                return s</span>
        }
}

// outputHierarchicalJSON outputs status as hierarchical JSON with nested tasks.
func outputHierarchicalJSON(w io.Writer, groups []tui.WorkspaceGroup) error <span class="cov0" title="0">{
        table := tui.NewHierarchicalStatusTable(groups)

        // Build attention items
        var attention []attentionItem
        for _, group := range groups </span><span class="cov0" title="0">{
                for _, task := range group.Tasks </span><span class="cov0" title="0">{
                        if tui.IsAttentionStatus(task.Status) </span><span class="cov0" title="0">{
                                action := tui.SuggestedAction(task.Status)
                                if action != "" </span><span class="cov0" title="0">{
                                        attention = append(attention, attentionItem{
                                                Workspace: group.Name,
                                                TaskID:    task.ID,
                                                Status:    string(task.Status),
                                                Action:    fmt.Sprintf("%s %s", action, group.Name),
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">output := hierarchicalJSONOutput{
                Workspaces:     table.ToJSONData(),
                AttentionItems: attention,
        }

        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(output)</span>
}

// outputHierarchicalTable outputs status as hierarchical table with nested tasks.
func outputHierarchicalTable(w io.Writer, groups []tui.WorkspaceGroup, quiet, showProgress bool) error <span class="cov0" title="0">{
        table := tui.NewHierarchicalStatusTable(groups)

        // Header (unless quiet)
        if !quiet </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, tui.RenderHeaderAuto())
                _, _ = fmt.Fprintln(w)
        }</span>

        // Hierarchical table
        <span class="cov0" title="0">if err := table.Render(w); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("render hierarchical table: %w", err)
        }</span>

        // Progress bars (if enabled)
        <span class="cov0" title="0">if showProgress </span><span class="cov0" title="0">{
                progressRows := buildProgressRowsFromGroups(groups)
                if len(progressRows) &gt; 0 </span><span class="cov0" title="0">{
                        _, _ = fmt.Fprintln(w)
                        pd := tui.NewProgressDashboard(progressRows)
                        _ = pd.Render(w)
                }</span>
        }

        // Footer summary (unless quiet)
        <span class="cov0" title="0">if !quiet </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w)
                _, _ = fmt.Fprintln(w, buildHierarchicalFooter(groups))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// buildProgressRowsFromGroups converts workspace groups to progress rows.
func buildProgressRowsFromGroups(groups []tui.WorkspaceGroup) []tui.ProgressRow <span class="cov0" title="0">{
        var progressRows []tui.ProgressRow
        for _, group := range groups </span><span class="cov0" title="0">{
                for _, task := range group.Tasks </span><span class="cov0" title="0">{
                        if task.Status == constants.TaskStatusRunning || task.Status == constants.TaskStatusValidating </span><span class="cov0" title="0">{
                                percent := 0.0
                                if task.TotalSteps &gt; 0 </span><span class="cov0" title="0">{
                                        percent = float64(task.CurrentStep) / float64(task.TotalSteps)
                                }</span>
                                <span class="cov0" title="0">progressRows = append(progressRows, tui.ProgressRow{
                                        Name:        fmt.Sprintf("%s/%s", group.Name, task.ID),
                                        Percent:     percent,
                                        CurrentStep: task.CurrentStep,
                                        TotalSteps:  task.TotalSteps,
                                        StepName:    task.Template,
                                })</span>
                        }
                }
        }
        <span class="cov0" title="0">return progressRows</span>
}

// buildHierarchicalFooter creates the footer summary for hierarchical display.
func buildHierarchicalFooter(groups []tui.WorkspaceGroup) string <span class="cov0" title="0">{
        attentionCount := 0
        var firstAttention *tui.WorkspaceGroup

        for i := range groups </span><span class="cov0" title="0">{
                if tui.IsAttentionStatus(groups[i].Status) </span><span class="cov0" title="0">{
                        attentionCount++
                        if firstAttention == nil </span><span class="cov0" title="0">{
                                firstAttention = &amp;groups[i]
                        }</span>
                }
        }

        // Count total tasks
        <span class="cov0" title="0">totalTasks := 0
        for _, group := range groups </span><span class="cov0" title="0">{
                totalTasks += group.TotalTasks
        }</span>

        // Summary line
        <span class="cov0" title="0">workspaceWord := "workspaces"
        if len(groups) == 1 </span><span class="cov0" title="0">{
                workspaceWord = "workspace"
        }</span>
        <span class="cov0" title="0">taskWord := "tasks"
        if totalTasks == 1 </span><span class="cov0" title="0">{
                taskWord = "task"
        }</span>
        <span class="cov0" title="0">summary := fmt.Sprintf("%d %s, %d %s", len(groups), workspaceWord, totalTasks, taskWord)

        if attentionCount &gt; 0 </span><span class="cov0" title="0">{
                needWord := "need"
                if attentionCount == 1 </span><span class="cov0" title="0">{
                        needWord = "needs"
                }</span>
                <span class="cov0" title="0">summary += fmt.Sprintf(", %d %s attention", attentionCount, needWord)</span>
        }

        // Actionable command
        <span class="cov0" title="0">if firstAttention != nil </span><span class="cov0" title="0">{
                action := tui.SuggestedAction(firstAttention.Status)
                if action != "" </span><span class="cov0" title="0">{
                        summary += fmt.Sprintf("\nRun: %s %s", action, firstAttention.Name)
                }</span>
        }

        <span class="cov0" title="0">return summary</span>
}

// buildProgressRows converts status rows to progress rows for the dashboard.
// Only includes rows with active tasks (running or validating states).
// Delegates to shared helper in tui package to avoid code duplication.
func buildProgressRows(rows []tui.StatusRow) []tui.ProgressRow <span class="cov0" title="0">{
        return tui.BuildProgressRowsFromStatus(rows)
}</span>

// buildFooter creates the footer summary and actionable command.
func buildFooter(rows []tui.StatusRow) string <span class="cov0" title="0">{
        attentionCount, firstAttention := countAttention(rows)

        // Summary line with proper singular/plural grammar
        workspaceWord := "workspaces"
        if len(rows) == 1 </span><span class="cov0" title="0">{
                workspaceWord = "workspace"
        }</span>
        <span class="cov0" title="0">summary := fmt.Sprintf("%d %s", len(rows), workspaceWord)

        if attentionCount &gt; 0 </span><span class="cov0" title="0">{
                needWord := "need"
                if attentionCount == 1 </span><span class="cov0" title="0">{
                        needWord = "needs"
                }</span>
                <span class="cov0" title="0">summary += fmt.Sprintf(", %d %s attention", attentionCount, needWord)</span>
        }

        // Actionable command
        <span class="cov0" title="0">if firstAttention != nil </span><span class="cov0" title="0">{
                summary += buildActionableSuggestion(firstAttention)
        }</span>

        <span class="cov0" title="0">return summary</span>
}

// countAttention counts workspaces needing attention and returns the first one.
func countAttention(rows []tui.StatusRow) (int, *tui.StatusRow) <span class="cov0" title="0">{
        var count int
        var first *tui.StatusRow

        for i := range rows </span><span class="cov0" title="0">{
                if tui.IsAttentionStatus(rows[i].Status) </span><span class="cov0" title="0">{
                        count++
                        if first == nil </span><span class="cov0" title="0">{
                                first = &amp;rows[i]
                        }</span>
                }
        }

        <span class="cov0" title="0">return count, first</span>
}

// buildActionableSuggestion builds the "Run: ..." suggestion for a workspace.
// Always includes the workspace name for consistency.
func buildActionableSuggestion(row *tui.StatusRow) string <span class="cov0" title="0">{
        action := tui.SuggestedAction(row.Status)
        if action == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // All actions include the workspace name for consistency
        <span class="cov0" title="0">return fmt.Sprintf("\nRun: %s %s", action, row.Workspace)</span>
}

// runWatchMode starts the watch mode TUI with live updates.
func runWatchMode(ctx context.Context, wsMgr tui.WorkspaceLister, taskStore tui.TaskLister, interval time.Duration, quiet, showProgress bool) error <span class="cov0" title="0">{
        // Load config to get bell preference
        cfg, err := config.Load(ctx)
        bellEnabled := true // Default to enabled
        if err == nil </span><span class="cov0" title="0">{
                bellEnabled = cfg.Notifications.Bell
        }</span>

        // Create watch config
        <span class="cov0" title="0">watchCfg := tui.WatchConfig{
                Interval:     interval,
                BellEnabled:  bellEnabled,
                Quiet:        quiet,
                ShowProgress: showProgress,
        }

        // Create the watch model with context for proper cancellation propagation
        model := tui.NewWatchModel(ctx, wsMgr, taskStore, watchCfg)

        // Create and run the Bubble Tea program with alternate screen and context
        p := tea.NewProgram(model, tea.WithAltScreen(), tea.WithContext(ctx))

        _, err = p.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("run watch mode: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file30" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "fmt"
        "io"
        "os"

        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/spf13/cobra"
)

// AddTestCommand adds the test command to the root command.
func AddTestCommand(root *cobra.Command) <span class="cov0" title="0">{
        root.AddCommand(newTestCmd())
}</span>

func newTestCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "test",
                Short: "Run tests",
                Long: `Run configured test commands on the current directory.

Uses 'magex test' by default if no test commands are configured.

Examples:
  atlas test
  atlas test --output json
  atlas test --verbose`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runTest(cmd.Context(), cmd, os.Stdout)
                }</span>,
        }

        <span class="cov0" title="0">return cmd</span>
}

func runTest(ctx context.Context, cmd *cobra.Command, w io.Writer) error <span class="cov0" title="0">{
        // Check context cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">logger := Logger()
        outputFormat := cmd.Flag("output").Value.String()
        verbose := cmd.Flag("verbose").Value.String() == "true"
        tui.CheckNoColor()

        out := tui.NewOutput(w, outputFormat)

        // Load config
        cfg, err := config.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("failed to load config, using defaults")
                cfg = config.DefaultConfig()
        }</span>

        // Get test commands
        <span class="cov0" title="0">commands := cfg.Validation.Commands.Test
        if len(commands) == 0 </span><span class="cov0" title="0">{
                commands = []string{constants.DefaultTestCommand}
        }</span>

        <span class="cov0" title="0">workDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get working directory: %w", err)
        }</span>

        <span class="cov0" title="0">opts := UtilityOptions{
                Verbose:      verbose,
                OutputFormat: outputFormat,
                Writer:       w,
        }

        return runCommandsWithOutput(ctx, commands, workDir, "Test", out, opts, logger)</span>
}
</pre>

		<pre class="file" id="file31" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "github.com/charmbracelet/huh"
        "github.com/charmbracelet/lipgloss"
        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/spf13/cobra"
        "golang.org/x/sync/errgroup"
)

// UpgradeFlags holds flags specific to the upgrade command.
type UpgradeFlags struct {
        // Check performs a dry-run, showing updates without installing.
        Check bool
        // Yes skips confirmation prompts.
        Yes bool
        // OutputFormat specifies the output format (text or json).
        OutputFormat string
}

// UpdateInfo contains version information for a single tool.
type UpdateInfo struct {
        // Name is the tool name.
        Name string `json:"name"`
        // CurrentVersion is the currently installed version.
        CurrentVersion string `json:"current_version"`
        // LatestVersion is the latest available version (may be empty if unknown).
        LatestVersion string `json:"latest_version,omitempty"`
        // UpdateAvailable indicates if an update is available.
        UpdateAvailable bool `json:"update_available"`
        // Installed indicates if the tool is currently installed.
        Installed bool `json:"installed"`
        // InstallPath is the go install path for the tool.
        InstallPath string `json:"-"`
}

// UpgradeResult contains the result of upgrading a single tool.
type UpgradeResult struct {
        // Tool is the tool name.
        Tool string `json:"tool"`
        // Success indicates if the upgrade was successful.
        Success bool `json:"success"`
        // Error contains the error message if the upgrade failed.
        Error string `json:"error,omitempty"`
        // OldVersion is the version before upgrade.
        OldVersion string `json:"old_version"`
        // NewVersion is the version after upgrade (if successful).
        NewVersion string `json:"new_version,omitempty"`
        // Warnings contains non-fatal warning messages.
        Warnings []string `json:"warnings,omitempty"`
}

// UpdateCheckResult contains the results of checking for updates.
type UpdateCheckResult struct {
        // UpdatesAvailable indicates if any updates are available.
        UpdatesAvailable bool `json:"updates_available"`
        // Tools contains the update info for each tool.
        Tools []UpdateInfo `json:"tools"`
}

// UpgradeChecker defines the interface for checking tool updates.
type UpgradeChecker interface {
        // CheckAllUpdates checks for updates to all tools.
        CheckAllUpdates(ctx context.Context) (*UpdateCheckResult, error)
        // CheckToolUpdate checks for updates to a specific tool.
        CheckToolUpdate(ctx context.Context, tool string) (*UpdateInfo, error)
}

// UpgradeExecutor defines the interface for executing tool upgrades.
type UpgradeExecutor interface {
        // UpgradeTool upgrades a specific tool.
        UpgradeTool(ctx context.Context, tool string) (*UpgradeResult, error)
        // BackupConstitution backs up the Speckit constitution.md file.
        BackupConstitution() (string, error)
        // RestoreConstitution restores the Speckit constitution.md file from backup.
        RestoreConstitution(originalPath string) error
        // CleanupConstitutionBackup removes the constitution.md backup file.
        CleanupConstitutionBackup(originalPath string) error
}

// upgradeStyles contains styling for the upgrade command output.
type upgradeStyles struct {
        header     lipgloss.Style
        toolName   lipgloss.Style
        version    lipgloss.Style
        updateAvl  lipgloss.Style
        upToDate   lipgloss.Style
        success    lipgloss.Style
        err        lipgloss.Style
        info       lipgloss.Style
        dim        lipgloss.Style
        spinner    lipgloss.Style
        installing lipgloss.Style
}

// newUpgradeStyles creates styles for upgrade command output.
func newUpgradeStyles() *upgradeStyles <span class="cov0" title="0">{
        return &amp;upgradeStyles{
                header: lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("#00D7FF")).
                        MarginBottom(1),
                toolName: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFFFFF")),
                version: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#888888")),
                updateAvl: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFD700")), // Yellow for update available
                upToDate: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00FF87")), // Green for up to date
                success: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00FF87")).
                        Bold(true),
                err: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FF5F5F")).
                        Bold(true),
                info: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00D7FF")),
                dim: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#666666")),
                spinner: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#00D7FF")),
                installing: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFD700")),
        }
}</span>

// upgradeCmd holds the dependencies for the upgrade command.
type upgradeCmd struct {
        flags    *UpgradeFlags
        checker  UpgradeChecker
        executor UpgradeExecutor
        styles   *upgradeStyles
        w        io.Writer
}

// getValidToolNames returns the list of valid tool names for upgrade.
func getValidToolNames() []string <span class="cov0" title="0">{
        return []string{
                constants.ToolAtlas,
                constants.ToolMageX,
                constants.ToolGoPreCommit,
                constants.ToolSpeckit,
        }
}</span>

// newUpgradeCmd creates the upgrade command for updating ATLAS and managed tools.
func newUpgradeCmd(flags *UpgradeFlags) *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "upgrade [tool]",
                Short: "Upgrade ATLAS and managed tools",
                Long: `Upgrade ATLAS and its managed tools to their latest versions.

By default, checks and upgrades all tools:
  - atlas: The ATLAS CLI itself
  - mage-x: Build automation tool
  - go-pre-commit: Git hooks tool
  - speckit: Specification tool

You can upgrade a specific tool by providing its name as an argument.

For Speckit upgrades, constitution.md is automatically backed up and restored.

Examples:
  atlas upgrade              # Check and upgrade all tools
  atlas upgrade --check      # Only check for updates (dry-run)
  atlas upgrade -y           # Upgrade without confirmation
  atlas upgrade speckit      # Upgrade only Speckit
  atlas upgrade atlas        # Upgrade only ATLAS itself
  atlas upgrade --check --output json   # Check for updates in JSON format`,
                Args: cobra.MaximumNArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        var tool string
                        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                                tool = args[0]
                                // Validate tool name
                                if !isValidTool(tool) </span><span class="cov0" title="0">{
                                        validNames := getValidToolNames()
                                        return fmt.Errorf("%w: %q (valid options: %s)", errors.ErrInvalidToolName, tool, strings.Join(validNames, ", "))
                                }</span>
                        }
                        <span class="cov0" title="0">return runUpgrade(cmd.Context(), cmd.OutOrStdout(), flags, tool)</span>
                },
                SilenceUsage: true,
        }

        // Add flags
        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;flags.Check, "check", "c", false, "only check for updates without installing")
        cmd.Flags().BoolVarP(&amp;flags.Yes, "yes", "y", false, "skip confirmation prompt")
        cmd.Flags().StringVarP(&amp;flags.OutputFormat, "output", "o", "text", "output format (text or json)")

        return cmd</span>
}

// AddUpgradeCommand adds the upgrade command to the root command.
func AddUpgradeCommand(rootCmd *cobra.Command) <span class="cov0" title="0">{
        flags := &amp;UpgradeFlags{}
        rootCmd.AddCommand(newUpgradeCmd(flags))
}</span>

// isValidTool checks if the provided tool name is valid.
func isValidTool(tool string) bool <span class="cov0" title="0">{
        for _, valid := range getValidToolNames() </span><span class="cov0" title="0">{
                if tool == valid </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// runUpgrade executes the upgrade command with default dependencies.
func runUpgrade(ctx context.Context, w io.Writer, flags *UpgradeFlags, tool string) error <span class="cov0" title="0">{
        executor := &amp;DefaultCommandExecutor{}
        checker := NewDefaultUpgradeChecker(executor)
        upgradeExec := NewDefaultUpgradeExecutor(executor)

        return runUpgradeWithDeps(ctx, w, flags, tool, checker, upgradeExec)
}</span>

// runUpgradeWithDeps executes the upgrade command with custom dependencies.
// This allows for mocking in tests.
func runUpgradeWithDeps(ctx context.Context, w io.Writer, flags *UpgradeFlags, tool string, checker UpgradeChecker, executor UpgradeExecutor) error <span class="cov0" title="0">{
        // Check cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">cmd := &amp;upgradeCmd{
                flags:    flags,
                checker:  checker,
                executor: executor,
                styles:   newUpgradeStyles(),
                w:        w,
        }

        return cmd.run(ctx, tool)</span>
}

// run executes the upgrade command logic.
func (u *upgradeCmd) run(ctx context.Context, tool string) error <span class="cov0" title="0">{
        // Check for updates
        checkResult, err := u.checkForUpdates(ctx, tool)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Handle JSON output mode
        <span class="cov0" title="0">if strings.ToLower(u.flags.OutputFormat) == "json" </span><span class="cov0" title="0">{
                return u.handleJSONOutput(checkResult)
        }</span>

        // Display update check results (text mode)
        <span class="cov0" title="0">u.displayUpdateTable(checkResult)

        // Handle --check mode (dry-run)
        if u.flags.Check </span><span class="cov0" title="0">{
                return u.handleCheckMode(checkResult)
        }</span>

        // Get tools that need upgrades
        <span class="cov0" title="0">toolsToUpgrade := u.getToolsToUpgrade(checkResult)
        if len(toolsToUpgrade) == 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(u.w)
                _, _ = fmt.Fprintln(u.w, u.styles.success.Render("✓ All installed tools are up to date."))
                return nil
        }</span>

        // Prompt for confirmation and execute upgrades
        <span class="cov0" title="0">return u.confirmAndExecuteUpgrades(ctx, toolsToUpgrade)</span>
}

// checkForUpdates checks for updates to the specified tool or all tools.
func (u *upgradeCmd) checkForUpdates(ctx context.Context, tool string) (*UpdateCheckResult, error) <span class="cov0" title="0">{
        if tool != "" </span><span class="cov0" title="0">{
                info, err := u.checker.CheckToolUpdate(ctx, tool)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to check for updates: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;UpdateCheckResult{
                        UpdatesAvailable: info.UpdateAvailable,
                        Tools:            []UpdateInfo{*info},
                }, nil</span>
        }

        <span class="cov0" title="0">result, err := u.checker.CheckAllUpdates(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check for updates: %w", err)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// handleJSONOutput outputs results in JSON format and handles exit codes.
func (u *upgradeCmd) handleJSONOutput(checkResult *UpdateCheckResult) error <span class="cov0" title="0">{
        if err := u.outputJSON(checkResult); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // For --check mode with JSON output, return exit code 1 if updates available (for scripting)
        <span class="cov0" title="0">if u.flags.Check &amp;&amp; checkResult.UpdatesAvailable </span><span class="cov0" title="0">{
                return &amp;ExitCodeError{Code: 1, Err: nil}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// handleCheckMode handles the --check flag (dry-run mode).
func (u *upgradeCmd) handleCheckMode(checkResult *UpdateCheckResult) error <span class="cov0" title="0">{
        if checkResult.UpdatesAvailable </span><span class="cov0" title="0">{
                return &amp;ExitCodeError{Code: 1, Err: nil} // Exit code 1 if updates available (for scripting)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// getToolsToUpgrade returns the list of tools that need upgrades.
func (u *upgradeCmd) getToolsToUpgrade(checkResult *UpdateCheckResult) []UpdateInfo <span class="cov0" title="0">{
        if !checkResult.UpdatesAvailable </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(u.w)
                _, _ = fmt.Fprintln(u.w, u.styles.success.Render("✓ All tools are up to date."))
                return nil
        }</span>

        <span class="cov0" title="0">var toolsToUpgrade []UpdateInfo
        for _, t := range checkResult.Tools </span><span class="cov0" title="0">{
                if t.UpdateAvailable &amp;&amp; t.Installed </span><span class="cov0" title="0">{
                        toolsToUpgrade = append(toolsToUpgrade, t)
                }</span>
        }
        <span class="cov0" title="0">return toolsToUpgrade</span>
}

// confirmAndExecuteUpgrades prompts for confirmation and executes upgrades.
func (u *upgradeCmd) confirmAndExecuteUpgrades(ctx context.Context, toolsToUpgrade []UpdateInfo) error <span class="cov0" title="0">{
        if !u.flags.Yes </span><span class="cov0" title="0">{
                confirmed, err := u.promptConfirmation(len(toolsToUpgrade))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to prompt for confirmation: %w", err)
                }</span>
                <span class="cov0" title="0">if !confirmed </span><span class="cov0" title="0">{
                        _, _ = fmt.Fprintln(u.w, u.styles.dim.Render("Upgrade canceled."))
                        return nil
                }</span>
        }

        <span class="cov0" title="0">results := u.executeUpgrades(ctx, toolsToUpgrade)
        u.displayUpgradeResults(results)
        return nil</span>
}

// displayUpdateTable displays the update check results in a formatted table.
func (u *upgradeCmd) displayUpdateTable(result *UpdateCheckResult) <span class="cov0" title="0">{
        _, _ = fmt.Fprintln(u.w, u.styles.header.Render("ATLAS Upgrade Check"))
        _, _ = fmt.Fprintln(u.w)
        _, _ = fmt.Fprintln(u.w, u.styles.info.Render("Current versions:"))

        for _, tool := range result.Tools </span><span class="cov0" title="0">{
                statusStr := u.formatToolStatus(tool)
                version := tool.CurrentVersion
                if version == "" </span><span class="cov0" title="0">{
                        version = "(not installed)"
                }</span>

                // Check if version contains multiple lines (e.g., ASCII art from --version)
                <span class="cov0" title="0">if strings.Contains(version, "\n") </span><span class="cov0" title="0">{
                        // Print tool name on its own line
                        _, _ = fmt.Fprintf(u.w, "  %s\n", u.styles.toolName.Render(tool.Name))
                        // Print multi-line version info
                        _, _ = fmt.Fprintln(u.w, u.styles.version.Render(version))
                        // Print status
                        _, _ = fmt.Fprintln(u.w, statusStr)
                }</span> else<span class="cov0" title="0"> {
                        // Single-line version: print on same line as tool name
                        name := fmt.Sprintf("  %-17s", tool.Name)
                        _, _ = fmt.Fprintf(u.w, "%s %s  %s\n",
                                u.styles.toolName.Render(name),
                                u.styles.version.Render(fmt.Sprintf("%-12s", version)),
                                statusStr)
                }</span>
        }
        <span class="cov0" title="0">_, _ = fmt.Fprintln(u.w)</span>
}

// formatToolStatus returns a styled status string for a tool.
func (u *upgradeCmd) formatToolStatus(tool UpdateInfo) string <span class="cov0" title="0">{
        if !tool.Installed </span><span class="cov0" title="0">{
                return u.styles.dim.Render("(not installed)")
        }</span>
        <span class="cov0" title="0">if tool.UpdateAvailable </span><span class="cov0" title="0">{
                if tool.LatestVersion != "" </span><span class="cov0" title="0">{
                        return u.styles.updateAvl.Render(fmt.Sprintf("→ %s (update available)", tool.LatestVersion))
                }</span>
                // MVP: We don't fetch latest version from registry, upgrade will determine if update occurred
                <span class="cov0" title="0">return u.styles.info.Render("(installed, upgrade to check)")</span>
        }
        <span class="cov0" title="0">return u.styles.upToDate.Render("✓ latest")</span>
}

// outputJSON outputs the update check result in JSON format.
func (u *upgradeCmd) outputJSON(result *UpdateCheckResult) error <span class="cov0" title="0">{
        encoder := json.NewEncoder(u.w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(result)
}</span>

// promptConfirmation prompts the user to confirm the upgrade.
func (u *upgradeCmd) promptConfirmation(count int) (bool, error) <span class="cov0" title="0">{
        _, _ = fmt.Fprintln(u.w)

        var confirm bool
        title := fmt.Sprintf("Upgrade %d tool(s)?", count)

        form := huh.NewForm(
                huh.NewGroup(
                        huh.NewConfirm().
                                Title(title).
                                Affirmative("Yes").
                                Negative("No").
                                Value(&amp;confirm),
                ),
        ).WithTheme(tui.AtlasTheme())

        if err := form.Run(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return confirm, nil</span>
}

// executeUpgrades performs the actual upgrades for the specified tools.
func (u *upgradeCmd) executeUpgrades(ctx context.Context, tools []UpdateInfo) []UpgradeResult <span class="cov0" title="0">{
        results := make([]UpgradeResult, 0, len(tools))
        _, _ = fmt.Fprintln(u.w)

        for _, tool := range tools </span><span class="cov0" title="0">{
                // Check context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        results = append(results, UpgradeResult{
                                Tool:       tool.Name,
                                Success:    false,
                                Error:      "canceled",
                                OldVersion: tool.CurrentVersion,
                        })
                        continue</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">_, _ = fmt.Fprintf(u.w, "%s %s...\n",
                        u.styles.installing.Render("Upgrading"),
                        u.styles.toolName.Render(tool.Name))

                result, err := u.executor.UpgradeTool(ctx, tool.Name)
                if err != nil </span><span class="cov0" title="0">{
                        results = append(results, UpgradeResult{
                                Tool:       tool.Name,
                                Success:    false,
                                Error:      err.Error(),
                                OldVersion: tool.CurrentVersion,
                        })
                        _, _ = fmt.Fprintf(u.w, "  %s\n", u.styles.err.Render("✗ Failed: "+err.Error()))
                }</span> else<span class="cov0" title="0"> if !result.Success </span><span class="cov0" title="0">{
                        // UpgradeTool returned nil error but the upgrade failed internally
                        result.OldVersion = tool.CurrentVersion
                        results = append(results, *result)
                        _, _ = fmt.Fprintf(u.w, "  %s\n", u.styles.err.Render("✗ Failed: "+result.Error))
                }</span> else<span class="cov0" title="0"> {
                        result.OldVersion = tool.CurrentVersion
                        results = append(results, *result)
                        _, _ = fmt.Fprintf(u.w, "  %s\n", u.styles.success.Render("✓ Success"))
                        // Display any warnings
                        for _, warning := range result.Warnings </span><span class="cov0" title="0">{
                                _, _ = fmt.Fprintf(u.w, "  %s\n", u.styles.dim.Render(warning))
                        }</span>
                }
        }

        <span class="cov0" title="0">return results</span>
}

// displayUpgradeResults displays the final upgrade results.
func (u *upgradeCmd) displayUpgradeResults(results []UpgradeResult) <span class="cov0" title="0">{
        _, _ = fmt.Fprintln(u.w)

        successCount := 0
        failCount := 0
        var failedTools []string
        for _, r := range results </span><span class="cov0" title="0">{
                if r.Success </span><span class="cov0" title="0">{
                        successCount++
                }</span> else<span class="cov0" title="0"> {
                        failCount++
                        failedTools = append(failedTools, r.Tool)
                }</span>
        }

        <span class="cov0" title="0">if failCount == 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(u.w, u.styles.success.Render("✓ All upgrades completed successfully."))
        }</span> else<span class="cov0" title="0"> if successCount == 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(u.w, u.styles.err.Render("✗ All upgrades failed."))
                u.displayRollbackInfo(failedTools)
        }</span> else<span class="cov0" title="0"> {
                _, _ = fmt.Fprintf(u.w, "%s %d succeeded, %d failed.\n",
                        u.styles.info.Render("Upgrade results:"),
                        successCount, failCount)
                u.displayRollbackInfo(failedTools)
        }</span>
}

// displayRollbackInfo shows recovery guidance when upgrades fail.
func (u *upgradeCmd) displayRollbackInfo(failedTools []string) <span class="cov0" title="0">{
        _, _ = fmt.Fprintln(u.w)
        _, _ = fmt.Fprintln(u.w, u.styles.info.Render("Recovery options:"))
        _, _ = fmt.Fprintln(u.w, u.styles.dim.Render("  • Retry failed upgrades: atlas upgrade &lt;tool-name&gt;"))
        _, _ = fmt.Fprintln(u.w, u.styles.dim.Render("  • Check network connectivity and Go installation"))
        _, _ = fmt.Fprintln(u.w, u.styles.dim.Render("  • Manual install: go install &lt;package&gt;@latest"))
        if len(failedTools) &gt; 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(u.w, "%s %s\n",
                        u.styles.dim.Render("  • Failed tools:"),
                        u.styles.err.Render(strings.Join(failedTools, ", ")))
        }</span>
}

// DefaultUpgradeChecker implements UpgradeChecker using the tool detector.
type DefaultUpgradeChecker struct {
        executor config.CommandExecutor
}

// NewDefaultUpgradeChecker creates a new DefaultUpgradeChecker.
func NewDefaultUpgradeChecker(executor config.CommandExecutor) *DefaultUpgradeChecker <span class="cov0" title="0">{
        return &amp;DefaultUpgradeChecker{executor: executor}
}</span>

// CheckAllUpdates checks for updates to all tools in parallel.
func (c *DefaultUpgradeChecker) CheckAllUpdates(ctx context.Context) (*UpdateCheckResult, error) <span class="cov0" title="0">{
        // Check context cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">tools := getUpgradableTools()
        result := &amp;UpdateCheckResult{
                Tools: make([]UpdateInfo, 0, len(tools)),
        }
        var resultMu sync.Mutex

        g, gCtx := errgroup.WithContext(ctx)

        for _, tool := range tools </span><span class="cov0" title="0">{
                g.Go(func() error </span><span class="cov0" title="0">{
                        info := c.checkToolUpdate(gCtx, tool)
                        resultMu.Lock()
                        result.Tools = append(result.Tools, info)
                        if info.UpdateAvailable </span><span class="cov0" title="0">{
                                result.UpdatesAvailable = true
                        }</span>
                        <span class="cov0" title="0">resultMu.Unlock()
                        return nil</span>
                })
        }

        <span class="cov0" title="0">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check for updates: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// CheckToolUpdate checks for updates to a specific tool.
func (c *DefaultUpgradeChecker) CheckToolUpdate(ctx context.Context, tool string) (*UpdateInfo, error) <span class="cov0" title="0">{
        // Check context cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">toolConfig := getToolConfig(tool)
        if toolConfig == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %s", errors.ErrUnknownTool, tool)
        }</span>

        <span class="cov0" title="0">info := c.checkToolUpdate(ctx, *toolConfig)
        return &amp;info, nil</span>
}

// upgradableToolConfig holds configuration for an upgradable tool.
type upgradableToolConfig struct {
        name        string
        command     string
        versionFlag string
        installPath string
}

// getUpgradableTools returns the list of tools that can be upgraded.
func getUpgradableTools() []upgradableToolConfig <span class="cov0" title="0">{
        return []upgradableToolConfig{
                {
                        name:        constants.ToolAtlas,
                        command:     "atlas",
                        versionFlag: "--version",
                        installPath: constants.InstallPathAtlas,
                },
                {
                        name:        constants.ToolMageX,
                        command:     constants.ToolMageX,
                        versionFlag: constants.VersionFlagStandard,
                        installPath: constants.InstallPathMageX,
                },
                {
                        name:        constants.ToolGoPreCommit,
                        command:     constants.ToolGoPreCommit,
                        versionFlag: constants.VersionFlagStandard,
                        installPath: constants.InstallPathGoPreCommit,
                },
                {
                        name:        constants.ToolSpeckit,
                        command:     constants.ToolSpeckit,
                        versionFlag: constants.VersionFlagSpeckit,
                        installPath: constants.InstallPathSpeckit,
                },
        }
}</span>

// getToolConfig returns the configuration for a specific tool.
func getToolConfig(name string) *upgradableToolConfig <span class="cov0" title="0">{
        for _, t := range getUpgradableTools() </span><span class="cov0" title="0">{
                if t.name == name </span><span class="cov0" title="0">{
                        return &amp;t
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// checkToolUpdate checks for updates to a single tool.
func (c *DefaultUpgradeChecker) checkToolUpdate(ctx context.Context, tool upgradableToolConfig) UpdateInfo <span class="cov0" title="0">{
        info := UpdateInfo{
                Name:        tool.name,
                InstallPath: tool.installPath,
        }

        // Check if tool exists in PATH
        _, err := c.executor.LookPath(tool.command)
        if err != nil </span><span class="cov0" title="0">{
                info.Installed = false
                info.UpdateAvailable = true // Can be installed
                return info
        }</span>
        <span class="cov0" title="0">info.Installed = true

        // Get current version
        output, err := c.executor.Run(ctx, tool.command, tool.versionFlag)
        if err != nil </span><span class="cov0" title="0">{
                // Tool exists but version command failed
                info.CurrentVersion = "unknown"
                info.UpdateAvailable = true // Assume update is needed
                return info
        }</span>

        <span class="cov0" title="0">info.CurrentVersion = parseVersionFromOutput(tool.name, output)

        // For atlas, fetch the latest version from GitHub
        if tool.name == constants.ToolAtlas </span><span class="cov0" title="0">{
                upgrader := NewAtlasReleaseUpgrader(c.executor)
                if latestVersion, err := upgrader.GetLatestVersion(ctx); err == nil </span><span class="cov0" title="0">{
                        info.LatestVersion = latestVersion
                        info.UpdateAvailable = isNewerVersion(info.CurrentVersion, latestVersion)
                        return info
                }</span>
                // If we can't fetch latest, fall through to default behavior
        }

        // For other tools, we assume an update is potentially available if the tool is installed
        // A more sophisticated approach would query the package registry
        // For now, we'll mark it as "check available" and let the actual upgrade determine if there was a change
        <span class="cov0" title="0">info.UpdateAvailable = true

        return info</span>
}

// parseVersionFromOutput extracts a version string from command output.
func parseVersionFromOutput(tool, output string) string <span class="cov0" title="0">{
        output = strings.TrimSpace(output)
        switch tool </span>{
        case constants.ToolAtlas:<span class="cov0" title="0">
                return parseAtlasVersion(output)</span>
        case constants.ToolSpeckit:<span class="cov0" title="0">
                if version := parseSpeckitVersion(output); version != "" </span><span class="cov0" title="0">{
                        return version
                }</span>
                // Fallthrough to generic parser if format changes
                <span class="cov0" title="0">return parseGenericVersion(output)</span>
        default:<span class="cov0" title="0">
                return parseGenericVersion(output)</span>
        }
}

// parseAtlasVersion extracts version from atlas version output.
func parseAtlasVersion(output string) string <span class="cov0" title="0">{
        // Parse "atlas version X.Y.Z (commit: abc, built: 2024-01-01)" → "X.Y.Z"
        if strings.HasPrefix(output, "atlas version ") </span><span class="cov0" title="0">{
                rest := strings.TrimPrefix(output, "atlas version ")
                if idx := strings.Index(rest, " "); idx &gt; 0 </span><span class="cov0" title="0">{
                        return rest[:idx]
                }</span>
                <span class="cov0" title="0">return rest</span>
        }
        // Fallback: first word
        <span class="cov0" title="0">if idx := strings.Index(output, " "); idx &gt; 0 </span><span class="cov0" title="0">{
                return output[:idx]
        }</span>
        <span class="cov0" title="0">return output</span>
}

// parseSpeckitVersion extracts version from speckit version output.
func parseSpeckitVersion(output string) string <span class="cov0" title="0">{
        // Parse specify version output
        // Example: "CLI Version    1.0.0"
        lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if strings.HasPrefix(strings.ToLower(line), "cli version") </span><span class="cov0" title="0">{
                        // Extract version from "CLI Version    1.0.0"
                        fields := strings.Fields(line)
                        if len(fields) &gt;= 3 </span><span class="cov0" title="0">{
                                return fields[2] // Return "1.0.0"
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// parseGenericVersion extracts version pattern from generic output.
func parseGenericVersion(output string) string <span class="cov0" title="0">{
        // Extract version pattern from output
        lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                // Look for version patterns like "v1.2.3" or "1.2.3"
                for _, word := range strings.Fields(line) </span><span class="cov0" title="0">{
                        word = strings.TrimPrefix(word, "v")
                        if len(word) &gt; 0 &amp;&amp; word[0] &gt;= '0' &amp;&amp; word[0] &lt;= '9' </span><span class="cov0" title="0">{
                                // Check if it looks like a version
                                if strings.Contains(word, ".") </span><span class="cov0" title="0">{
                                        return word
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return output</span>
}

// AtlasUpgraderFunc is a function type that creates an AtlasReleaseUpgrader.
// This allows injection of custom upgraders for testing.
type AtlasUpgraderFunc func(executor config.CommandExecutor) *AtlasReleaseUpgrader

// DefaultUpgradeExecutor implements UpgradeExecutor.
type DefaultUpgradeExecutor struct {
        executor          config.CommandExecutor
        atlasUpgraderFunc AtlasUpgraderFunc // For testing injection
}

// NewDefaultUpgradeExecutor creates a new DefaultUpgradeExecutor.
func NewDefaultUpgradeExecutor(executor config.CommandExecutor) *DefaultUpgradeExecutor <span class="cov0" title="0">{
        return &amp;DefaultUpgradeExecutor{
                executor:          executor,
                atlasUpgraderFunc: NewAtlasReleaseUpgrader,
        }
}</span>

// NewDefaultUpgradeExecutorWithUpgrader creates a new DefaultUpgradeExecutor with a custom atlas upgrader.
// This is used for testing.
func NewDefaultUpgradeExecutorWithUpgrader(executor config.CommandExecutor, upgraderFunc AtlasUpgraderFunc) *DefaultUpgradeExecutor <span class="cov0" title="0">{
        return &amp;DefaultUpgradeExecutor{
                executor:          executor,
                atlasUpgraderFunc: upgraderFunc,
        }
}</span>

// UpgradeTool upgrades a specific tool.
func (e *DefaultUpgradeExecutor) UpgradeTool(ctx context.Context, tool string) (*UpgradeResult, error) <span class="cov0" title="0">{
        toolConfig := getToolConfig(tool)
        if toolConfig == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %s", errors.ErrUnknownTool, tool)
        }</span>

        <span class="cov0" title="0">result := &amp;UpgradeResult{
                Tool: tool,
        }

        // Handle Speckit constitution.md backup
        constitutionPath, backupWarning := e.handleSpeckitBackup(tool)
        if backupWarning != "" </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, backupWarning)
        }</span>
        <span class="cov0" title="0">if constitutionPath != "" </span><span class="cov0" title="0">{
                defer e.handleSpeckitRestore(result, constitutionPath)
        }</span>

        // Try tool-specific upgrade methods first
        <span class="cov0" title="0">if e.tryToolSpecificUpgrade(ctx, tool, toolConfig, result) </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        // Execute the upgrade via go install
        <span class="cov0" title="0">e.upgradeViaGoInstall(ctx, tool, toolConfig, result)
        return result, nil</span>
}

// BackupConstitution backs up the Speckit constitution.md file.
func (e *DefaultUpgradeExecutor) BackupConstitution() (string, error) <span class="cov0" title="0">{
        // Check both possible locations for constitution.md
        locations := getConstitutionLocations()

        for _, loc := range locations </span><span class="cov0" title="0">{
                if _, err := os.Stat(loc); err == nil </span><span class="cov0" title="0">{
                        backupPath := loc + ".backup"
                        if err := copyFile(loc, backupPath); err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to backup constitution.md: %w", err)
                        }</span>
                        <span class="cov0" title="0">return loc, nil</span>
                }
        }

        // No constitution.md found, nothing to backup
        <span class="cov0" title="0">return "", nil</span>
}

// RestoreConstitution restores the Speckit constitution.md file from backup.
func (e *DefaultUpgradeExecutor) RestoreConstitution(originalPath string) error <span class="cov0" title="0">{
        if originalPath == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">backupPath := originalPath + ".backup"
        if _, err := os.Stat(backupPath); err != nil </span><span class="cov0" title="0">{
                // No backup file exists - this is not an error, just nothing to restore
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return copyFile(backupPath, originalPath)</span>
}

// CleanupConstitutionBackup removes the constitution.md backup file.
func (e *DefaultUpgradeExecutor) CleanupConstitutionBackup(originalPath string) error <span class="cov0" title="0">{
        if originalPath == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">backupPath := originalPath + ".backup"
        return os.Remove(backupPath)</span>
}

// tryToolSpecificUpgrade attempts to upgrade using tool-specific commands.
// Returns true if a tool-specific upgrade was attempted (regardless of success).
func (e *DefaultUpgradeExecutor) tryToolSpecificUpgrade(ctx context.Context, tool string, toolConfig *upgradableToolConfig, result *UpgradeResult) bool <span class="cov0" title="0">{
        switch tool </span>{
        case constants.ToolAtlas:<span class="cov0" title="0">
                // Atlas uses GitHub releases for upgrades
                e.upgradeAtlasViaRelease(ctx, toolConfig, result)
                return true</span>
        case constants.ToolMageX:<span class="cov0" title="0">
                if _, lookErr := e.executor.LookPath(constants.ToolMageX); lookErr == nil </span><span class="cov0" title="0">{
                        e.upgradeMagex(ctx, tool, toolConfig, result)
                        return true
                }</span>
        case constants.ToolGoPreCommit:<span class="cov0" title="0">
                if _, lookErr := e.executor.LookPath(constants.ToolGoPreCommit); lookErr == nil </span><span class="cov0" title="0">{
                        e.upgradeGoPreCommit(ctx, tool, toolConfig, result)
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// upgradeMagex upgrades magex using its built-in update command.
func (e *DefaultUpgradeExecutor) upgradeMagex(ctx context.Context, tool string, toolConfig *upgradableToolConfig, result *UpgradeResult) <span class="cov0" title="0">{
        _, err := e.executor.Run(ctx, constants.ToolMageX, "update:install")
        if err != nil </span><span class="cov0" title="0">{
                result.Success = false
                result.Error = err.Error()
                return
        }</span>
        <span class="cov0" title="0">result.Success = true
        e.updateResultVersion(ctx, tool, toolConfig, result)</span>
}

// upgradeGoPreCommit upgrades go-pre-commit using its built-in upgrade command.
func (e *DefaultUpgradeExecutor) upgradeGoPreCommit(ctx context.Context, tool string, toolConfig *upgradableToolConfig, result *UpgradeResult) <span class="cov0" title="0">{
        _, err := e.executor.Run(ctx, constants.ToolGoPreCommit, "upgrade", "--force")
        if err != nil </span><span class="cov0" title="0">{
                result.Success = false
                result.Error = err.Error()
                return
        }</span>
        <span class="cov0" title="0">result.Success = true
        e.updateResultVersion(ctx, tool, toolConfig, result)</span>
}

// upgradeAtlasViaRelease upgrades atlas using GitHub releases.
func (e *DefaultUpgradeExecutor) upgradeAtlasViaRelease(ctx context.Context, toolConfig *upgradableToolConfig, result *UpgradeResult) <span class="cov0" title="0">{
        // Get current version
        output, err := e.executor.Run(ctx, toolConfig.command, toolConfig.versionFlag)
        currentVersion := "unknown"
        if err == nil </span><span class="cov0" title="0">{
                currentVersion = parseVersionFromOutput(constants.ToolAtlas, output)
        }</span>

        // Create upgrader and perform upgrade
        <span class="cov0" title="0">upgrader := e.atlasUpgraderFunc(e.executor)
        newVersion, err := upgrader.UpgradeAtlas(ctx, currentVersion)
        if err != nil </span><span class="cov0" title="0">{
                result.Success = false
                result.Error = err.Error()
                return
        }</span>

        <span class="cov0" title="0">result.Success = true
        result.NewVersion = newVersion</span>
}

// upgradeViaGoInstall upgrades a tool using go install.
func (e *DefaultUpgradeExecutor) upgradeViaGoInstall(ctx context.Context, tool string, toolConfig *upgradableToolConfig, result *UpgradeResult) <span class="cov0" title="0">{
        _, err := e.executor.Run(ctx, "go", "install", toolConfig.installPath)
        if err != nil </span><span class="cov0" title="0">{
                result.Success = false
                result.Error = err.Error()
                return
        }</span>
        <span class="cov0" title="0">result.Success = true
        e.updateResultVersion(ctx, tool, toolConfig, result)</span>
}

// updateResultVersion updates the result with the new version after upgrade.
func (e *DefaultUpgradeExecutor) updateResultVersion(ctx context.Context, tool string, toolConfig *upgradableToolConfig, result *UpgradeResult) <span class="cov0" title="0">{
        output, err := e.executor.Run(ctx, toolConfig.command, toolConfig.versionFlag)
        if err == nil </span><span class="cov0" title="0">{
                result.NewVersion = parseVersionFromOutput(tool, output)
        }</span>
}

// handleSpeckitBackup backs up constitution.md for Speckit upgrades.
// Returns the backup path and a warning message if backup failed.
func (e *DefaultUpgradeExecutor) handleSpeckitBackup(tool string) (string, string) <span class="cov0" title="0">{
        if tool != constants.ToolSpeckit </span><span class="cov0" title="0">{
                return "", ""
        }</span>
        <span class="cov0" title="0">backupPath, err := e.BackupConstitution()
        if err != nil </span><span class="cov0" title="0">{
                // Return warning but continue - backup is best effort
                return "", fmt.Sprintf("Warning: failed to backup constitution.md: %v", err)
        }</span>
        <span class="cov0" title="0">return backupPath, ""</span>
}

// handleSpeckitRestore restores constitution.md after a successful Speckit upgrade.
func (e *DefaultUpgradeExecutor) handleSpeckitRestore(result *UpgradeResult, constitutionPath string) <span class="cov0" title="0">{
        if result.Success </span><span class="cov0" title="0">{
                if err := e.RestoreConstitution(constitutionPath); err != nil </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings,
                                fmt.Sprintf("Warning: failed to restore constitution.md: %v (backup at %s.backup)", err, constitutionPath))
                        return // Don't cleanup backup if restore failed
                }</span>
                <span class="cov0" title="0">if err := e.CleanupConstitutionBackup(constitutionPath); err != nil </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings,
                                fmt.Sprintf("Warning: failed to cleanup backup: %v", err))
                }</span>
        }
}

// getConstitutionLocations returns the possible locations for constitution.md.
func getConstitutionLocations() []string <span class="cov0" title="0">{
        locations := []string{
                filepath.Join(".", ".speckit", "constitution.md"),
        }

        if home, err := os.UserHomeDir(); err == nil </span><span class="cov0" title="0">{
                locations = append(locations, filepath.Join(home, ".speckit", "constitution.md"))
        }</span>

        <span class="cov0" title="0">return locations</span>
}

// ExitCodeError represents an error with a specific exit code.
type ExitCodeError struct {
        Code int
        Err  error
}

// Error implements the error interface.
func (e *ExitCodeError) Error() string <span class="cov0" title="0">{
        if e.Err != nil </span><span class="cov0" title="0">{
                return e.Err.Error()
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("exit code %d", e.Code)</span>
}

// DefaultCommandExecutor wraps config.DefaultCommandExecutor for use in upgrade.
type DefaultCommandExecutor struct {
        config.DefaultCommandExecutor
}
</pre>

		<pre class="file" id="file32" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "archive/tar"
        "archive/zip"
        "bufio"
        "compress/gzip"
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "time"

        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        atlasErrors "github.com/mrz1836/atlas/internal/errors"
)

// GitHubRelease represents a GitHub release API response.
type GitHubRelease struct {
        TagName     string         `json:"tag_name"`
        Name        string         `json:"name"`
        Assets      []ReleaseAsset `json:"assets"`
        PreRelease  bool           `json:"prerelease"`
        Draft       bool           `json:"draft"`
        PublishedAt string         `json:"published_at"`
}

// ReleaseAsset represents a release asset from GitHub.
type ReleaseAsset struct {
        Name               string `json:"name"`
        BrowserDownloadURL string `json:"browser_download_url"`
        Size               int64  `json:"size"`
        ContentType        string `json:"content_type"`
}

// ReleaseClient defines the interface for fetching GitHub release information.
// This allows mocking in tests.
type ReleaseClient interface {
        // GetLatestRelease fetches the latest release from GitHub.
        GetLatestRelease(ctx context.Context, owner, repo string) (*GitHubRelease, error)
}

// ReleaseDownloader defines the interface for downloading release assets.
// This allows mocking in tests.
type ReleaseDownloader interface {
        // DownloadFile downloads a file from a URL to a temporary location.
        // Returns the path to the downloaded file.
        DownloadFile(ctx context.Context, url string) (string, error)
}

// AtlasReleaseUpgrader handles upgrading atlas via GitHub releases.
type AtlasReleaseUpgrader struct {
        client     ReleaseClient
        downloader ReleaseDownloader
        executor   config.CommandExecutor
}

// NewAtlasReleaseUpgrader creates a new AtlasReleaseUpgrader with default implementations.
func NewAtlasReleaseUpgrader(executor config.CommandExecutor) *AtlasReleaseUpgrader <span class="cov0" title="0">{
        return &amp;AtlasReleaseUpgrader{
                client:     NewDefaultReleaseClient(executor),
                downloader: NewDefaultReleaseDownloader(executor),
                executor:   executor,
        }
}</span>

// NewAtlasReleaseUpgraderWithDeps creates a new AtlasReleaseUpgrader with custom dependencies.
// This is used for testing.
func NewAtlasReleaseUpgraderWithDeps(client ReleaseClient, downloader ReleaseDownloader, executor config.CommandExecutor) *AtlasReleaseUpgrader <span class="cov0" title="0">{
        return &amp;AtlasReleaseUpgrader{
                client:     client,
                downloader: downloader,
                executor:   executor,
        }
}</span>

// UpgradeAtlas upgrades atlas to the latest release.
// Returns the new version string on success.
func (u *AtlasReleaseUpgrader) UpgradeAtlas(ctx context.Context, currentVersion string) (string, error) <span class="cov0" title="0">{
        // 1. Get latest release
        release, err := u.client.GetLatestRelease(ctx, constants.GitHubOwner, constants.GitHubRepo)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: %v", atlasErrors.ErrUpgradeNoRelease, err) //nolint:errorlint // intentional hybrid wrap
        }</span>

        <span class="cov0" title="0">latestVersion := strings.TrimPrefix(release.TagName, "v")

        // 2. Compare versions - skip if already on latest
        if !isNewerVersion(currentVersion, latestVersion) </span><span class="cov0" title="0">{
                return currentVersion, nil // Already on latest
        }</span>

        // 3. Find the correct binary asset for this platform
        <span class="cov0" title="0">binaryAssetName := getBinaryAssetName(release.TagName)
        checksumAssetName := getChecksumAssetName(release.TagName)

        var binaryAsset, checksumAsset *ReleaseAsset
        for i := range release.Assets </span><span class="cov0" title="0">{
                if release.Assets[i].Name == binaryAssetName </span><span class="cov0" title="0">{
                        binaryAsset = &amp;release.Assets[i]
                }</span>
                <span class="cov0" title="0">if release.Assets[i].Name == checksumAssetName </span><span class="cov0" title="0">{
                        checksumAsset = &amp;release.Assets[i]
                }</span>
        }

        <span class="cov0" title="0">if binaryAsset == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: %s (available: %s)", atlasErrors.ErrUpgradeAssetNotFound, binaryAssetName, listAssetNames(release.Assets))
        }</span>

        <span class="cov0" title="0">if checksumAsset == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: checksum file %s", atlasErrors.ErrUpgradeAssetNotFound, checksumAssetName)
        }</span>

        // 4. Download checksum file first
        <span class="cov0" title="0">checksumPath, err := u.downloader.DownloadFile(ctx, checksumAsset.BrowserDownloadURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: failed to download checksums: %v", atlasErrors.ErrUpgradeDownloadFailed, err) //nolint:errorlint // intentional hybrid wrap
        }</span>
        <span class="cov0" title="0">defer os.Remove(checksumPath) //nolint:errcheck // cleanup best-effort

        // 5. Parse expected checksum
        expectedChecksum, err := extractChecksumForFile(checksumPath, binaryAssetName)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: failed to parse checksums: %v", atlasErrors.ErrUpgradeChecksumMismatch, err) //nolint:errorlint // intentional hybrid wrap
        }</span>

        // 6. Download binary archive
        <span class="cov0" title="0">archivePath, err := u.downloader.DownloadFile(ctx, binaryAsset.BrowserDownloadURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: failed to download binary: %v", atlasErrors.ErrUpgradeDownloadFailed, err) //nolint:errorlint // intentional hybrid wrap
        }</span>
        <span class="cov0" title="0">defer os.Remove(archivePath) //nolint:errcheck // cleanup best-effort

        // 7. Verify checksum
        if verifyErr := verifyChecksum(archivePath, expectedChecksum); verifyErr != nil </span><span class="cov0" title="0">{
                return "", verifyErr
        }</span>

        // 8. Extract binary from archive
        <span class="cov0" title="0">binaryPath, err := extractBinaryFromArchive(archivePath, binaryAssetName)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: failed to extract binary: %v", atlasErrors.ErrUpgradeDownloadFailed, err) //nolint:errorlint // intentional hybrid wrap
        }</span>
        <span class="cov0" title="0">defer os.Remove(binaryPath) //nolint:errcheck // cleanup best-effort

        // 9. Find current binary location
        currentBinaryPath, err := u.executor.LookPath("atlas")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: cannot find current atlas binary: %v", atlasErrors.ErrUpgradeReplaceFailed, err) //nolint:errorlint // intentional hybrid wrap
        }</span>

        // 10. Atomic replace
        <span class="cov0" title="0">if err := atomicReplaceBinary(currentBinaryPath, binaryPath); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return latestVersion, nil</span>
}

// GetLatestVersion fetches the latest version from GitHub without upgrading.
func (u *AtlasReleaseUpgrader) GetLatestVersion(ctx context.Context) (string, error) <span class="cov0" title="0">{
        release, err := u.client.GetLatestRelease(ctx, constants.GitHubOwner, constants.GitHubRepo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.TrimPrefix(release.TagName, "v"), nil</span>
}

// DefaultReleaseClient implements ReleaseClient using gh CLI with HTTP fallback.
type DefaultReleaseClient struct {
        executor   config.CommandExecutor
        httpClient HTTPClient
}

// HTTPClient abstracts HTTP operations for testing.
type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

// NewDefaultReleaseClient creates a new DefaultReleaseClient.
func NewDefaultReleaseClient(executor config.CommandExecutor) *DefaultReleaseClient <span class="cov0" title="0">{
        return &amp;DefaultReleaseClient{
                executor: executor,
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }
}</span>

// NewDefaultReleaseClientWithHTTP creates a client with a custom HTTP client (for testing).
func NewDefaultReleaseClientWithHTTP(executor config.CommandExecutor, httpClient HTTPClient) *DefaultReleaseClient <span class="cov0" title="0">{
        return &amp;DefaultReleaseClient{
                executor:   executor,
                httpClient: httpClient,
        }
}</span>

// GetLatestRelease fetches the latest release, trying gh first then falling back to HTTP.
func (c *DefaultReleaseClient) GetLatestRelease(ctx context.Context, owner, repo string) (*GitHubRelease, error) <span class="cov0" title="0">{
        // Try gh CLI first (authenticated, better rate limits)
        release, err := c.getLatestReleaseViaGH(ctx, owner, repo)
        if err == nil </span><span class="cov0" title="0">{
                return release, nil
        }</span>

        // Fall back to HTTP API (unauthenticated)
        <span class="cov0" title="0">return c.getLatestReleaseViaHTTP(ctx, owner, repo)</span>
}

// getLatestReleaseViaGH fetches release info using the gh CLI.
func (c *DefaultReleaseClient) getLatestReleaseViaGH(ctx context.Context, owner, repo string) (*GitHubRelease, error) <span class="cov0" title="0">{
        // Check if gh is available
        if _, err := c.executor.LookPath("gh"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gh not found: %w", err)
        }</span>

        // Use gh api to fetch release info
        <span class="cov0" title="0">apiPath := fmt.Sprintf("repos/%s/%s/releases/latest", owner, repo)
        output, err := c.executor.Run(ctx, "gh", "api", apiPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("gh api failed: %w", err)
        }</span>

        <span class="cov0" title="0">var release GitHubRelease
        if err := json.Unmarshal([]byte(output), &amp;release); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse release: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;release, nil</span>
}

// getLatestReleaseViaHTTP fetches release info using direct HTTP API calls.
func (c *DefaultReleaseClient) getLatestReleaseViaHTTP(ctx context.Context, owner, repo string) (*GitHubRelease, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/repos/%s/%s/releases/latest", constants.GitHubAPIBaseURL, owner, repo)

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Accept", "application/vnd.github+json")
        req.Header.Set("User-Agent", "atlas-cli")
        req.Header.Set("X-GitHub-Api-Version", "2022-11-28")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close() //nolint:errcheck // HTTP response body close

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, readErr := io.ReadAll(resp.Body)
                if readErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: status %d (failed to read response body: %w)", atlasErrors.ErrUpgradeDownloadFailed, resp.StatusCode, readErr)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("%w: status %d: %s", atlasErrors.ErrUpgradeDownloadFailed, resp.StatusCode, string(body))</span>
        }

        <span class="cov0" title="0">var release GitHubRelease
        if err := json.NewDecoder(resp.Body).Decode(&amp;release); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;release, nil</span>
}

// DefaultReleaseDownloader implements ReleaseDownloader using gh CLI with HTTP fallback.
type DefaultReleaseDownloader struct {
        executor   config.CommandExecutor
        httpClient HTTPClient
}

// NewDefaultReleaseDownloader creates a new DefaultReleaseDownloader.
func NewDefaultReleaseDownloader(executor config.CommandExecutor) *DefaultReleaseDownloader <span class="cov0" title="0">{
        return &amp;DefaultReleaseDownloader{
                executor: executor,
                httpClient: &amp;http.Client{
                        Timeout: 5 * time.Minute, // Longer timeout for downloads
                },
        }
}</span>

// NewDefaultReleaseDownloaderWithHTTP creates a downloader with a custom HTTP client.
func NewDefaultReleaseDownloaderWithHTTP(executor config.CommandExecutor, httpClient HTTPClient) *DefaultReleaseDownloader <span class="cov0" title="0">{
        return &amp;DefaultReleaseDownloader{
                executor:   executor,
                httpClient: httpClient,
        }
}</span>

// DownloadFile downloads a file from URL to a temporary location.
// Tries gh CLI first (authenticated, works with private repos), falls back to HTTP.
func (d *DefaultReleaseDownloader) DownloadFile(ctx context.Context, url string) (string, error) <span class="cov0" title="0">{
        // Try gh CLI first (authenticated, works with private repos)
        if d.executor != nil </span><span class="cov0" title="0">{
                path, err := d.downloadFileViaGH(ctx, url)
                if err == nil </span><span class="cov0" title="0">{
                        return path, nil
                }</span>
                // Fall through to HTTP if gh fails
        }

        // Fall back to HTTP (unauthenticated)
        <span class="cov0" title="0">return d.downloadFileViaHTTP(ctx, url)</span>
}

// downloadFileViaGH downloads a release asset using gh CLI.
// URL format: https://github.com/OWNER/REPO/releases/download/TAG/ASSET
func (d *DefaultReleaseDownloader) downloadFileViaGH(ctx context.Context, url string) (string, error) <span class="cov0" title="0">{
        // Check if gh is available
        if _, err := d.executor.LookPath("gh"); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("gh not found: %w", err)
        }</span>

        // Parse URL to extract owner, repo, tag, and asset name
        // Format: https://github.com/OWNER/REPO/releases/download/TAG/ASSET
        <span class="cov0" title="0">owner, repo, tag, assetName, err := parseGitHubReleaseURL(url)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("cannot parse GitHub URL: %w", err)
        }</span>

        // Create temp directory for download
        <span class="cov0" title="0">tmpDir, err := os.MkdirTemp("", "atlas-download-*")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create temp dir: %w", err)
        }</span>

        // Download using gh release download
        <span class="cov0" title="0">repoArg := fmt.Sprintf("%s/%s", owner, repo)
        _, err = d.executor.Run(ctx, "gh", "release", "download", tag,
                "--repo", repoArg,
                "--pattern", assetName,
                "--dir", tmpDir)
        if err != nil </span><span class="cov0" title="0">{
                _ = os.RemoveAll(tmpDir)
                return "", fmt.Errorf("gh release download failed: %w", err)
        }</span>

        // Return path to downloaded file
        <span class="cov0" title="0">downloadedPath := filepath.Join(tmpDir, assetName)
        if _, statErr := os.Stat(downloadedPath); statErr != nil </span><span class="cov0" title="0">{
                _ = os.RemoveAll(tmpDir)
                return "", fmt.Errorf("downloaded file not found: %w", statErr)
        }</span>

        <span class="cov0" title="0">return downloadedPath, nil</span>
}

// parseGitHubReleaseURL parses a GitHub release download URL.
// Returns owner, repo, tag, and asset name.
// URL format: https://github.com/OWNER/REPO/releases/download/TAG/ASSET
func parseGitHubReleaseURL(url string) (owner, repo, tag, assetName string, err error) <span class="cov0" title="0">{
        // Expected format: https://github.com/OWNER/REPO/releases/download/TAG/ASSET
        const prefix = "https://github.com/"
        if !strings.HasPrefix(url, prefix) </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("%w: not a github.com URL", atlasErrors.ErrInvalidURL)
        }</span>

        // Remove prefix and split
        <span class="cov0" title="0">path := strings.TrimPrefix(url, prefix)
        parts := strings.Split(path, "/")

        // Need at least: OWNER/REPO/releases/download/TAG/ASSET (6 parts)
        if len(parts) &lt; 6 </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("%w: invalid release URL format", atlasErrors.ErrInvalidURL)
        }</span>

        <span class="cov0" title="0">if parts[2] != "releases" || parts[3] != "download" </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("%w: not a release download URL", atlasErrors.ErrInvalidURL)
        }</span>

        <span class="cov0" title="0">return parts[0], parts[1], parts[4], parts[5], nil</span>
}

// downloadFileViaHTTP downloads a file using HTTP (unauthenticated).
func (d *DefaultReleaseDownloader) downloadFileViaHTTP(ctx context.Context, url string) (string, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("User-Agent", "atlas-cli")

        resp, err := d.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("download failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close() //nolint:errcheck // HTTP response body close

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: status %d", atlasErrors.ErrUpgradeDownloadFailed, resp.StatusCode)
        }</span>

        // Create temp file
        <span class="cov0" title="0">tmpFile, err := os.CreateTemp("", "atlas-upgrade-*")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create temp file: %w", err)
        }</span>
        <span class="cov0" title="0">defer tmpFile.Close() //nolint:errcheck // temp file close

        // Copy content
        if _, err := io.Copy(tmpFile, resp.Body); err != nil </span><span class="cov0" title="0">{
                _ = os.Remove(tmpFile.Name())
                return "", fmt.Errorf("failed to write file: %w", err)
        }</span>

        <span class="cov0" title="0">return tmpFile.Name(), nil</span>
}

// getBinaryAssetName returns the expected asset name for the current platform.
func getBinaryAssetName(tagName string) string <span class="cov0" title="0">{
        version := strings.TrimPrefix(tagName, "v")
        ext := ".tar.gz"
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                ext = ".zip"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("atlas_%s_%s_%s%s", version, runtime.GOOS, runtime.GOARCH, ext)</span>
}

// getChecksumAssetName returns the expected checksum file name.
func getChecksumAssetName(tagName string) string <span class="cov0" title="0">{
        version := strings.TrimPrefix(tagName, "v")
        return fmt.Sprintf("atlas_%s_checksums.txt", version)
}</span>

// listAssetNames returns a comma-separated list of asset names for error messages.
func listAssetNames(assets []ReleaseAsset) string <span class="cov0" title="0">{
        names := make([]string, len(assets))
        for i, a := range assets </span><span class="cov0" title="0">{
                names[i] = a.Name
        }</span>
        <span class="cov0" title="0">return strings.Join(names, ", ")</span>
}

// extractChecksumForFile extracts the checksum for a specific file from a checksums file.
func extractChecksumForFile(checksumFilePath, targetFile string) (string, error) <span class="cov0" title="0">{
        file, err := os.Open(checksumFilePath) //nolint:gosec // path from controlled source
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer file.Close() //nolint:errcheck // file close in reader

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Format: "checksum  filename" or "checksum filename"
                <span class="cov0" title="0">parts := strings.Fields(line)
                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        checksum := parts[0]
                        filename := parts[len(parts)-1]
                        if filename == targetFile </span><span class="cov0" title="0">{
                                return checksum, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("%w: file %s not in checksums", atlasErrors.ErrUpgradeChecksumMismatch, targetFile)</span>
}

// verifyChecksum verifies the SHA256 checksum of a file.
func verifyChecksum(filePath, expectedChecksum string) error <span class="cov0" title="0">{
        file, err := os.Open(filePath) //nolint:gosec // path from controlled source
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: cannot open file: %v", atlasErrors.ErrUpgradeChecksumMismatch, err) //nolint:errorlint // intentional hybrid wrap
        }</span>
        <span class="cov0" title="0">defer file.Close() //nolint:errcheck // file close in reader

        hasher := sha256.New()
        if _, err := io.Copy(hasher, file); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: cannot hash file: %v", atlasErrors.ErrUpgradeChecksumMismatch, err) //nolint:errorlint // intentional hybrid wrap
        }</span>

        <span class="cov0" title="0">actualChecksum := hex.EncodeToString(hasher.Sum(nil))
        if !strings.EqualFold(actualChecksum, expectedChecksum) </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: expected %s, got %s", atlasErrors.ErrUpgradeChecksumMismatch, expectedChecksum, actualChecksum)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// extractBinaryFromArchive extracts the atlas binary from a tar.gz or zip archive.
func extractBinaryFromArchive(archivePath, archiveName string) (string, error) <span class="cov0" title="0">{
        if strings.HasSuffix(archiveName, ".zip") </span><span class="cov0" title="0">{
                return extractFromZip(archivePath)
        }</span>
        <span class="cov0" title="0">return extractFromTarGz(archivePath)</span>
}

// extractFromTarGz extracts the atlas binary from a tar.gz archive.
func extractFromTarGz(archivePath string) (string, error) <span class="cov0" title="0">{ //nolint:gocognit // tar extraction inherently complex
        file, err := os.Open(archivePath) //nolint:gosec // path from controlled source
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer file.Close() //nolint:errcheck // file close in reader

        gzr, err := gzip.NewReader(file)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer gzr.Close() //nolint:errcheck // gzip reader close

        tr := tar.NewReader(gzr)

        binaryName := "atlas"
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                binaryName = "atlas.exe"
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                header, err := tr.Next()
                if errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("read tar header: %w", err)
                }</span>

                // Look for the atlas binary
                <span class="cov0" title="0">if header.Typeflag == tar.TypeReg &amp;&amp; filepath.Base(header.Name) == binaryName </span><span class="cov0" title="0">{
                        tmpFile, err := os.CreateTemp("", "atlas-binary-*")
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("create temp file: %w", err)
                        }</span>

                        // Use limited copy to prevent decompression bomb
                        <span class="cov0" title="0">if _, copyErr := io.CopyN(tmpFile, tr, header.Size); copyErr != nil &amp;&amp; !errors.Is(copyErr, io.EOF) </span><span class="cov0" title="0">{
                                _ = tmpFile.Close()
                                _ = os.Remove(tmpFile.Name())
                                return "", copyErr
                        }</span>
                        <span class="cov0" title="0">_ = tmpFile.Close()

                        // Make executable
                        if chmodErr := os.Chmod(tmpFile.Name(), 0o755); chmodErr != nil </span><span class="cov0" title="0">{ //nolint:gosec // executable needed
                                _ = os.Remove(tmpFile.Name())
                                return "", chmodErr
                        }</span>

                        <span class="cov0" title="0">return tmpFile.Name(), nil</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("%w: binary %s not in archive", atlasErrors.ErrUpgradeAssetNotFound, binaryName)</span>
}

// extractFromZip extracts the atlas binary from a zip archive.
func extractFromZip(archivePath string) (string, error) <span class="cov0" title="0">{
        r, err := zip.OpenReader(archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("open zip archive: %w", err)
        }</span>
        <span class="cov0" title="0">defer r.Close() //nolint:errcheck // zip reader close

        binaryName := "atlas"
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                binaryName = "atlas.exe"
        }</span>

        <span class="cov0" title="0">for _, f := range r.File </span><span class="cov0" title="0">{
                if filepath.Base(f.Name) == binaryName &amp;&amp; !f.FileInfo().IsDir() </span><span class="cov0" title="0">{
                        return extractZipFile(f)
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("%w: binary %s not in archive", atlasErrors.ErrUpgradeAssetNotFound, binaryName)</span>
}

// extractZipFile extracts a single file from a zip archive.
func extractZipFile(f *zip.File) (string, error) <span class="cov0" title="0">{
        rc, err := f.Open()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("open zip entry: %w", err)
        }</span>
        <span class="cov0" title="0">defer rc.Close() //nolint:errcheck // zip file close

        tmpFile, err := os.CreateTemp("", "atlas-binary-*")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("create temp file: %w", err)
        }</span>

        // Use limited copy to prevent decompression bomb
        <span class="cov0" title="0">if _, copyErr := io.CopyN(tmpFile, rc, int64(f.UncompressedSize64)); copyErr != nil &amp;&amp; !errors.Is(copyErr, io.EOF) </span><span class="cov0" title="0">{ //nolint:gosec // size from zip header
                _ = tmpFile.Close()
                _ = os.Remove(tmpFile.Name())
                return "", copyErr
        }</span>
        <span class="cov0" title="0">_ = tmpFile.Close()

        // Make executable
        if err := os.Chmod(tmpFile.Name(), 0o755); err != nil </span><span class="cov0" title="0">{ //nolint:gosec // executable needed
                _ = os.Remove(tmpFile.Name())
                return "", err
        }</span>

        <span class="cov0" title="0">return tmpFile.Name(), nil</span>
}

// atomicReplaceBinary atomically replaces the current binary with the new one.
func atomicReplaceBinary(currentPath, newPath string) error <span class="cov0" title="0">{
        // Get current binary info for permissions
        currentInfo, err := os.Stat(currentPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: cannot stat current binary: %v", atlasErrors.ErrUpgradeReplaceFailed, err) //nolint:errorlint // intentional hybrid wrap
        }</span>

        // Create backup
        <span class="cov0" title="0">backupPath := currentPath + ".backup"
        if err := os.Rename(currentPath, backupPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: cannot backup current binary: %v", atlasErrors.ErrUpgradeReplaceFailed, err) //nolint:errorlint // intentional hybrid wrap
        }</span>

        // Copy new binary to target location (we can't rename across filesystems)
        <span class="cov0" title="0">if copyErr := copyBinaryFile(newPath, currentPath, currentInfo.Mode()); copyErr != nil </span><span class="cov0" title="0">{
                // Restore from backup
                if restoreErr := os.Rename(backupPath, currentPath); restoreErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: install failed and restore failed: %w",
                                atlasErrors.ErrUpgradeReplaceFailed, restoreErr)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("%w: %v", atlasErrors.ErrUpgradeReplaceFailed, copyErr)</span> //nolint:errorlint // intentional hybrid wrap
        }

        // Remove backup on success
        <span class="cov0" title="0">_ = os.Remove(backupPath)

        return nil</span>
}

// copyBinaryFile copies a binary file preserving the specified permissions.
func copyBinaryFile(src, dst string, mode os.FileMode) error <span class="cov0" title="0">{
        srcFile, err := os.Open(src) //nolint:gosec // path from controlled source
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("open source %s: %w", src, err)
        }</span>
        <span class="cov0" title="0">defer srcFile.Close() //nolint:errcheck // file close in reader

        dstFile, err := os.OpenFile(dst, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, mode) //nolint:gosec // path from controlled source
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create destination %s: %w", dst, err)
        }</span>
        <span class="cov0" title="0">defer dstFile.Close() //nolint:errcheck // will be closed explicitly

        if _, err := io.Copy(dstFile, srcFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("copy to %s: %w", dst, err)
        }</span>

        <span class="cov0" title="0">return dstFile.Close()</span>
}

// isNewerVersion returns true if latest is newer than current.
// Uses simple string comparison - could be enhanced with semver parsing.
func isNewerVersion(current, latest string) bool <span class="cov0" title="0">{
        // Strip 'v' prefix if present
        current = strings.TrimPrefix(current, "v")
        latest = strings.TrimPrefix(latest, "v")

        // Handle dev/unknown versions - always upgrade
        if current == "dev" || current == "unknown" || current == "" </span><span class="cov0" title="0">{
                return true
        }</span>

        // Simple comparison - for proper semver, could use a library
        // For now, different versions means potentially newer
        <span class="cov0" title="0">return current != latest</span>
}
</pre>

		<pre class="file" id="file33" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "time"

        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/task"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/validation"
        "github.com/mrz1836/atlas/internal/workspace"
        "github.com/rs/zerolog"
)

// CommandResult holds the result of a single command execution.
type CommandResult struct {
        Command    string `json:"command"`
        Success    bool   `json:"success"`
        ExitCode   int    `json:"exit_code"`
        Output     string `json:"output,omitempty"`
        Error      string `json:"error,omitempty"`
        DurationMs int64  `json:"duration_ms"`
}

// ValidationResponse is the JSON response for validation commands.
type ValidationResponse struct {
        Success      bool              `json:"success"`
        Results      []CommandResult   `json:"results"`
        SkippedSteps []string          `json:"skipped_steps,omitempty"`
        SkipReasons  map[string]string `json:"skip_reasons,omitempty"`
}

// UtilityOptions holds options for utility command execution.
type UtilityOptions struct {
        Verbose      bool
        OutputFormat string
        Writer       io.Writer
}

// getDefaultCommands returns the default command for a given category.
func getDefaultCommands(category string) []string <span class="cov0" title="0">{
        switch category </span>{
        case "format":<span class="cov0" title="0">
                return []string{constants.DefaultFormatCommand}</span>
        case "lint":<span class="cov0" title="0">
                return []string{constants.DefaultLintCommand}</span>
        case "test":<span class="cov0" title="0">
                return []string{constants.DefaultTestCommand}</span>
        case "pre-commit":<span class="cov0" title="0">
                return []string{constants.DefaultPreCommitCommand}</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// showVerboseOutput displays command output in verbose mode.
func showVerboseOutput(opts UtilityOptions, result CommandResult) <span class="cov0" title="0">{
        if !opts.Verbose </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if result.Output != "" </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(opts.Writer, result.Output)
        }</span>
        <span class="cov0" title="0">if result.Error != "" </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(opts.Writer, result.Error)
        }</span>
}

// runSingleCommand executes a single command and returns the result.
func runSingleCommand(ctx context.Context, runner validation.CommandRunner, workDir, cmdStr string, logger zerolog.Logger) CommandResult <span class="cov0" title="0">{
        start := time.Now()

        stdout, stderr, exitCode, err := runner.Run(ctx, workDir, cmdStr)

        result := CommandResult{
                Command:    cmdStr,
                Success:    err == nil &amp;&amp; exitCode == 0,
                ExitCode:   exitCode,
                DurationMs: time.Since(start).Milliseconds(),
        }

        if stdout != "" </span><span class="cov0" title="0">{
                result.Output = stdout
        }</span>
        <span class="cov0" title="0">if err != nil || exitCode != 0 </span><span class="cov0" title="0">{
                if stderr != "" </span><span class="cov0" title="0">{
                        result.Error = stderr
                }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        result.Error = err.Error()
                }</span>
        }

        <span class="cov0" title="0">logger.Debug().
                Str("command", cmdStr).
                Bool("success", result.Success).
                Int("exit_code", exitCode).
                Int64("duration_ms", result.DurationMs).
                Msg("command executed")

        return result</span>
}

// runCommandsWithOutput executes commands sequentially and handles output.
func runCommandsWithOutput(
        ctx context.Context,
        commands []string,
        workDir string,
        category string,
        out tui.Output,
        opts UtilityOptions,
        logger zerolog.Logger,
) error <span class="cov0" title="0">{
        runner := &amp;validation.DefaultCommandRunner{}
        results := make([]CommandResult, 0, len(commands))

        for _, cmdStr := range commands </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                // Show command being executed in verbose mode (TTY only - JSON gets final response)
                <span class="cov0" title="0">if opts.Verbose &amp;&amp; opts.OutputFormat != OutputJSON </span><span class="cov0" title="0">{
                        out.Info(fmt.Sprintf("⏳ Running: %s", cmdStr))
                }</span>

                <span class="cov0" title="0">result := runSingleCommand(ctx, runner, workDir, cmdStr, logger)
                results = append(results, result)

                // In verbose mode, show command output
                showVerboseOutput(opts, result)

                if !result.Success </span><span class="cov0" title="0">{
                        if opts.OutputFormat == OutputJSON </span><span class="cov0" title="0">{
                                return out.JSON(ValidationResponse{
                                        Success: false,
                                        Results: results,
                                })
                        }</span>
                        <span class="cov0" title="0">out.Error(tui.WrapWithSuggestion(fmt.Errorf("%w: %s in %s", errors.ErrCommandFailed, cmdStr, category)))
                        return fmt.Errorf("%w: %s in %s", errors.ErrCommandFailed, cmdStr, category)</span>
                }

                // Only show per-command success for TTY output (JSON gets final response only)
                // TTYOutput.Success() adds the ✓ prefix automatically, so don't include icon here
                <span class="cov0" title="0">if opts.OutputFormat != OutputJSON </span><span class="cov0" title="0">{
                        out.Success(cmdStr)
                }</span>
        }

        <span class="cov0" title="0">if opts.OutputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(ValidationResponse{
                        Success: true,
                        Results: results,
                })
        }</span>

        <span class="cov0" title="0">out.Success(fmt.Sprintf("%s completed successfully", category))
        return nil</span>
}

// handleValidationFailure handles validation failure output.
func handleValidationFailure(out tui.Output, outputFormat string, results []CommandResult) error <span class="cov0" title="0">{
        if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(ValidationResponse{
                        Success: false,
                        Results: results,
                })
        }</span>

        // Find the failed command
        <span class="cov0" title="0">for _, r := range results </span><span class="cov0" title="0">{
                if !r.Success </span><span class="cov0" title="0">{
                        out.Error(tui.WrapWithSuggestion(fmt.Errorf("%w: %s (exit code: %d)", errors.ErrValidationFailed, r.Command, r.ExitCode)))
                        if r.Error != "" </span><span class="cov0" title="0">{
                                out.Info(r.Error)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov0" title="0">return errors.ErrValidationFailed</span>
}

// encodeJSONIndented encodes a value as indented JSON to the writer.
// This is a shared helper for JSON error output functions across commands.
func encodeJSONIndented(w io.Writer, v any) error <span class="cov8" title="1">{
        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(v)
}</span>

// Default values for smart commit and PR description configuration.
const (
        DefaultSmartCommitTimeout       = 30 * time.Second
        DefaultSmartCommitMaxRetries    = 2
        DefaultSmartCommitBackoffFactor = 1.5
)

// ResolvedGitConfig holds resolved agent/model settings for git operations.
// This consolidates the fallback logic for SmartCommit and PRDescription settings.
type ResolvedGitConfig struct {
        CommitAgent         string
        CommitModel         string
        PRDescAgent         string
        PRDescModel         string
        CommitTimeout       time.Duration
        CommitMaxRetries    int
        CommitBackoffFactor float64
}

// ResolveGitConfig resolves SmartCommit and PRDescription settings with fallback to global AI config.
// This eliminates duplicated resolution logic across commands.
func ResolveGitConfig(cfg *config.Config) ResolvedGitConfig <span class="cov0" title="0">{
        // Resolve commit agent/model with fallback to global AI config
        commitAgent := cfg.SmartCommit.Agent
        if commitAgent == "" </span><span class="cov0" title="0">{
                commitAgent = cfg.AI.Agent
        }</span>
        <span class="cov0" title="0">commitModel := cfg.SmartCommit.Model
        if commitModel == "" </span><span class="cov0" title="0">{
                commitModel = cfg.AI.Model
        }</span>

        // Resolve PR description agent/model with fallback to global AI config
        <span class="cov0" title="0">prDescAgent := cfg.PRDescription.Agent
        if prDescAgent == "" </span><span class="cov0" title="0">{
                prDescAgent = cfg.AI.Agent
        }</span>
        <span class="cov0" title="0">prDescModel := cfg.PRDescription.Model
        if prDescModel == "" </span><span class="cov0" title="0">{
                prDescModel = cfg.AI.Model
        }</span>

        // Resolve smart commit timeout/retry settings with defaults
        <span class="cov0" title="0">commitTimeout := cfg.SmartCommit.Timeout
        if commitTimeout == 0 </span><span class="cov0" title="0">{
                commitTimeout = DefaultSmartCommitTimeout
        }</span>
        <span class="cov0" title="0">commitMaxRetries := cfg.SmartCommit.MaxRetries
        if commitMaxRetries == 0 </span><span class="cov0" title="0">{
                commitMaxRetries = DefaultSmartCommitMaxRetries
        }</span>
        <span class="cov0" title="0">commitBackoffFactor := cfg.SmartCommit.RetryBackoffFactor
        if commitBackoffFactor == 0 </span><span class="cov0" title="0">{
                commitBackoffFactor = DefaultSmartCommitBackoffFactor
        }</span>

        <span class="cov0" title="0">return ResolvedGitConfig{
                CommitAgent:         commitAgent,
                CommitModel:         commitModel,
                PRDescAgent:         prDescAgent,
                PRDescModel:         prDescModel,
                CommitTimeout:       commitTimeout,
                CommitMaxRetries:    commitMaxRetries,
                CommitBackoffFactor: commitBackoffFactor,
        }</span>
}

// WorkspaceTaskSelector defines interface for items that can be selected from a workspace menu.
type WorkspaceTaskSelector interface {
        GetWorkspaceName() string
        GetTaskDescription() string
}

// SelectWorkspaceTask presents a selection menu and returns the selected item's index.
// It uses generics to work with any type implementing WorkspaceTaskSelector.
func SelectWorkspaceTask[T WorkspaceTaskSelector](prompt string, items []T) (int, error) <span class="cov0" title="0">{
        options := make([]tui.Option, len(items))
        for i, item := range items </span><span class="cov0" title="0">{
                options[i] = tui.Option{
                        Label:       item.GetWorkspaceName(),
                        Description: item.GetTaskDescription(),
                        Value:       item.GetWorkspaceName(),
                }
        }</span>

        <span class="cov0" title="0">selected, err := tui.Select(prompt, options)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">for i, item := range items </span><span class="cov0" title="0">{
                if item.GetWorkspaceName() == selected </span><span class="cov0" title="0">{
                        return i, nil
                }</span>
        }
        <span class="cov0" title="0">return -1, fmt.Errorf("selected workspace not found: %w", errors.ErrWorkspaceNotFound)</span>
}

// CreateStores creates workspace and task stores with unified error handling.
// Returns workspace store, task store, and error.
func CreateStores(baseDir string) (workspace.Store, task.Store, error) <span class="cov8" title="1">{
        wsStore, err := workspace.NewFileStore(baseDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create workspace store: %w", err)
        }</span>

        <span class="cov8" title="1">taskStore, err := task.NewFileStore(baseDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create task store: %w", err)
        }</span>

        <span class="cov8" title="1">return wsStore, taskStore, nil</span>
}

// HandleCommandError handles errors with optional JSON output.
// If format is JSON, it encodes the response and returns ErrJSONErrorOutput.
// Otherwise, it returns the original error.
func HandleCommandError(format string, w io.Writer, response any, err error) error <span class="cov8" title="1">{
        if format == OutputJSON </span><span class="cov8" title="1">{
                if encErr := encodeJSONIndented(w, response); encErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to encode JSON: %w", encErr)
                }</span>
                <span class="cov8" title="1">return errors.ErrJSONErrorOutput</span>
        }
        <span class="cov8" title="1">return err</span>
}
</pre>

		<pre class="file" id="file34" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "fmt"
        "io"
        "os"

        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/validation"
        "github.com/spf13/cobra"
)

// ValidateOptions allows dependency injection for testing the validate command.
type ValidateOptions struct {
        // Runner is an optional validation runner. If nil, a real one will be created.
        Runner ValidationRunner
}

// ValidationRunner interface allows mocking the validation pipeline for tests.
type ValidationRunner interface {
        SetProgressCallback(cb validation.ProgressCallback)
        Run(ctx context.Context, workDir string) (*validation.PipelineResult, error)
}

// AddValidateCommand adds the validate command to the root command.
func AddValidateCommand(root *cobra.Command) <span class="cov0" title="0">{
        root.AddCommand(newValidateCmd())
}</span>

func newValidateCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "validate",
                Short: "Run the full validation suite (format, lint, test, pre-commit)",
                Long: `Run the complete validation pipeline configured for the project.

The validation suite runs in this order:
  1. Format - Code formatting (sequential)
  2. Lint + Test - Run in parallel
  3. Pre-commit - Pre-commit hooks (sequential)

Examples:
  atlas validate
  atlas validate --output json
  atlas validate --verbose
  atlas validate --quiet`,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runValidate(cmd.Context(), cmd, os.Stdout)
                }</span>,
        }

        <span class="cov0" title="0">cmd.Flags().BoolP("quiet", "q", false, "Show only final pass/fail result")

        return cmd</span>
}

func runValidate(ctx context.Context, cmd *cobra.Command, w io.Writer) error <span class="cov0" title="0">{
        return runValidateWithOptions(ctx, cmd, w, nil)
}</span>

// runValidateWithOptions is the testable version that accepts optional dependencies.
//
//nolint:gocognit // TODO: Refactor to reduce complexity - extract progress callback setup and result handling
func runValidateWithOptions(ctx context.Context, cmd *cobra.Command, w io.Writer, opts *ValidateOptions) error <span class="cov0" title="0">{
        // Check context cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">logger := Logger()
        outputFormat := cmd.Flag("output").Value.String()
        verbose := cmd.Flag("verbose").Value.String() == "true"
        quiet := cmd.Flag("quiet").Value.String() == "true"
        tui.CheckNoColor()

        out := tui.NewOutput(w, outputFormat)

        // Load config
        cfg, err := config.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("failed to load config, using defaults")
                cfg = config.DefaultConfig()
        }</span>

        // Get current working directory
        <span class="cov0" title="0">workDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get working directory: %w", err)
        }</span>

        // Create spinner for progress indication (only for TTY output)
        // The spinner wraps the writer with mutex protection for thread safety
        <span class="cov0" title="0">spinner := tui.NewTerminalSpinner(w)

        // Use injected runner if provided (for testing), otherwise create real runner
        var runner ValidationRunner
        if opts != nil &amp;&amp; opts.Runner != nil </span><span class="cov0" title="0">{
                runner = opts.Runner
        }</span> else<span class="cov0" title="0"> {
                // Create executor and runner
                executor := validation.NewExecutor(cfg.Validation.Timeout)

                // Enable live output streaming in verbose mode
                // Use the spinner's writer to ensure thread-safe access to the output
                if verbose </span><span class="cov0" title="0">{
                        executor.SetLiveOutput(spinner.Writer())
                }</span>

                <span class="cov0" title="0">runnerConfig := &amp;validation.RunnerConfig{
                        FormatCommands:    cfg.Validation.Commands.Format,
                        LintCommands:      cfg.Validation.Commands.Lint,
                        TestCommands:      cfg.Validation.Commands.Test,
                        PreCommitCommands: cfg.Validation.Commands.PreCommit,
                }
                runner = validation.NewRunner(executor, runnerConfig)</span>
        }

        // Set up progress callback for TUI output
        <span class="cov0" title="0">runner.SetProgressCallback(func(step, status string, info *validation.ProgressInfo) </span><span class="cov0" title="0">{
                // Skip all progress output in quiet mode
                if quiet </span><span class="cov0" title="0">{
                        return
                }</span>

                // For JSON output, skip visual feedback
                <span class="cov0" title="0">if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">stepInfo := ""
                if info != nil &amp;&amp; info.TotalSteps &gt; 0 </span><span class="cov0" title="0">{
                        stepInfo = fmt.Sprintf("[%d/%d] ", info.CurrentStep, info.TotalSteps)
                }</span>

                <span class="cov0" title="0">switch constants.ValidationProgressStatus(status) </span>{
                case constants.ValidationProgressStarting:<span class="cov0" title="0">
                        // Use spinner for starting status
                        spinner.Start(ctx, fmt.Sprintf("%sRunning %s...", stepInfo, step))</span>
                case constants.ValidationProgressCompleted:<span class="cov0" title="0">
                        // Stop spinner and show success
                        duration := ""
                        if info != nil &amp;&amp; info.DurationMs &gt; 0 </span><span class="cov0" title="0">{
                                duration = fmt.Sprintf(" (%s)", tui.FormatDuration(info.DurationMs))
                        }</span>
                        <span class="cov0" title="0">spinner.StopWithSuccess(fmt.Sprintf("%s passed%s", capitalizeStep(step), duration))</span>
                case constants.ValidationProgressFailed:<span class="cov0" title="0">
                        // Stop spinner - error will be reported later with details
                        if verbose </span><span class="cov0" title="0">{
                                spinner.StopWithError(fmt.Sprintf("%s failed", capitalizeStep(step)))
                        }</span> else<span class="cov0" title="0"> {
                                spinner.Stop()
                        }</span>
                case constants.ValidationProgressSkipped:<span class="cov0" title="0">
                        spinner.StopWithWarning(fmt.Sprintf("%s skipped (tool not installed)", capitalizeStep(step)))</span>
                }
        })

        // Run the validation pipeline
        <span class="cov0" title="0">result, err := runner.Run(ctx, workDir)

        // Ensure spinner is stopped on exit
        spinner.Stop()

        // Handle JSON output
        if outputFormat == OutputJSON </span><span class="cov0" title="0">{
                return out.JSON(pipelineResultToResponse(result))
        }</span>

        // Handle error
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return handlePipelineFailure(out, result)
        }</span>

        <span class="cov0" title="0">out.Success("All validations passed!")
        return nil</span>
}

// capitalizeStep formats step names for display.
func capitalizeStep(step string) string <span class="cov0" title="0">{
        switch step </span>{
        case "format":<span class="cov0" title="0">
                return "Format"</span>
        case "lint":<span class="cov0" title="0">
                return "Lint"</span>
        case "test":<span class="cov0" title="0">
                return "Test"</span>
        case "pre-commit":<span class="cov0" title="0">
                return "Pre-commit"</span>
        default:<span class="cov0" title="0">
                return step</span>
        }
}

// pipelineResultToResponse converts PipelineResult to ValidationResponse for JSON output.
func pipelineResultToResponse(result *validation.PipelineResult) ValidationResponse <span class="cov0" title="0">{
        if result == nil </span><span class="cov0" title="0">{
                return ValidationResponse{Success: false}
        }</span>

        <span class="cov0" title="0">allResults := result.AllResults()
        cliResults := make([]CommandResult, 0, len(allResults))
        for _, r := range allResults </span><span class="cov0" title="0">{
                cliResults = append(cliResults, CommandResult{
                        Command:    r.Command,
                        Success:    r.Success,
                        ExitCode:   r.ExitCode,
                        Output:     r.Stdout,
                        Error:      r.Error,
                        DurationMs: r.DurationMs,
                })
        }</span>

        <span class="cov0" title="0">return ValidationResponse{
                Success:      result.Success,
                Results:      cliResults,
                SkippedSteps: result.SkippedSteps,
                SkipReasons:  result.SkipReasons,
        }</span>
}

// handlePipelineFailure handles validation pipeline failure output.
func handlePipelineFailure(out tui.Output, result *validation.PipelineResult) error <span class="cov0" title="0">{
        if result == nil </span><span class="cov0" title="0">{
                return errors.ErrValidationFailed
        }</span>

        // Find the failed result and display error details
        <span class="cov0" title="0">allResults := result.AllResults()
        for _, r := range allResults </span><span class="cov0" title="0">{
                if !r.Success </span><span class="cov0" title="0">{
                        out.Error(tui.WrapWithSuggestion(fmt.Errorf("%w: %s (exit code: %d)", errors.ErrValidationFailed, r.Command, r.ExitCode)))
                        if r.Error != "" </span><span class="cov0" title="0">{
                                out.Info(r.Error)
                        }</span>
                        <span class="cov0" title="0">if r.Stderr != "" &amp;&amp; r.Stderr != r.Error </span><span class="cov0" title="0">{
                                out.Info(r.Stderr)
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov0" title="0">return errors.ErrValidationFailed</span>
}
</pre>

		<pre class="file" id="file35" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "fmt"
        "os/exec"
        "strings"

        "github.com/charmbracelet/huh"
        "github.com/mrz1836/atlas/internal/config"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/tui"
)

// ValidationProviderConfig holds validation configuration values collected from user input.
// This struct is used for collecting configuration before saving.
type ValidationProviderConfig struct {
        // FormatCmds is the multiline string of format commands (one per line).
        FormatCmds string
        // LintCmds is the multiline string of lint commands (one per line).
        LintCmds string
        // TestCmds is the multiline string of test commands (one per line).
        TestCmds string
        // PreCommitCmds is the multiline string of pre-commit commands (one per line).
        PreCommitCmds string
        // CustomPrePR is the multiline string of custom pre-PR hook commands (one per line).
        CustomPrePR string
}

// ValidationConfigDefaults returns the default values for validation configuration.
// Defaults are empty as commands should be suggested based on detected tools.
func ValidationConfigDefaults() ValidationProviderConfig <span class="cov0" title="0">{
        return ValidationProviderConfig{}
}</span>

// SuggestValidationDefaults suggests validation commands based on detected tools.
// This is the exported version of suggestValidationCommands for reuse.
func SuggestValidationDefaults(result *config.ToolDetectionResult) ValidationCommands <span class="cov0" title="0">{
        cmds := ValidationCommands{}

        hasMageX := false
        hasGoPreCommit := false

        if result != nil </span><span class="cov0" title="0">{
                for _, tool := range result.Tools </span><span class="cov0" title="0">{
                        if tool.Status == config.ToolStatusInstalled </span><span class="cov0" title="0">{
                                switch tool.Name </span>{
                                case constants.ToolMageX:<span class="cov0" title="0">
                                        hasMageX = true</span>
                                case constants.ToolGoPreCommit:<span class="cov0" title="0">
                                        hasGoPreCommit = true</span>
                                }
                        }
                }
        }

        // Set commands based on available tools
        <span class="cov0" title="0">if hasMageX </span><span class="cov0" title="0">{
                cmds.Format = []string{"magex format:fix"}
                cmds.Lint = []string{"magex lint"}
                cmds.Test = []string{"magex test"}
        }</span> else<span class="cov0" title="0"> {
                // Fallback to basic go commands
                cmds.Format = []string{"gofmt -w ."}
                cmds.Lint = []string{"go vet ./..."}
                cmds.Test = []string{"go test ./..."}
        }</span>

        <span class="cov0" title="0">if hasGoPreCommit </span><span class="cov0" title="0">{
                cmds.PreCommit = []string{"go-pre-commit run --all-files"}
        }</span>

        <span class="cov0" title="0">return cmds</span>
}

// ParseMultilineInput splits multiline input into a slice of strings.
// Each line is trimmed of whitespace and empty lines are filtered out.
func ParseMultilineInput(input string) []string <span class="cov0" title="0">{
        var result []string
        lines := strings.Split(input, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line != "" </span><span class="cov0" title="0">{
                        result = append(result, line)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// NewValidationConfigForm creates a Charm Huh form for validation configuration.
// The form collects format, lint, test, pre-commit, and custom pre-PR commands.
func NewValidationConfigForm(cfg *ValidationProviderConfig) *huh.Form <span class="cov0" title="0">{
        return huh.NewForm(
                huh.NewGroup(
                        huh.NewText().
                                Title("Format Commands").
                                Description("Commands to run for code formatting (one per line)").
                                Value(&amp;cfg.FormatCmds).
                                Placeholder("magex format:fix"),
                        huh.NewText().
                                Title("Lint Commands").
                                Description("Commands to run for linting (one per line)").
                                Value(&amp;cfg.LintCmds).
                                Placeholder("magex lint"),
                        huh.NewText().
                                Title("Test Commands").
                                Description("Commands to run for testing (one per line)").
                                Value(&amp;cfg.TestCmds).
                                Placeholder("magex test"),
                        huh.NewText().
                                Title("Pre-commit Commands").
                                Description("Commands to run before commits (one per line)").
                                Value(&amp;cfg.PreCommitCmds).
                                Placeholder("go-pre-commit run --all-files"),
                        huh.NewText().
                                Title("Custom Pre-PR Hooks").
                                Description("Additional commands to run before PR creation (one per line, optional)").
                                Value(&amp;cfg.CustomPrePR).
                                Placeholder("custom-validation-script"),
                ),
        ).WithTheme(tui.AtlasTheme())
}</span>

// CollectValidationConfigInteractive runs the validation configuration form.
// It populates the config with defaults based on detected tools and runs the form.
func CollectValidationConfigInteractive(ctx context.Context, cfg *ValidationProviderConfig, toolResult *config.ToolDetectionResult) error <span class="cov0" title="0">{
        // Check cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        // Populate defaults based on detected tools
        <span class="cov0" title="0">PopulateValidationConfigDefaults(cfg, toolResult)

        // Create and run the main form
        form := NewValidationConfigForm(cfg)
        if err := form.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CollectValidationConfigNonInteractive returns a configuration with defaults based on detected tools.
// Used when running in non-interactive mode.
func CollectValidationConfigNonInteractive(toolResult *config.ToolDetectionResult) ValidationProviderConfig <span class="cov0" title="0">{
        cfg := ValidationConfigDefaults()
        PopulateValidationConfigDefaults(&amp;cfg, toolResult)
        return cfg
}</span>

// PopulateValidationConfigDefaults populates the config with suggested defaults based on detected tools.
// The defaults are set as multiline strings for display in the form.
func PopulateValidationConfigDefaults(cfg *ValidationProviderConfig, toolResult *config.ToolDetectionResult) <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">defaults := SuggestValidationDefaults(toolResult)

        cfg.FormatCmds = strings.Join(defaults.Format, "\n")
        cfg.LintCmds = strings.Join(defaults.Lint, "\n")
        cfg.TestCmds = strings.Join(defaults.Test, "\n")
        cfg.PreCommitCmds = strings.Join(defaults.PreCommit, "\n")</span>
}

// ToValidationCommands converts the provider config to ValidationCommands struct.
func (cfg *ValidationProviderConfig) ToValidationCommands() ValidationCommands <span class="cov0" title="0">{
        return ValidationCommands{
                Format:      ParseMultilineInput(cfg.FormatCmds),
                Lint:        ParseMultilineInput(cfg.LintCmds),
                Test:        ParseMultilineInput(cfg.TestCmds),
                PreCommit:   ParseMultilineInput(cfg.PreCommitCmds),
                CustomPrePR: ParseMultilineInput(cfg.CustomPrePR),
        }
}</span>

// ToValidationConfig converts the provider config to ValidationConfig struct.
func (cfg *ValidationProviderConfig) ToValidationConfig() ValidationConfig <span class="cov0" title="0">{
        return ValidationConfig{
                Commands: cfg.ToValidationCommands(),
        }
}</span>

// extractBaseCommand extracts the base command from a full command string.
// For example, "magex format:fix" returns "magex".
func extractBaseCommand(fullCmd string) string <span class="cov0" title="0">{
        parts := strings.Fields(fullCmd)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return parts[0]</span>
}

// ValidateCommand checks if a command is executable.
// It returns whether the command exists in PATH and a warning message if not.
// The function only checks the base command (first word), ignoring arguments.
func ValidateCommand(cmd string) (exists bool, warning string) <span class="cov0" title="0">{
        cmd = strings.TrimSpace(cmd)
        if cmd == "" </span><span class="cov0" title="0">{
                return false, "empty command"
        }</span>

        <span class="cov0" title="0">baseCmd := extractBaseCommand(cmd)
        if baseCmd == "" </span><span class="cov0" title="0">{
                return false, "empty command"
        }</span>

        <span class="cov0" title="0">_, err := exec.LookPath(baseCmd)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Sprintf("command '%s' not found in PATH", baseCmd)
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

// ValidateCommands checks all commands in a multiline string.
// Returns a slice of warnings for commands that are not found.
// Commands are not rejected - only warnings are returned.
func ValidateCommands(multilineInput string) []string <span class="cov0" title="0">{
        var warnings []string
        cmds := ParseMultilineInput(multilineInput)
        for _, cmd := range cmds </span><span class="cov0" title="0">{
                if exists, warning := ValidateCommand(cmd); !exists </span><span class="cov0" title="0">{
                        warnings = append(warnings, warning)
                }</span>
        }
        <span class="cov0" title="0">return warnings</span>
}

// ValidateAllConfigCommands validates all commands in the configuration.
// Returns a map of category to warnings for that category.
func ValidateAllConfigCommands(cfg *ValidationProviderConfig) map[string][]string <span class="cov0" title="0">{
        result := make(map[string][]string)

        if warnings := ValidateCommands(cfg.FormatCmds); len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                result["Format"] = warnings
        }</span>
        <span class="cov0" title="0">if warnings := ValidateCommands(cfg.LintCmds); len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                result["Lint"] = warnings
        }</span>
        <span class="cov0" title="0">if warnings := ValidateCommands(cfg.TestCmds); len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                result["Test"] = warnings
        }</span>
        <span class="cov0" title="0">if warnings := ValidateCommands(cfg.PreCommitCmds); len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                result["Pre-commit"] = warnings
        }</span>
        <span class="cov0" title="0">if warnings := ValidateCommands(cfg.CustomPrePR); len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                result["Custom Pre-PR"] = warnings
        }</span>

        <span class="cov0" title="0">return result</span>
}
</pre>

		<pre class="file" id="file36" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "github.com/spf13/cobra"
)

// newWorkspaceCmd creates the parent workspace command.
func newWorkspaceCmd() *cobra.Command <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "workspace",
                Short: "Manage ATLAS workspaces",
                Long: `Commands for managing ATLAS workspaces including listing,
destroying, and closing workspaces.

A workspace represents an isolated development environment with its own
git worktree and task history.`,
                // No RunE - parent command just displays help
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return cmd.Help()
                }</span>,
        }

        // Add subcommands
        <span class="cov0" title="0">addWorkspaceListCmd(cmd)
        addWorkspaceDestroyCmd(cmd)
        addWorkspaceCloseCmd(cmd)
        addWorkspaceLogsCmd(cmd)

        return cmd</span>
}

// AddWorkspaceCommand adds the workspace command tree to the root command.
func AddWorkspaceCommand(parent *cobra.Command) <span class="cov0" title="0">{
        parent.AddCommand(newWorkspaceCmd())
}</span>
</pre>

		<pre class="file" id="file37" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "encoding/json"
        stderrors "errors"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/charmbracelet/huh"
        "github.com/charmbracelet/lipgloss"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/task"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/workspace"
        "github.com/rs/zerolog"
        "github.com/spf13/cobra"
)

// addWorkspaceCloseCmd adds the close subcommand to the workspace command.
func addWorkspaceCloseCmd(parent *cobra.Command) <span class="cov0" title="0">{
        var force bool

        cmd := &amp;cobra.Command{
                Use:   "close &lt;name&gt;",
                Short: "Close a workspace, preserving history",
                Long: `Archive a completed workspace by removing its git worktree
while preserving all task history and the git branch.

Use this when you're done with a workspace but want to keep the history
for reference. The closed workspace will still appear in 'workspace list'.

Examples:
  atlas workspace close auth          # Confirm and close
  atlas workspace close auth --force  # Close without confirmation`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        err := runWorkspaceClose(cmd.Context(), cmd, os.Stdout, args[0], force, "")
                        // If JSON error was already output, silence cobra's error printing
                        // but still return error for non-zero exit code
                        if stderrors.Is(err, errors.ErrJSONErrorOutput) </span><span class="cov0" title="0">{
                                cmd.SilenceErrors = true
                        }</span>
                        <span class="cov0" title="0">return err</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;force, "force", "f", false, "Skip confirmation prompt")

        parent.AddCommand(cmd)</span>
}

// runWorkspaceClose executes the workspace close command.
func runWorkspaceClose(ctx context.Context, cmd *cobra.Command, w io.Writer, name string, force bool, storeBaseDir string) error <span class="cov0" title="0">{
        // Check for cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        // Get output format from global flags
        <span class="cov0" title="0">output := cmd.Flag("output").Value.String()

        return runWorkspaceCloseWithOutput(ctx, w, name, force, storeBaseDir, output)</span>
}

// runWorkspaceCloseWithOutput executes the workspace close command with explicit output format.
func runWorkspaceCloseWithOutput(ctx context.Context, w io.Writer, name string, force bool, storeBaseDir, output string) error <span class="cov0" title="0">{
        logger := Logger()

        // Respect NO_COLOR environment variable (UX-7)
        tui.CheckNoColor()

        // Create store and check workspace existence
        store, exists, err := checkWorkspaceExistsForClose(ctx, name, storeBaseDir, output, w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return handleCloseWorkspaceNotFound(name, output, w)
        }</span>

        // Check if workspace is already closed
        <span class="cov0" title="0">ws, err := store.Get(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputCloseErrorJSON(w, name, fmt.Sprintf("failed to get workspace: %v", err))
                        return errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get workspace '%s': %w", name, err)</span>
        }

        <span class="cov0" title="0">if ws.Status == constants.WorkspaceStatusClosed </span><span class="cov0" title="0">{
                if output == OutputJSON </span><span class="cov0" title="0">{
                        // Return success for already closed (idempotent)
                        return outputCloseSuccessJSON(w, name)
                }</span>
                <span class="cov0" title="0">_, _ = fmt.Fprintf(w, "Workspace '%s' is already closed.\n", name)
                return nil</span>
        }

        // Handle confirmation if needed
        <span class="cov0" title="0">if err := handleCloseConfirmation(name, force, output, w); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Execute the close operation
        <span class="cov0" title="0">return executeClose(ctx, store, name, storeBaseDir, output, w, logger)</span>
}

// checkWorkspaceExistsForClose creates the store and checks if the workspace exists.
// Returns (store, exists, error). For JSON output errors, returns ErrJSONErrorOutput.
func checkWorkspaceExistsForClose(ctx context.Context, name, storeBaseDir, output string, w io.Writer) (*workspace.FileStore, bool, error) <span class="cov0" title="0">{
        logger := Logger()

        store, err := workspace.NewFileStore(storeBaseDir)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(err).Msg("failed to create workspace store")
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputCloseErrorJSON(w, name, fmt.Sprintf("failed to create workspace store: %v", err))
                        return nil, false, errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return nil, false, fmt.Errorf("failed to create workspace store: %w", err)</span>
        }

        <span class="cov0" title="0">exists, err := store.Exists(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(err).Str("workspace", name).Msg("failed to check workspace existence")
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputCloseErrorJSON(w, name, fmt.Sprintf("failed to check workspace: %v", err))
                        return nil, false, errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return nil, false, fmt.Errorf("failed to check workspace '%s': %w", name, err)</span>
        }

        <span class="cov0" title="0">return store, exists, nil</span>
}

// handleCloseWorkspaceNotFound handles the case when a workspace is not found.
func handleCloseWorkspaceNotFound(name, output string, w io.Writer) error <span class="cov0" title="0">{
        if output == OutputJSON </span><span class="cov0" title="0">{
                // Output JSON error and return sentinel so caller knows to silence cobra's error printing
                _ = outputCloseErrorJSON(w, name, "workspace not found")
                return errors.ErrJSONErrorOutput
        }</span>
        // Match AC5 format exactly: "Workspace 'nonexistent' not found"
        // Wrap sentinel for programmatic error checking
        //nolint:staticcheck // ST1005: AC5 requires capitalized error for user-facing message
        <span class="cov0" title="0">return fmt.Errorf("Workspace '%s' not found: %w", name, errors.ErrWorkspaceNotFound)</span>
}

// handleCloseConfirmation handles the user confirmation flow.
// Returns nil if confirmed or force is true, error otherwise.
func handleCloseConfirmation(name string, force bool, output string, w io.Writer) error <span class="cov0" title="0">{
        if force </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if !terminalCheck() </span><span class="cov0" title="0">{
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputCloseErrorJSON(w, name, "cannot close workspace: use --force in non-interactive mode")
                        return errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("cannot close workspace '%s': %w", name, errors.ErrNonInteractiveMode)</span>
        }

        <span class="cov0" title="0">confirmed, err := confirmClose(name)
        if err != nil </span><span class="cov0" title="0">{
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputCloseErrorJSON(w, name, fmt.Sprintf("failed to get confirmation: %v", err))
                        return errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get confirmation: %w", err)</span>
        }

        <span class="cov0" title="0">if !confirmed </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, "Operation canceled.")
                return nil
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// executeClose performs the actual close operation.
func executeClose(ctx context.Context, store *workspace.FileStore, name, storeBaseDir, output string, w io.Writer, logger zerolog.Logger) error <span class="cov0" title="0">{
        // Get repo path for worktree runner
        repoPath, err := detectRepoPath()
        if err != nil </span><span class="cov0" title="0">{
                // If we can't detect repo, worktree operations will fail gracefully
                logger.Debug().Err(err).Msg("could not detect repo path, worktree cleanup may be limited")
                repoPath = ""
        }</span>

        // Create worktree runner (may be nil if no repo path)
        <span class="cov0" title="0">var wtRunner workspace.WorktreeRunner
        if repoPath != "" </span><span class="cov0" title="0">{
                wtRunner, err = workspace.NewGitWorktreeRunner(ctx, repoPath, logger)
                if err != nil </span><span class="cov0" title="0">{
                        // Log but continue - close should still update state
                        logger.Debug().Err(err).Msg("could not create worktree runner, worktree cleanup may be limited")
                        wtRunner = nil
                }</span>
        }

        // Create task store to check for running tasks before closing
        // This prevents closing a workspace while tasks are actively running
        <span class="cov0" title="0">var taskLister workspace.TaskLister
        taskStore, taskErr := task.NewFileStore(storeBaseDir)
        if taskErr != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(taskErr).Msg("could not create task store, running task check will be skipped")
        }</span> else<span class="cov0" title="0"> {
                taskLister = taskStore
        }</span>

        // Create manager and close
        <span class="cov0" title="0">mgr := workspace.NewManager(store, wtRunner, logger)

        result, closeErr := mgr.Close(ctx, name, taskLister)
        if closeErr != nil </span><span class="cov0" title="0">{
                return handleCloseError(w, name, output, closeErr)
        }</span>

        // Get warning messages if worktree or branch removal failed
        <span class="cov0" title="0">var warning string
        if result != nil </span><span class="cov0" title="0">{
                var warnings []string
                if result.WorktreeWarning != "" </span><span class="cov0" title="0">{
                        warnings = append(warnings, result.WorktreeWarning)
                }</span>
                <span class="cov0" title="0">if result.BranchWarning != "" </span><span class="cov0" title="0">{
                        warnings = append(warnings, result.BranchWarning)
                }</span>
                <span class="cov0" title="0">if len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                        warning = strings.Join(warnings, "; ")
                }</span>
        }

        // Output success with optional warning
        <span class="cov0" title="0">if output == OutputJSON </span><span class="cov0" title="0">{
                return outputCloseSuccessJSONWithWarning(w, name, warning)
        }</span>

        // Text output: success message first, then warning if any
        <span class="cov0" title="0">if err := outputCloseSuccess(w, name, output); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("output close success: %w", err)
        }</span>
        <span class="cov0" title="0">if warning != "" </span><span class="cov0" title="0">{
                outputCloseWarning(w, warning, output)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleCloseError handles errors from the close operation.
func handleCloseError(w io.Writer, name, output string, closeErr error) error <span class="cov0" title="0">{
        // Check for running tasks error (AC #3)
        if stderrors.Is(closeErr, errors.ErrWorkspaceHasRunningTasks) </span><span class="cov0" title="0">{
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputCloseErrorJSON(w, name, "cannot close workspace with running tasks")
                        return errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("cannot close workspace '%s' with running tasks: %w", name, closeErr)</span>
        }

        // Other errors
        <span class="cov0" title="0">if output == OutputJSON </span><span class="cov0" title="0">{
                _ = outputCloseErrorJSON(w, name, closeErr.Error())
                return errors.ErrJSONErrorOutput
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("failed to close workspace '%s': %w", name, closeErr)</span>
}

// outputCloseSuccess outputs success message in appropriate format.
func outputCloseSuccess(w io.Writer, name, output string) error <span class="cov0" title="0">{
        if output == OutputJSON </span><span class="cov0" title="0">{
                return outputCloseSuccessJSON(w, name)
        }</span>

        // Use lipgloss for styled success message (AC #2)
        <span class="cov0" title="0">checkmark := lipgloss.NewStyle().Foreground(lipgloss.Color("42")).Render("✓")
        _, _ = fmt.Fprintf(w, "%s Workspace '%s' closed. History preserved.\n", checkmark, name)

        return nil</span>
}

// outputCloseWarning outputs a warning message about worktree removal failure.
func outputCloseWarning(w io.Writer, warning, output string) <span class="cov0" title="0">{
        if output == OutputJSON </span><span class="cov0" title="0">{
                // For JSON output, include warning in a separate line
                if err := json.NewEncoder(w).Encode(map[string]any{
                        "type":    "warning",
                        "message": warning,
                }); err != nil </span><span class="cov0" title="0">{
                        // Best effort - if JSON encoding fails, fall back to stderr
                        _, _ = fmt.Fprintf(os.Stderr, "Warning: %s\n", warning)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Use lipgloss for styled warning message
        <span class="cov0" title="0">warningIcon := lipgloss.NewStyle().Foreground(lipgloss.Color("214")).Render("⚠")
        _, _ = fmt.Fprintf(w, "%s Warning: %s\n", warningIcon, warning)</span>
}

// confirmClose prompts the user for confirmation before closing a workspace.
func confirmClose(name string) (bool, error) <span class="cov0" title="0">{
        var confirm bool

        form := huh.NewForm(
                huh.NewGroup(
                        huh.NewConfirm().
                                Title(fmt.Sprintf("Close workspace '%s'?", name)).
                                Description("Worktree will be removed but history preserved.").
                                Affirmative("Yes, close").
                                Negative("No, cancel").
                                Value(&amp;confirm),
                ),
        )

        if err := form.Run(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return confirm, nil</span>
}

// closeResult represents the JSON output for close operations.
type closeResult struct {
        Status           string `json:"status"`
        Workspace        string `json:"workspace"`
        HistoryPreserved bool   `json:"history_preserved,omitempty"`
        Warning          string `json:"warning,omitempty"`
        Error            string `json:"error,omitempty"`
}

// outputCloseSuccessJSON outputs a success result as JSON.
func outputCloseSuccessJSON(w io.Writer, name string) error <span class="cov0" title="0">{
        return outputCloseSuccessJSONWithWarning(w, name, "")
}</span>

// outputCloseSuccessJSONWithWarning outputs a success result as JSON with an optional warning.
func outputCloseSuccessJSONWithWarning(w io.Writer, name, warning string) error <span class="cov0" title="0">{
        result := closeResult{
                Status:           "closed",
                Workspace:        name,
                HistoryPreserved: true,
                Warning:          warning,
        }

        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(result)
}</span>

// outputCloseErrorJSON outputs an error result as JSON.
// Returns the encoding error if JSON output fails, which callers typically
// ignore with `_ =` since ErrJSONErrorOutput is already being returned.
func outputCloseErrorJSON(w io.Writer, name, errMsg string) error <span class="cov0" title="0">{
        result := closeResult{
                Status:    "error",
                Workspace: name,
                Error:     errMsg,
        }

        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(result)
}</span>
</pre>

		<pre class="file" id="file38" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "encoding/json"
        stderrors "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/charmbracelet/huh"
        "github.com/charmbracelet/lipgloss"
        "github.com/mrz1836/atlas/internal/backlog"
        "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/task"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/workspace"
        "github.com/rs/zerolog"
        "github.com/spf13/cobra"
        "golang.org/x/term"
)

// addWorkspaceDestroyCmd adds the destroy subcommand to the workspace command.
func addWorkspaceDestroyCmd(parent *cobra.Command) <span class="cov0" title="0">{
        var force bool

        cmd := &amp;cobra.Command{
                Use:   "destroy &lt;name&gt;",
                Short: "Destroy a workspace and its worktree",
                Long: `Completely remove a workspace including its git worktree,
branch, and all associated state files.

This operation cannot be undone. Use --force to skip confirmation.

Examples:
  atlas workspace destroy payment           # Confirm and destroy
  atlas workspace destroy payment --force   # Destroy without confirmation`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        err := runWorkspaceDestroy(cmd.Context(), cmd, os.Stdout, args[0], force, "")
                        // If JSON error was already output, silence cobra's error printing
                        // but still return error for non-zero exit code
                        if stderrors.Is(err, errors.ErrJSONErrorOutput) </span><span class="cov0" title="0">{
                                cmd.SilenceErrors = true
                        }</span>
                        <span class="cov0" title="0">return err</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;force, "force", "f", false, "Skip confirmation prompt")

        parent.AddCommand(cmd)</span>
}

// runWorkspaceDestroy executes the workspace destroy command.
func runWorkspaceDestroy(ctx context.Context, cmd *cobra.Command, w io.Writer, name string, force bool, storeBaseDir string) error <span class="cov0" title="0">{
        // Check for cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        // Get output format from global flags
        <span class="cov0" title="0">output := cmd.Flag("output").Value.String()

        return runWorkspaceDestroyWithOutput(ctx, w, name, force, storeBaseDir, output)</span>
}

// runWorkspaceDestroyWithOutput executes the workspace destroy command with explicit output format.
func runWorkspaceDestroyWithOutput(ctx context.Context, w io.Writer, name string, force bool, storeBaseDir, output string) error <span class="cov0" title="0">{
        logger := Logger()

        // Respect NO_COLOR environment variable (UX-7)
        tui.CheckNoColor()

        // Create store and check workspace existence
        store, exists, err := checkWorkspaceExists(ctx, name, storeBaseDir, output, w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return handleWorkspaceNotFound(name, output, w)
        }</span>

        // Handle confirmation if needed
        <span class="cov0" title="0">if err := handleConfirmation(name, force, output, w); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Execute the destroy operation
        <span class="cov0" title="0">return executeDestroy(ctx, store, name, output, w, logger)</span>
}

// checkWorkspaceExists creates the store and checks if the workspace exists.
// Returns (store, exists, error). For JSON output errors, returns ErrJSONErrorOutput.
func checkWorkspaceExists(ctx context.Context, name, storeBaseDir, output string, w io.Writer) (*workspace.FileStore, bool, error) <span class="cov0" title="0">{
        logger := Logger()

        store, err := workspace.NewFileStore(storeBaseDir)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(err).Msg("failed to create workspace store")
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputDestroyErrorJSON(w, name, fmt.Sprintf("failed to create workspace store: %v", err))
                        return nil, false, errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return nil, false, fmt.Errorf("failed to create workspace store: %w", err)</span>
        }

        <span class="cov0" title="0">exists, err := store.Exists(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(err).Str("workspace", name).Msg("failed to check workspace existence")
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputDestroyErrorJSON(w, name, fmt.Sprintf("failed to check workspace: %v", err))
                        return nil, false, errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return nil, false, fmt.Errorf("failed to check workspace '%s': %w", name, err)</span>
        }

        <span class="cov0" title="0">return store, exists, nil</span>
}

// handleWorkspaceNotFound handles the case when a workspace is not found.
func handleWorkspaceNotFound(name, output string, w io.Writer) error <span class="cov0" title="0">{
        if output == OutputJSON </span><span class="cov0" title="0">{
                // Output JSON error and return sentinel so caller knows to silence cobra's error printing
                _ = outputDestroyErrorJSON(w, name, "workspace not found")
                return errors.ErrJSONErrorOutput
        }</span>
        // Match AC5 format exactly: "Workspace 'nonexistent' not found"
        // Wrap sentinel for programmatic error checking
        //nolint:staticcheck // ST1005: AC5 requires capitalized error for user-facing message
        <span class="cov0" title="0">return fmt.Errorf("Workspace '%s' not found: %w", name, errors.ErrWorkspaceNotFound)</span>
}

// handleConfirmation handles the user confirmation flow.
// Returns nil if confirmed or force is true, error otherwise.
func handleConfirmation(name string, force bool, output string, w io.Writer) error <span class="cov0" title="0">{
        if force </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if !terminalCheck() </span><span class="cov0" title="0">{
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputDestroyErrorJSON(w, name, "cannot destroy workspace: use --force in non-interactive mode")
                        return errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("cannot destroy workspace '%s': %w", name, errors.ErrNonInteractiveMode)</span>
        }

        <span class="cov0" title="0">confirmed, err := confirmDestroy(name)
        if err != nil </span><span class="cov0" title="0">{
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputDestroyErrorJSON(w, name, fmt.Sprintf("failed to get confirmation: %v", err))
                        return errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get confirmation: %w", err)</span>
        }

        <span class="cov0" title="0">if !confirmed </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, "Operation canceled.")
                return nil
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// executeDestroy performs the actual destroy operation.
func executeDestroy(ctx context.Context, store *workspace.FileStore, name, output string, w io.Writer, logger zerolog.Logger) error <span class="cov0" title="0">{
        // Get workspace first to store path/branch info for better error reporting
        ws, wsErr := store.Get(ctx, name)
        var worktreePath, branch string
        if wsErr == nil &amp;&amp; ws != nil </span><span class="cov0" title="0">{
                worktreePath = ws.WorktreePath
                branch = ws.Branch
        }</span>

        // Delete linked backlog discoveries before destroying workspace (best-effort)
        <span class="cov0" title="0">deleteLinkedDiscoveries(ctx, name, logger)

        // Get repo path for worktree runner
        repoPath, err := detectRepoPath()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("could not detect repo path, worktree cleanup will be skipped")
                // Show warning to user if we have worktree info
                if worktreePath != "" </span><span class="cov0" title="0">{
                        logger.Warn().
                                Str("worktree_path", worktreePath).
                                Str("branch", branch).
                                Msg("manual cleanup may be required: run 'git worktree remove --force &lt;path&gt;' and 'git branch -D &lt;branch&gt;'")
                }</span>
                <span class="cov0" title="0">repoPath = ""</span>
        }

        // Create worktree runner (may be nil if no repo path)
        <span class="cov0" title="0">var wtRunner workspace.WorktreeRunner
        if repoPath != "" </span><span class="cov0" title="0">{
                wtRunner, err = workspace.NewGitWorktreeRunner(ctx, repoPath, logger)
                if err != nil </span><span class="cov0" title="0">{
                        // Log but continue - destroy should still clean up state
                        logger.Warn().Err(err).Msg("could not create worktree runner, worktree cleanup will be limited")
                        wtRunner = nil
                }</span>
        }

        // Create manager and destroy
        <span class="cov0" title="0">mgr := workspace.NewManager(store, wtRunner, logger)

        if destroyErr := mgr.Destroy(ctx, name); destroyErr != nil </span><span class="cov0" title="0">{
                // This should never happen per NFR18, but handle just in case
                if output == OutputJSON </span><span class="cov0" title="0">{
                        return outputDestroyErrorJSON(w, name, destroyErr.Error())
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to destroy workspace '%s': %w", name, destroyErr)</span>
        }

        // If we couldn't create worktree runner, add helpful message
        <span class="cov0" title="0">if wtRunner == nil &amp;&amp; worktreePath != "" </span><span class="cov0" title="0">{
                showManualCleanupWarning(w, output, worktreePath, branch, logger)
        }</span>

        // Output success
        <span class="cov0" title="0">if output == OutputJSON </span><span class="cov0" title="0">{
                return outputDestroySuccessJSON(w, name)
        }</span>

        // Use lipgloss for styled success message
        <span class="cov0" title="0">checkmark := lipgloss.NewStyle().Foreground(lipgloss.Color("42")).Render("✓")
        _, _ = fmt.Fprintf(w, "%s Workspace '%s' destroyed\n", checkmark, name)

        return nil</span>
}

// showManualCleanupWarning displays manual cleanup instructions when worktree runner is unavailable.
func showManualCleanupWarning(w io.Writer, output, worktreePath, branch string, logger zerolog.Logger) <span class="cov0" title="0">{
        logger.Warn().Msg("workspace state deleted, but worktree cleanup was limited")
        if output == OutputJSON </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">_, _ = fmt.Fprintf(w, "\n⚠️  Manual cleanup may be required:\n")
        if worktreePath != "" </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "   git worktree remove --force %s\n", worktreePath)
        }</span>
        <span class="cov0" title="0">if branch != "" </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(w, "   git branch -D %s\n", branch)
        }</span>
        <span class="cov0" title="0">_, _ = fmt.Fprintf(w, "\n")</span>
}

// confirmDestroy prompts the user for confirmation before destroying a workspace.
func confirmDestroy(name string) (bool, error) <span class="cov0" title="0">{
        var confirm bool

        form := huh.NewForm(
                huh.NewGroup(
                        huh.NewConfirm().
                                Title(fmt.Sprintf("Delete workspace '%s'?", name)).
                                Description("This cannot be undone.").
                                Affirmative("Yes, delete").
                                Negative("No, cancel").
                                Value(&amp;confirm),
                ),
        )

        if err := form.Run(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return confirm, nil</span>
}

// terminalCheck is a variable for the terminal check function, allowing tests to override it.
//
//nolint:gochecknoglobals // Required for test injection of terminal detection
var terminalCheck = isTerminal

// isTerminal returns true if stdin is a terminal.
func isTerminal() bool <span class="cov0" title="0">{
        return term.IsTerminal(int(os.Stdin.Fd()))
}</span>

// detectRepoPath finds the git repository root from the current working directory.
func detectRepoPath() (string, error) <span class="cov0" title="0">{
        // Try current working directory
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Check if it's a git repo by looking for .git
        // Walk up directory tree
        <span class="cov0" title="0">dir := cwd
        for </span><span class="cov0" title="0">{
                gitPath := filepath.Join(dir, ".git")
                if _, err := os.Stat(gitPath); err == nil </span><span class="cov0" title="0">{
                        return dir, nil
                }</span>

                <span class="cov0" title="0">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        // Reached root
                        break</span>
                }
                <span class="cov0" title="0">dir = parent</span>
        }

        <span class="cov0" title="0">return "", errors.ErrNotGitRepo</span>
}

// destroyResult represents the JSON output for destroy operations.
type destroyResult struct {
        Status    string `json:"status"`
        Workspace string `json:"workspace"`
        Error     string `json:"error,omitempty"`
}

// outputDestroySuccessJSON outputs a success result as JSON.
func outputDestroySuccessJSON(w io.Writer, name string) error <span class="cov0" title="0">{
        result := destroyResult{
                Status:    "destroyed",
                Workspace: name,
        }

        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(result)
}</span>

// outputDestroyErrorJSON outputs an error result as JSON.
// Returns the encoding error if JSON output fails, which callers typically
// ignore with `_ =` since ErrJSONErrorOutput is already being returned.
// This is intentional: if we can't write JSON, there's no useful fallback,
// and the caller's return of ErrJSONErrorOutput signals to cobra to suppress
// its own error printing regardless of whether our JSON succeeded.
func outputDestroyErrorJSON(w io.Writer, name, errMsg string) error <span class="cov0" title="0">{
        result := destroyResult{
                Status:    "error",
                Workspace: name,
                Error:     errMsg,
        }

        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(result)
}</span>

// deleteLinkedDiscoveries removes backlog discovery files linked to tasks in the workspace.
// This is a best-effort operation - failures are logged but don't prevent workspace destruction.
// Git history provides the audit trail for deleted discoveries.
func deleteLinkedDiscoveries(ctx context.Context, workspaceName string, logger zerolog.Logger) <span class="cov0" title="0">{
        // Create task store to list tasks for the workspace
        taskStore, err := task.NewFileStore("")
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(err).Msg("could not create task store for discovery cleanup")
                return
        }</span>

        // List all tasks in the workspace
        <span class="cov0" title="0">tasks, err := taskStore.List(ctx, workspaceName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(err).
                        Str("workspace_name", workspaceName).
                        Msg("could not list tasks for discovery cleanup")
                return
        }</span>

        // Create backlog manager
        <span class="cov0" title="0">backlogMgr, err := backlog.NewManager("")
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(err).Msg("could not create backlog manager for discovery cleanup")
                return
        }</span>

        // Check each task for linked discoveries and delete them
        <span class="cov0" title="0">for _, t := range tasks </span><span class="cov0" title="0">{
                if t.Metadata == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">backlogID, ok := t.Metadata["from_backlog_id"].(string)
                if !ok || backlogID == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Delete the discovery file (best-effort)
                <span class="cov0" title="0">if deleteErr := backlogMgr.Delete(ctx, backlogID); deleteErr != nil </span><span class="cov0" title="0">{
                        logger.Debug().Err(deleteErr).
                                Str("discovery_id", backlogID).
                                Str("task_id", t.ID).
                                Msg("could not delete linked discovery")
                }</span> else<span class="cov0" title="0"> {
                        logger.Info().
                                Str("discovery_id", backlogID).
                                Str("task_id", t.ID).
                                Str("workspace_name", workspaceName).
                                Msg("deleted linked backlog discovery")
                }</span>
        }
}
</pre>

		<pre class="file" id="file39" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"

        "github.com/charmbracelet/lipgloss"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/domain"
        "github.com/mrz1836/atlas/internal/task"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/workspace"
        "github.com/spf13/cobra"
)

// tableStyles holds lipgloss styles for table rendering.
type tableStyles struct {
        header       lipgloss.Style
        cell         lipgloss.Style
        dim          lipgloss.Style
        statusColors map[constants.WorkspaceStatus]lipgloss.AdaptiveColor
}

// newTableStyles creates styles for the workspace list table.
func newTableStyles() *tableStyles <span class="cov0" title="0">{
        return &amp;tableStyles{
                header: lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.AdaptiveColor{Light: "#333333", Dark: "#DDDDDD"}),
                cell: lipgloss.NewStyle(),
                dim: lipgloss.NewStyle().
                        Foreground(lipgloss.AdaptiveColor{Light: "#666666", Dark: "#888888"}),
                // Semantic colors for workspace statuses (UX-6)
                statusColors: map[constants.WorkspaceStatus]lipgloss.AdaptiveColor{
                        constants.WorkspaceStatusActive: {Light: "#0087AF", Dark: "#00D7FF"}, // Blue
                        constants.WorkspaceStatusPaused: {Light: "#585858", Dark: "#6C6C6C"}, // Gray
                        constants.WorkspaceStatusClosed: {Light: "#585858", Dark: "#6C6C6C"}, // Dim
                },
        }
}</span>

// addWorkspaceListCmd adds the list subcommand to the workspace command.
func addWorkspaceListCmd(parent *cobra.Command) <span class="cov0" title="0">{
        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List all workspaces",
                Long: `Display a table of all ATLAS workspaces with their status,
branch, creation time, and task count.

Examples:
  atlas workspace list              # Display as styled table
  atlas workspace list --output json # Display as JSON array
  atlas workspace ls                 # Alias for list`,
                Aliases: []string{"ls"},
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return runWorkspaceList(cmd.Context(), cmd, os.Stdout)
                }</span>,
        }
        <span class="cov0" title="0">parent.AddCommand(cmd)</span>
}

// runWorkspaceList executes the workspace list command.
func runWorkspaceList(ctx context.Context, cmd *cobra.Command, w io.Writer) error <span class="cov0" title="0">{
        // Check for cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">logger := Logger()

        // Get output format from global flags
        output := cmd.Flag("output").Value.String()

        // Respect NO_COLOR environment variable (UX-7)
        tui.CheckNoColor()

        // Create store and manager
        store, err := workspace.NewFileStore("")
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(err).Msg("failed to create workspace store")
                return fmt.Errorf("failed to create workspace store: %w", err)
        }</span>

        // Create manager (nil worktreeRunner OK for List operation)
        <span class="cov0" title="0">mgr := workspace.NewManager(store, nil, logger)

        // Get all workspaces
        workspaces, err := mgr.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(err).Msg("failed to list workspaces")
                return fmt.Errorf("failed to list workspaces: %w", err)
        }</span>

        // Handle empty case
        <span class="cov0" title="0">if len(workspaces) == 0 </span><span class="cov0" title="0">{
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _, _ = fmt.Fprintln(w, "[]")
                }</span> else<span class="cov0" title="0"> {
                        _, _ = fmt.Fprintln(w, "No workspaces. Run 'atlas start' to create one.")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Output based on format
        <span class="cov0" title="0">if output == OutputJSON </span><span class="cov0" title="0">{
                return outputWorkspacesJSON(w, workspaces)
        }</span>

        <span class="cov0" title="0">return outputWorkspacesTable(w, workspaces)</span>
}

// outputWorkspacesJSON outputs workspaces as JSON array.
func outputWorkspacesJSON(w io.Writer, workspaces []*domain.Workspace) error <span class="cov0" title="0">{
        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(workspaces); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode workspaces to JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// countActiveTasks returns the number of non-terminal tasks in the workspace.
func countActiveTasks(ws *domain.Workspace) int <span class="cov0" title="0">{
        count := 0
        for _, taskRef := range ws.Tasks </span><span class="cov0" title="0">{
                if !task.IsTerminalStatus(taskRef.Status) </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// countCompletedTasks returns the number of terminal tasks in the workspace.
func countCompletedTasks(ws *domain.Workspace) int <span class="cov0" title="0">{
        count := 0
        for _, taskRef := range ws.Tasks </span><span class="cov0" title="0">{
                if task.IsTerminalStatus(taskRef.Status) </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// outputWorkspacesTable outputs workspaces as a styled table.
func outputWorkspacesTable(w io.Writer, workspaces []*domain.Workspace) error <span class="cov0" title="0">{
        styles := newTableStyles()

        // Define column widths
        const (
                nameWidth      = 12
                branchWidth    = 20
                statusWidth    = 10
                createdWidth   = 15
                activeWidth    = 6 // "ACTIVE" header
                completedWidth = 9 // "COMPLETED" header
        )

        // Print header
        header := fmt.Sprintf("%-*s %-*s %-*s %-*s %*s %*s",
                nameWidth, "NAME",
                branchWidth, "BRANCH",
                statusWidth, "STATUS",
                createdWidth, "CREATED",
                activeWidth, "ACTIVE",
                completedWidth, "COMPLETED",
        )
        _, _ = fmt.Fprintln(w, styles.header.Render(header))

        // Print rows
        for _, ws := range workspaces </span><span class="cov0" title="0">{
                // Format name (truncate if needed)
                name := ws.Name
                if len(name) &gt; nameWidth </span><span class="cov0" title="0">{
                        name = name[:nameWidth-1] + "…"
                }</span>

                // Format branch (truncate if needed)
                <span class="cov0" title="0">branch := ws.Branch
                if len(branch) &gt; branchWidth </span><span class="cov0" title="0">{
                        branch = branch[:branchWidth-1] + "…"
                }</span>

                // Format status with color
                <span class="cov0" title="0">statusStr := string(ws.Status)
                if color, ok := styles.statusColors[ws.Status]; ok </span><span class="cov0" title="0">{
                        statusStyle := lipgloss.NewStyle().Foreground(color)
                        statusStr = statusStyle.Render(statusStr)
                }</span>

                // Format created time as relative
                <span class="cov0" title="0">createdStr := tui.RelativeTime(ws.CreatedAt)

                // Count active and completed tasks
                activeCount := countActiveTasks(ws)
                completedCount := countCompletedTasks(ws)

                // Build and print row
                row := fmt.Sprintf("%-*s %-*s %-*s %-*s %*d %*d",
                        nameWidth, name,
                        branchWidth, branch,
                        statusWidth+tui.ColorOffset(statusStr, string(ws.Status)), statusStr,
                        createdWidth, createdStr,
                        activeWidth, activeCount,
                        completedWidth, completedCount,
                )
                _, _ = fmt.Fprintln(w, row)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// getStatusColors returns the semantic color definitions for workspace statuses.
// Exported for testing purposes. Delegates to tui package.
func getStatusColors() map[constants.WorkspaceStatus]lipgloss.AdaptiveColor <span class="cov0" title="0">{
        return tui.StatusColors()
}</span>
</pre>

		<pre class="file" id="file40" style="display: none">// Package cli provides the command-line interface for atlas.
package cli

import (
        "bufio"
        "context"
        "encoding/json"
        stderrors "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/charmbracelet/lipgloss"
        "github.com/mrz1836/atlas/internal/constants"
        "github.com/mrz1836/atlas/internal/domain"
        "github.com/mrz1836/atlas/internal/errors"
        "github.com/mrz1836/atlas/internal/tui"
        "github.com/mrz1836/atlas/internal/workspace"
        "github.com/spf13/cobra"
)

// logsOptions holds the options for the logs command.
type logsOptions struct {
        follow   bool
        stepName string
        taskID   string
        tail     int
}

// logStyles holds lipgloss styles for log output formatting.
type logStyles struct {
        dim      lipgloss.Style
        stepName lipgloss.Style
        info     lipgloss.Style
        warn     lipgloss.Style
        errorSty lipgloss.Style
        debug    lipgloss.Style
}

// newLogStyles creates styles for log output.
func newLogStyles() *logStyles <span class="cov0" title="0">{
        return &amp;logStyles{
                dim:      lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#666666", Dark: "#888888"}),
                stepName: lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#0087AF", Dark: "#00D7FF"}).Bold(true),
                info:     lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#0087AF", Dark: "#00D7FF"}),
                warn:     lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#AF8700", Dark: "#FFD700"}),
                errorSty: lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#AF0000", Dark: "#FF5F5F"}),
                debug:    lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: "#585858", Dark: "#6C6C6C"}),
        }
}</span>

// levelColor returns the appropriate style for a log level.
func (s *logStyles) levelColor(level string) lipgloss.Style <span class="cov0" title="0">{
        switch strings.ToLower(level) </span>{
        case "info":<span class="cov0" title="0">
                return s.info</span>
        case "warn", "warning":<span class="cov0" title="0">
                return s.warn</span>
        case "error", "fatal", "panic":<span class="cov0" title="0">
                return s.errorSty</span>
        case "debug", "trace":<span class="cov0" title="0">
                return s.debug</span>
        default:<span class="cov0" title="0">
                return s.info</span>
        }
}

// logEntry represents a parsed JSON-lines log entry.
type logEntry struct {
        Timestamp     time.Time `json:"ts"`
        Level         string    `json:"level"`
        Event         string    `json:"event"`
        WorkspaceName string    `json:"workspace_name"`
        TaskID        string    `json:"task_id"`
        StepName      string    `json:"step_name"`
        DurationMs    int64     `json:"duration_ms,omitempty"`
        Error         string    `json:"error,omitempty"`
}

// logsResult represents the JSON output for logs operations.
type logsResult struct {
        Status    string `json:"status"`
        Workspace string `json:"workspace"`
        TaskID    string `json:"task_id,omitempty"`
        Error     string `json:"error,omitempty"`
}

// addWorkspaceLogsCmd adds the logs subcommand to the workspace command.
func addWorkspaceLogsCmd(parent *cobra.Command) <span class="cov0" title="0">{
        var (
                follow   bool
                stepName string
                taskID   string
                tail     int
        )

        cmd := &amp;cobra.Command{
                Use:   "logs &lt;name&gt;",
                Short: "View workspace task logs",
                Long: `Display task execution logs for a workspace.

Shows the most recent task's logs by default. Use flags to filter
by specific task or step, or follow logs in real-time.

Examples:
  atlas workspace logs auth           # View most recent task logs
  atlas workspace logs auth -f        # Follow logs in real-time
  atlas workspace logs auth --step validate  # Filter by step
  atlas workspace logs auth --task task-550e8400-e29b-41d4-a716-446655440000  # Specific task
  atlas workspace logs auth --tail 50  # Last 50 lines only`,
                Args: cobra.ExactArgs(1),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        err := runWorkspaceLogs(cmd.Context(), cmd, os.Stdout, args[0], logsOptions{
                                follow:   follow,
                                stepName: stepName,
                                taskID:   taskID,
                                tail:     tail,
                        }, "")
                        // If JSON error was already output, silence cobra's error printing
                        if stderrors.Is(err, errors.ErrJSONErrorOutput) </span><span class="cov0" title="0">{
                                cmd.SilenceErrors = true
                        }</span>
                        <span class="cov0" title="0">return err</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().BoolVarP(&amp;follow, "follow", "f", false, "Follow log output")
        cmd.Flags().StringVar(&amp;stepName, "step", "", "Filter logs by step name")
        cmd.Flags().StringVar(&amp;taskID, "task", "", "Show logs for specific task ID")
        cmd.Flags().IntVarP(&amp;tail, "tail", "n", 0, "Show last n lines (0 = all)")

        parent.AddCommand(cmd)</span>
}

// runWorkspaceLogs executes the workspace logs command.
func runWorkspaceLogs(ctx context.Context, cmd *cobra.Command, w io.Writer, name string, opts logsOptions, storeBaseDir string) error <span class="cov0" title="0">{
        // Check for cancellation at entry
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        // Get output format from global flags
        <span class="cov0" title="0">output := cmd.Flag("output").Value.String()

        return runWorkspaceLogsWithOutput(ctx, w, name, opts, storeBaseDir, output)</span>
}

// runWorkspaceLogsWithOutput executes the workspace logs command with explicit output format.
func runWorkspaceLogsWithOutput(ctx context.Context, w io.Writer, name string, opts logsOptions, storeBaseDir, output string) error <span class="cov0" title="0">{
        logger := Logger()

        // Respect NO_COLOR environment variable (UX-7)
        tui.CheckNoColor()

        // Create store
        store, err := workspace.NewFileStore(storeBaseDir)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(err).Msg("failed to create workspace store")
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputLogsErrorJSON(w, name, "", fmt.Sprintf("failed to create workspace store: %v", err))
                        return errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to create workspace store: %w", err)</span>
        }

        // Check if workspace exists
        <span class="cov0" title="0">exists, err := store.Exists(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                logger.Debug().Err(err).Str("workspace", name).Msg("failed to check workspace existence")
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputLogsErrorJSON(w, name, "", fmt.Sprintf("failed to check workspace: %v", err))
                        return errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to check workspace '%s': %w", name, err)</span>
        }

        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return handleLogsWorkspaceNotFound(name, output, w)
        }</span>

        // Get workspace to access tasks
        <span class="cov0" title="0">ws, err := store.Get(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputLogsErrorJSON(w, name, "", fmt.Sprintf("failed to get workspace: %v", err))
                        return errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get workspace '%s': %w", name, err)</span>
        }

        // Determine which task to show logs for
        <span class="cov0" title="0">taskRef, err := selectTask(ws, opts.taskID)
        if err != nil </span><span class="cov0" title="0">{
                if stderrors.Is(err, errors.ErrNoTasksFound) </span><span class="cov0" title="0">{
                        return handleNoLogsFound(w, name, output)
                }</span>
                <span class="cov0" title="0">if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputLogsErrorJSON(w, name, opts.taskID, err.Error())
                        return errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Construct log file path
        <span class="cov0" title="0">logPath, err := getTaskLogPath(storeBaseDir, name, taskRef.ID)
        if err != nil </span><span class="cov0" title="0">{
                if output == OutputJSON </span><span class="cov0" title="0">{
                        _ = outputLogsErrorJSON(w, name, taskRef.ID, err.Error())
                        return errors.ErrJSONErrorOutput
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Check if log file exists
        <span class="cov0" title="0">if _, err := os.Stat(logPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return handleNoLogsFound(w, name, output)
        }</span>

        // Handle follow mode
        <span class="cov0" title="0">if opts.follow </span><span class="cov0" title="0">{
                return followLogs(ctx, logPath, w, newLogStyles(), output, opts.stepName)
        }</span>

        // Read and display logs
        <span class="cov0" title="0">return displayLogs(ctx, logPath, w, opts, output)</span>
}

// handleLogsWorkspaceNotFound handles the case when a workspace is not found.
func handleLogsWorkspaceNotFound(name, output string, w io.Writer) error <span class="cov0" title="0">{
        if output == OutputJSON </span><span class="cov0" title="0">{
                _ = outputLogsErrorJSON(w, name, "", "workspace not found")
                return errors.ErrJSONErrorOutput
        }</span>
        // Match AC10 format: "Workspace 'nonexistent' not found"
        //nolint:staticcheck // ST1005: AC requires capitalized error for user-facing message
        <span class="cov0" title="0">return fmt.Errorf("Workspace '%s' not found: %w", name, errors.ErrWorkspaceNotFound)</span>
}

// handleNoLogsFound handles the case when no logs exist.
func handleNoLogsFound(w io.Writer, name, output string) error <span class="cov0" title="0">{
        if output == OutputJSON </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, "[]")
                return nil
        }</span>
        // Match AC6 format
        <span class="cov0" title="0">_, _ = fmt.Fprintf(w, "No logs found for workspace '%s'\n", name)
        return nil</span>
}

// selectTask determines which task to show logs for.
func selectTask(ws *domain.Workspace, requestedTaskID string) (*domain.TaskRef, error) <span class="cov0" title="0">{
        if len(ws.Tasks) == 0 </span><span class="cov0" title="0">{
                return nil, errors.ErrNoTasksFound
        }</span>

        // If specific task requested, find it
        <span class="cov0" title="0">if requestedTaskID != "" </span><span class="cov0" title="0">{
                for i := range ws.Tasks </span><span class="cov0" title="0">{
                        if ws.Tasks[i].ID == requestedTaskID </span><span class="cov0" title="0">{
                                return &amp;ws.Tasks[i], nil
                        }</span>
                }
                //nolint:staticcheck // ST1005: AC requires capitalized error for user-facing message
                <span class="cov0" title="0">return nil, fmt.Errorf("Task '%s' not found: %w", requestedTaskID, errors.ErrTaskNotFound)</span>
        }

        // Find most recent task
        <span class="cov0" title="0">return findMostRecentTask(ws.Tasks), nil</span>
}

// findMostRecentTask returns the most recently started task.
func findMostRecentTask(tasks []domain.TaskRef) *domain.TaskRef <span class="cov0" title="0">{
        if len(tasks) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Sort by StartedAt descending (most recent first), with ID as tiebreaker for determinism
        <span class="cov0" title="0">sorted := make([]domain.TaskRef, len(tasks))
        copy(sorted, tasks)
        sort.Slice(sorted, func(i, j int) bool </span><span class="cov0" title="0">{
                // Both nil - use ID as tiebreaker (lexicographically larger ID = more recent convention)
                if sorted[i].StartedAt == nil &amp;&amp; sorted[j].StartedAt == nil </span><span class="cov0" title="0">{
                        return sorted[i].ID &gt; sorted[j].ID
                }</span>
                <span class="cov0" title="0">if sorted[i].StartedAt == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if sorted[j].StartedAt == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                // Equal times - use ID as tiebreaker
                <span class="cov0" title="0">if sorted[i].StartedAt.Equal(*sorted[j].StartedAt) </span><span class="cov0" title="0">{
                        return sorted[i].ID &gt; sorted[j].ID
                }</span>
                <span class="cov0" title="0">return sorted[i].StartedAt.After(*sorted[j].StartedAt)</span>
        })

        <span class="cov0" title="0">return &amp;sorted[0]</span>
}

// getTaskLogPath constructs the path to a task's log file.
func getTaskLogPath(storeBaseDir, wsName, taskID string) (string, error) <span class="cov0" title="0">{
        if storeBaseDir == "" </span><span class="cov0" title="0">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to get user home directory: %w", err)
                }</span>
                <span class="cov0" title="0">storeBaseDir = filepath.Join(home, constants.AtlasHome)</span>
        }
        <span class="cov0" title="0">return filepath.Join(storeBaseDir, constants.WorkspacesDir, wsName, constants.TasksDir, taskID, constants.TaskLogFileName), nil</span>
}

// displayLogs reads and displays log content.
func displayLogs(ctx context.Context, logPath string, w io.Writer, opts logsOptions, output string) error <span class="cov0" title="0">{
        // Check for cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        // Open and read log file
        <span class="cov0" title="0">f, err := os.Open(logPath) //#nosec G304 -- path is constructed from validated workspace name
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open log file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = f.Close() }</span>()

        // Read all lines
        <span class="cov0" title="0">var lines [][]byte
        scanner := bufio.NewScanner(f)
        for scanner.Scan() </span><span class="cov0" title="0">{
                lines = append(lines, append([]byte{}, scanner.Bytes()...))
        }</span>
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read log file: %w", err)
        }</span>

        // Filter by step if requested
        <span class="cov0" title="0">if opts.stepName != "" </span><span class="cov0" title="0">{
                lines = filterByStep(lines, opts.stepName)
                if len(lines) == 0 </span><span class="cov0" title="0">{
                        if output == OutputJSON </span><span class="cov0" title="0">{
                                _, _ = fmt.Fprintln(w, "[]")
                                return nil
                        }</span>
                        <span class="cov0" title="0">_, _ = fmt.Fprintf(w, "No logs found for step '%s'\n", opts.stepName)
                        return nil</span>
                }
        }

        // Apply tail if requested
        <span class="cov0" title="0">if opts.tail &gt; 0 &amp;&amp; len(lines) &gt; opts.tail </span><span class="cov0" title="0">{
                lines = lines[len(lines)-opts.tail:]
        }</span>

        // Output based on format
        <span class="cov0" title="0">if output == OutputJSON </span><span class="cov0" title="0">{
                return outputLogsJSON(w, lines)
        }</span>

        <span class="cov0" title="0">return outputLogsFormatted(w, lines)</span>
}

// filterByStep filters log lines to only those matching the given step name.
func filterByStep(lines [][]byte, stepName string) [][]byte <span class="cov0" title="0">{
        var filtered [][]byte
        stepLower := strings.ToLower(stepName)

        for _, line := range lines </span><span class="cov0" title="0">{
                var entry logEntry
                if err := json.Unmarshal(line, &amp;entry); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid JSON lines
                }

                // Case-insensitive prefix match
                <span class="cov0" title="0">if strings.HasPrefix(strings.ToLower(entry.StepName), stepLower) </span><span class="cov0" title="0">{
                        filtered = append(filtered, line)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

// outputLogsJSON outputs log lines as a JSON array.
func outputLogsJSON(w io.Writer, lines [][]byte) error <span class="cov0" title="0">{
        // Parse each line and collect into array
        entries := make([]json.RawMessage, 0, len(lines))
        for _, line := range lines </span><span class="cov0" title="0">{
                // Validate it's valid JSON before adding
                var js json.RawMessage
                if err := json.Unmarshal(line, &amp;js); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid JSON
                }
                <span class="cov0" title="0">entries = append(entries, js)</span>
        }

        // Handle empty case
        <span class="cov0" title="0">if len(entries) == 0 </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintln(w, "[]")
                return nil
        }</span>

        <span class="cov0" title="0">encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(entries)</span>
}

// outputLogsFormatted outputs log lines with formatting and colors.
//
//nolint:unparam // error return is for interface consistency
func outputLogsFormatted(w io.Writer, lines [][]byte) error <span class="cov0" title="0">{
        styles := newLogStyles()

        for _, line := range lines </span><span class="cov0" title="0">{
                formatted := formatLogLine(line, styles)
                _, _ = fmt.Fprintln(w, formatted)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// formatLogLine formats a single log line with styling.
func formatLogLine(line []byte, styles *logStyles) string <span class="cov0" title="0">{
        var entry logEntry
        if err := json.Unmarshal(line, &amp;entry); err != nil </span><span class="cov0" title="0">{
                // Fallback: return raw line if not valid JSON
                return string(line)
        }</span>

        // Format: "2 min ago [INFO] implement: step execution started"
        <span class="cov0" title="0">timeStr := tui.RelativeTime(entry.Timestamp)
        levelStyle := styles.levelColor(entry.Level)

        // Build the formatted line
        var parts []string
        parts = append(parts, styles.dim.Render(timeStr))
        parts = append(parts, fmt.Sprintf("[%s]", levelStyle.Render(strings.ToUpper(entry.Level))))

        if entry.StepName != "" </span><span class="cov0" title="0">{
                parts = append(parts, styles.stepName.Render(entry.StepName)+":")
        }</span>

        <span class="cov0" title="0">parts = append(parts, entry.Event)

        // Add error details if present
        if entry.Error != "" </span><span class="cov0" title="0">{
                parts = append(parts, styles.errorSty.Render(fmt.Sprintf("(error: %s)", entry.Error)))
        }</span>

        // Add duration if present
        <span class="cov0" title="0">if entry.DurationMs &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, styles.dim.Render(fmt.Sprintf("[%dms]", entry.DurationMs)))
        }</span>

        <span class="cov0" title="0">return strings.Join(parts, " ")</span>
}

// followLogs streams new log entries in real-time.
func followLogs(ctx context.Context, path string, w io.Writer, styles *logStyles, output, stepFilter string) error <span class="cov0" title="0">{
        f, err := os.Open(path) //#nosec G304 -- path is constructed from validated workspace name
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open log file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = f.Close() }</span>()

        // Seek to end of file
        <span class="cov0" title="0">if _, err = f.Seek(0, io.SeekEnd); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to seek to end of file: %w", err)
        }</span>

        <span class="cov0" title="0">if output != OutputJSON </span><span class="cov0" title="0">{
                msg := "Watching for new log entries... (Ctrl+C to stop)"
                if stepFilter != "" </span><span class="cov0" title="0">{
                        msg = fmt.Sprintf("Watching for new log entries (step: %s)... (Ctrl+C to stop)", stepFilter)
                }</span>
                <span class="cov0" title="0">_, _ = fmt.Fprintln(w, styles.dim.Render(msg))</span>
        }

        <span class="cov0" title="0">return pollLogFile(ctx, f, w, styles, output, stepFilter)</span>
}

// pollLogFile continuously polls a log file for new content.
func pollLogFile(ctx context.Context, f *os.File, w io.Writer, styles *logStyles, output, stepFilter string) error <span class="cov0" title="0">{
        reader := bufio.NewReader(f)
        ticker := time.NewTicker(500 * time.Millisecond)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := readNewLines(reader, w, styles, output, stepFilter); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
}

// readNewLines reads and outputs any new lines from the reader.
func readNewLines(reader *bufio.Reader, w io.Writer, styles *logStyles, output, stepFilter string) error <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                line, err := reader.ReadBytes('\n')
                if stderrors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        return nil // No more data
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read log: %w", err)
                }</span>

                // Apply step filter if specified
                <span class="cov0" title="0">if stepFilter != "" </span><span class="cov0" title="0">{
                        var entry logEntry
                        if err := json.Unmarshal(line, &amp;entry); err == nil </span><span class="cov0" title="0">{
                                if !strings.HasPrefix(strings.ToLower(entry.StepName), strings.ToLower(stepFilter)) </span><span class="cov0" title="0">{
                                        continue</span> // Skip lines that don't match the step filter
                                }
                        }
                }

                <span class="cov0" title="0">if output == OutputJSON </span><span class="cov0" title="0">{
                        _, _ = w.Write(line)
                }</span> else<span class="cov0" title="0"> {
                        _, _ = fmt.Fprintln(w, formatLogLine(line, styles))
                }</span>
        }
}

// outputLogsErrorJSON outputs an error result as JSON.
// Returns the encoding error if JSON output fails, which callers typically
// ignore with `_ =` since ErrJSONErrorOutput is already being returned.
// This is intentional: if we can't write JSON, there's no useful fallback,
// and the caller's return of ErrJSONErrorOutput signals to cobra to suppress
// its own error printing regardless of whether our JSON succeeded.
func outputLogsErrorJSON(w io.Writer, name, taskID, errMsg string) error <span class="cov0" title="0">{
        result := logsResult{
                Status:    "error",
                Workspace: name,
                TaskID:    taskID,
                Error:     errMsg,
        }

        encoder := json.NewEncoder(w)
        encoder.SetIndent("", "  ")
        return encoder.Encode(result)
}</span>
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
