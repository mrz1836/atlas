# Implementation Plan: Hook System for Crash Recovery & Context Persistence

**Branch**: `002-hook-system-mvp` | **Date**: 2026-01-17 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-hook-system-mvp/spec.md`
**Reference**: Original design document at `docs/specs_raw/hooks-mvp.md`

## Summary

Implement a durable, crash-resistant context persistence system for ATLAS that enables AI agents to resume interrupted tasks without data loss. The system uses a two-file approach: `hook.json` (machine-readable state) and `HOOK.md` (human/AI-readable recovery instructions), with automatic checkpoints on git operations and validation passes, plus cryptographic signing of validation receipts using HD-derived keys.

## Technical Context

**Language/Version**: Go 1.24+ (matches existing ATLAS codebase)
**Primary Dependencies**:
- Existing ATLAS packages (task, workspace, domain, config, validation)
- `github.com/bsv-blockchain/go-sdk` (NEW: HD key derivation and ECDSA signing)
- Standard library: `crypto/sha256`, `encoding/hex`, `os`, `time`

**Storage**: File-based (JSON for state, Markdown for recovery guide) - follows "Text is Truth" principle
**Testing**: `magex test:race` with testify (require/assert) - table-driven tests
**Target Platform**: Local CLI (macOS/Linux) - same as ATLAS
**Project Type**: Single Go application extending existing ATLAS CLI
**Performance Goals**:
- Checkpoint creation < 1 second
- Recovery file read/parse < 100ms
- Resume time < 30 seconds after restart

**Constraints**:
- No database (file-based only per constitution)
- No breaking changes to existing task.json schema
- Hook files co-located with task files
- Master key file permissions: 0600

**Scale/Scope**: Single-agent system, ~50 checkpoints max per task, single machine

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Evidence/Notes |
|-----------|--------|----------------|
| I. Human Authority at Checkpoints | ✅ PASS | Recovery file is human-readable; human controls abandon/resume decisions |
| II. Git is the Backbone | ✅ PASS | Auto-checkpoints on git commit/push/PR; git state captured in checkpoints |
| III. Text is Truth | ✅ PASS | JSON state file + Markdown recovery file; no database; all state inspectable |
| IV. Ship Then Iterate | ✅ PASS | MVP scope defined; multi-machine sync explicitly deferred |
| V. Context-First Go | ✅ PASS | Will use context.Context for all checkpoint/recovery operations |
| VI. Validation Before Delivery | ✅ PASS | Cryptographic receipts prove validation ran; wrapper git hooks non-destructive |
| VII. Transparent State | ✅ PASS | Hook files in task directory; `atlas hook status` for visibility |

**Gate Status**: PASS - No violations requiring justification.

## Project Structure

### Documentation (this feature)

```text
specs/002-hook-system-mvp/
├── plan.md              # This file
├── research.md          # Phase 0: Technology decisions and patterns
├── data-model.md        # Phase 1: Entity definitions and relationships
├── quickstart.md        # Phase 1: User-facing documentation
├── contracts/           # Phase 1: Internal API contracts (Go interfaces)
└── tasks.md             # Phase 2 output (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
internal/
├── domain/
│   └── hook.go            # NEW: Hook, HookState, StepCheckpoint, ValidationReceipt types
├── hook/                  # NEW: Hook system package
│   ├── store.go           # HookStore interface and FileStore implementation
│   ├── state.go           # Hook state machine (ValidTransitions, helpers)
│   ├── checkpoint.go      # Auto-checkpoint triggers and interval checkpointer
│   ├── recovery.go        # Crash detection and recovery recommendations
│   ├── markdown.go        # HOOK.md generation from hook.json
│   ├── signer.go          # ReceiptSigner interface definition
│   └── signer_hd.go       # HD key implementation (go-sdk) of ReceiptSigner
├── crypto/                # NEW: Cryptographic utilities (interfaced for swappability)
│   ├── signer.go          # Signer/Verifier interfaces (shared across packages)
│   ├── signer_test.go     # Interface contract tests
│   └── hd/                # HD key implementation package
│       └── signer.go      # go-sdk implementation (can be swapped)
├── cli/
│   ├── hook.go            # NEW: atlas hook {status, checkpoints, verify-receipt, regenerate, export}
│   ├── checkpoint.go      # NEW: atlas checkpoint "description"
│   └── cleanup.go         # MODIFY: Add --hooks flag support
│   └── start.go           # MODIFY: Create hook on task start
│   └── resume.go          # MODIFY: Read hook for recovery context
├── task/
│   └── engine.go          # MODIFY: Integrate hook state updates during step execution
└── git/
    └── hooks.go           # NEW: Git hook wrapper installation for auto-checkpoints

~/.atlas/
├── keys/                  # NEW: Cryptographic key storage
│   └── master.key         # HD master key (0600 permissions)
└── workspaces/<name>/tasks/<id>/
    ├── task.json          # EXISTING: Task state
    ├── task.log           # EXISTING: Execution log
    ├── hook.json          # NEW: Hook state (source of truth)
    └── HOOK.md            # NEW: Human-readable recovery guide
```

**Structure Decision**: Single project structure extending existing ATLAS internal packages. New `internal/hook/` package follows patterns from `internal/task/` and `internal/workspace/`. Domain types in `internal/domain/hook.go` follow existing import rules.

## Testing Strategy

All hook system functionality MUST have comprehensive unit tests. Tests follow existing ATLAS patterns: table-driven tests with `testify` (require/assert), run via `magex test:race`.

### Test File Structure

```text
internal/
├── domain/
│   └── hook_test.go           # Entity validation, state enum tests
├── hook/
│   ├── store_test.go          # FileStore CRUD, atomic writes, concurrency
│   ├── state_test.go          # State machine transitions, invalid transitions
│   ├── checkpoint_test.go     # Auto-checkpoint triggers, interval checkpointer, pruning
│   ├── recovery_test.go       # Crash detection, recovery recommendations, stale detection
│   ├── markdown_test.go       # HOOK.md generation, template rendering
│   ├── signer_test.go         # ReceiptSigner interface contract tests (run against all implementations)
│   ├── signer_hd_test.go      # HDReceiptSigner-specific tests (go-sdk integration)
│   └── signer_mock.go         # MockSigner for testing hook logic without crypto
├── crypto/
│   └── hd/
│       └── signer_test.go     # HD key derivation, key generation, permissions
├── cli/
│   ├── hook_test.go           # CLI subcommand tests
│   └── checkpoint_test.go     # Manual checkpoint CLI tests
└── git/
    └── hooks_test.go          # Git hook installation, wrapper chaining
```

**Interface testing pattern**: `signer_test.go` defines contract tests that ANY `ReceiptSigner` implementation must pass. This ensures new implementations (e.g., replacing `go-sdk`) maintain the same behavior.

### Test Scenarios by Component

#### State Machine Tests (`state_test.go`)

| Scenario | Input | Expected |
|----------|-------|----------|
| Valid transition | `step_pending` → `step_running` | Success, event recorded |
| Invalid transition | `completed` → `step_running` | Error: terminal state |
| All valid paths | Each state | All allowed transitions work |
| History append | Any transition | Event added to history |
| Terminal state detection | `completed`, `failed`, `abandoned` | Returns true |

#### Checkpoint Tests (`checkpoint_test.go`)

| Scenario | Input | Expected |
|----------|-------|----------|
| Git commit trigger | Post-commit hook fires | Checkpoint created with `git_commit` trigger |
| Validation pass trigger | Validation exits 0 | Checkpoint created with `validation` trigger |
| Interval checkpoint | 5 minutes elapsed in `step_running` | Checkpoint created with `interval` trigger |
| Manual checkpoint | User runs `atlas checkpoint "desc"` | Checkpoint created with `manual` trigger |
| Pruning at max | 51st checkpoint added | Oldest checkpoint removed, 50 remain |
| File snapshot capture | Checkpoint created | Files in `files_touched` have snapshots |
| Git state capture | Checkpoint created | Branch, commit, dirty status recorded |

#### Recovery Tests (`recovery_test.go`)

| Scenario | Input | Expected |
|----------|-------|----------|
| Stale hook detection | `UpdatedAt` > 5m ago, non-terminal | `isStale` returns true |
| Fresh hook | `UpdatedAt` < 5m ago | `isStale` returns false |
| Terminal state not stale | `completed` + old timestamp | `isStale` returns false |
| Recovery recommendation: retry | Crash during `analyze` step | `RecommendedAction: retry_step` |
| Recovery recommendation: manual | Crash during `implement` step | `RecommendedAction: manual` |
| Recovery recommendation: checkpoint | Recent checkpoint exists | `RecommendedAction: retry_from_checkpoint` |
| Recovery context population | Crash detected | All fields populated correctly |

#### Signing Tests (`signer_test.go`, `signer_hd_test.go`)

**Interface contract tests** (run against all ReceiptSigner implementations):

| Scenario | Input | Expected |
|----------|-------|----------|
| Sign populates fields | Valid receipt | Signature and KeyPath fields set |
| Verify accepts valid | Signed receipt | Returns nil |
| Verify rejects tampered | Modified receipt | Returns error |
| KeyPath format | Task index | Returns non-empty string |
| Sign is deterministic | Same receipt twice | Same signature |

**HDReceiptSigner-specific tests** (go-sdk implementation):

| Scenario | Input | Expected |
|----------|-------|----------|
| Master key generation | First run, no key exists | Key created with 0600 permissions |
| Key derivation path | Task index 5 | Path: `m/44'/236'/0'/5/0` |
| Config-driven path | Custom coin type | Uses config values |
| Missing key handling | No master key | Graceful error, no panic |

**MockSigner** (for testing hook logic without crypto overhead):
- Always returns deterministic test signatures
- Verify always passes (or fails, configurable)
- Used in hook/, checkpoint/, recovery/ tests

#### Store Tests (`store_test.go`)

| Scenario | Input | Expected |
|----------|-------|----------|
| Create hook | New task | `hook.json` created atomically |
| Load hook | Existing `hook.json` | Hook struct populated correctly |
| Update hook | Modified hook | Atomic write, no corruption on crash |
| Concurrent access | Two goroutines updating | File lock prevents corruption |
| Corrupted file | Invalid JSON | Clear error message |
| Missing file | No `hook.json` | `ErrHookNotFound` returned |

#### Markdown Generation Tests (`markdown_test.go`)

| Scenario | Input | Expected |
|----------|-------|----------|
| Fresh task | Hook in `initializing` | Minimal HOOK.md, no recovery section |
| Mid-step crash | Hook in `step_running` | "What To Do Now" shows retry instructions |
| Completed steps | 3 steps done | "DO NOT REPEAT" section lists all 3 |
| With receipts | Validation receipts exist | Receipts table populated |
| With checkpoints | 5 checkpoints | Timeline shows all 5 |
| Regeneration | Existing HOOK.md | Overwritten from hook.json |

#### Git Hook Tests (`hooks_test.go`)

| Scenario | Input | Expected |
|----------|-------|----------|
| Fresh install | No existing hooks | Wrapper script installed |
| Existing hook preserved | `post-commit` exists | Renamed to `.original`, wrapper chains |
| Uninstall | Remove hooks | Original restored, wrapper removed |
| Hook execution | Commit made | Checkpoint created via wrapper |
| Hook failure isolated | Checkpoint fails | Original hook still runs |

### Integration Test Scenarios

End-to-end scenarios testing the full crash recovery flow:

| Scenario | Steps | Verification |
|----------|-------|--------------|
| **Happy path recovery** | Start task → Run 2 steps → Simulate crash → Resume | Resumes at step 3, steps 1-2 not repeated |
| **Checkpoint recovery** | Start task → Create checkpoint → Crash → Resume | Checkpoint info in recovery context |
| **Validation receipt chain** | Run validation → Check receipt → Verify signature | Receipt valid, signature verifies |
| **Config override** | Set `max_checkpoints: 10` → Create 15 | Only 10 checkpoints retained |
| **Stale detection** | Start task → Wait 6 minutes → Check status | Hook marked as potentially crashed |
| **HOOK.md accuracy** | Various states → Generate HOOK.md | Content matches hook.json |

### Test Fixtures

Test fixtures located in `internal/hook/testdata/`:

```text
testdata/
└── hooks/
    ├── valid_initializing.json    # Fresh hook (no signatures)
    ├── valid_step_running.json    # Mid-execution (no signatures)
    ├── valid_completed.json       # Terminal state (no signatures)
    ├── with_checkpoints.json      # 5 checkpoints (no signatures)
    ├── corrupted.json             # Invalid JSON
    └── stale.json                 # Old timestamp
```

**Note**: No `keys/` directory - test keys are generated at runtime. Receipt signing tests generate ephemeral keys in `t.TempDir()`. Fixtures with signatures (`with_receipts.json`) are generated during test setup, not committed.

### Gitleaks Compliance

**IMPORTANT**: Test keys and fixtures must not trigger gitleaks false positives. To ensure `go-pre-commit run --all-files` passes:

**Primary approach: Generate keys at test runtime** (REQUIRED)

Never commit cryptographic keys to the repository. Generate them in `TestMain()` or use `t.TempDir()`:

```go
func TestMain(m *testing.M) {
    // Generate ephemeral test key - never committed to repo
    testKeyPath = filepath.Join(t.TempDir(), "atlas-test-master.key")
    generateTestKey(testKeyPath)
    os.Exit(m.Run())
}
```

**If inline secrets are unavoidable** (e.g., test vector hashes):

Use gitleaks inline ignore comments:
```go
var testSignature = "3045022100..." // gitleaks:allow (test vector)
```

**If file-level ignores are needed** (last resort):

Add fingerprints to `.gitleaksignore` (NOT `.gitleaks.toml`):
```
# .gitleaksignore - specific findings only, not broad patterns
# Format: fingerprint:path:line
abc123def456:internal/hook/testdata/test_vectors.go:42
```

**Rules**:
- DO NOT commit real or realistic-looking private keys
- DO NOT use `.gitleaks.toml` custom rules
- DO prefer runtime generation over any ignore mechanism
- DO use `// gitleaks:allow` inline comments sparingly with clear justification

### Test Coverage Requirements

- **Minimum coverage**: 80% line coverage for `internal/hook/` package
- **Critical paths**: 100% coverage for state transitions, signing, and recovery logic
- **Table-driven**: All tests use table-driven patterns for comprehensive case coverage
- **Race detection**: All tests pass with `-race` flag

## Complexity Tracking

> No Constitution violations requiring justification. Design follows all seven principles.
